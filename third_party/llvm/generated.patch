Auto generated patch. Do not edit or delete it, even if empty.
diff -ruN --strip-trailing-cr a/clang/include/clang/Analysis/FlowSensitive/StorageLocation.h b/clang/include/clang/Analysis/FlowSensitive/StorageLocation.h
--- a/clang/include/clang/Analysis/FlowSensitive/StorageLocation.h
+++ b/clang/include/clang/Analysis/FlowSensitive/StorageLocation.h
@@ -17,7 +17,6 @@
 #include "clang/AST/Decl.h"
 #include "clang/AST/Type.h"
 #include "llvm/ADT/DenseMap.h"
-#include "llvm/ADT/StringRef.h"
 #include "llvm/Support/Debug.h"
 #include <cassert>
 
@@ -153,11 +152,6 @@
     return {SyntheticFields.begin(), SyntheticFields.end()};
   }
 
-  /// Add a synthetic field, if none by that name is already present.
-  void addSyntheticField(llvm::StringRef Name, StorageLocation &Loc) {
-    SyntheticFields.insert({Name, &Loc});
-  }
-
   /// Changes the child storage location for a field `D` of reference type.
   /// All other fields cannot change their storage location and always retain
   /// the storage location passed to the `RecordStorageLocation` constructor.
@@ -170,11 +164,6 @@
     Children[&D] = Loc;
   }
 
-  /// Add a child storage location for a field `D`, if not already present.
-  void addChild(const ValueDecl &D, StorageLocation *Loc) {
-    Children.insert({&D, Loc});
-  }
-
   llvm::iterator_range<FieldToLoc::const_iterator> children() const {
     return {Children.begin(), Children.end()};
   }
diff -ruN --strip-trailing-cr a/clang/lib/Analysis/FlowSensitive/Transfer.cpp b/clang/lib/Analysis/FlowSensitive/Transfer.cpp
--- a/clang/lib/Analysis/FlowSensitive/Transfer.cpp
+++ b/clang/lib/Analysis/FlowSensitive/Transfer.cpp
@@ -20,17 +20,14 @@
 #include "clang/AST/OperationKinds.h"
 #include "clang/AST/Stmt.h"
 #include "clang/AST/StmtVisitor.h"
-#include "clang/AST/Type.h"
 #include "clang/Analysis/FlowSensitive/ASTOps.h"
 #include "clang/Analysis/FlowSensitive/AdornedCFG.h"
 #include "clang/Analysis/FlowSensitive/DataflowAnalysisContext.h"
 #include "clang/Analysis/FlowSensitive/DataflowEnvironment.h"
 #include "clang/Analysis/FlowSensitive/NoopAnalysis.h"
 #include "clang/Analysis/FlowSensitive/RecordOps.h"
-#include "clang/Analysis/FlowSensitive/StorageLocation.h"
 #include "clang/Analysis/FlowSensitive/Value.h"
 #include "clang/Basic/Builtins.h"
-#include "clang/Basic/LLVM.h"
 #include "clang/Basic/OperatorKinds.h"
 #include "llvm/Support/Casting.h"
 #include <assert.h>
@@ -290,7 +287,7 @@
     }
   }
 
-  void VisitCastExpr(const CastExpr *S) {
+  void VisitImplicitCastExpr(const ImplicitCastExpr *S) {
     const Expr *SubExpr = S->getSubExpr();
     assert(SubExpr != nullptr);
 
@@ -320,60 +317,6 @@
       break;
     }
 
-    case CK_BaseToDerived: {
-      // This is a cast of (single-layer) pointer or reference to a record type.
-      // We should now model the fields for the derived type.
-
-      // Get the RecordStorageLocation for the record object underneath.
-      RecordStorageLocation *Loc = nullptr;
-      if (S->getType()->isPointerType()) {
-        auto *PV = Env.get<PointerValue>(*SubExpr);
-        assert(PV != nullptr);
-        if (PV == nullptr)
-          break;
-        Loc = cast<RecordStorageLocation>(&PV->getPointeeLoc());
-      } else {
-        assert(S->getType()->isRecordType());
-        if (SubExpr->isGLValue()) {
-          Loc = Env.get<RecordStorageLocation>(*SubExpr);
-        } else {
-          Loc = &Env.getResultObjectLocation(*SubExpr);
-        }
-      }
-      if (!Loc) {
-        // Nowhere to add children or propagate from, so we're done.
-        break;
-      }
-
-      // Get the derived record type underneath the reference or pointer.
-      QualType Derived = S->getType().getNonReferenceType();
-      if (Derived->isPointerType()) {
-        Derived = Derived->getPointeeType();
-      }
-
-      // Add children to the storage location for fields (including synthetic
-      // fields) of the derived type and initialize their values.
-      for (const FieldDecl *Field :
-           Env.getDataflowAnalysisContext().getModeledFields(Derived)) {
-        assert(Field != nullptr);
-        QualType FieldType = Field->getType();
-        if (FieldType->isReferenceType()) {
-          Loc->addChild(*Field, nullptr);
-        } else {
-          Loc->addChild(*Field, &Env.createStorageLocation(FieldType));
-        }
-
-        for (const auto &Entry :
-             Env.getDataflowAnalysisContext().getSyntheticFields(Derived)) {
-          Loc->addSyntheticField(Entry.getKey(),
-                                 Env.createStorageLocation(Entry.getValue()));
-        }
-      }
-      Env.initializeFieldsWithValues(*Loc, Derived);
-
-      // Fall through to propagate SubExpr's StorageLocation to the CastExpr.
-      [[fallthrough]];
-    }
     case CK_IntegralCast:
       // FIXME: This cast creates a new integral value from the
       // subexpression. But, because we don't model integers, we don't
@@ -381,9 +324,10 @@
       // modeling is added, then update this code to create a fresh location and
       // value.
     case CK_UncheckedDerivedToBase:
-    case CK_DerivedToBase:
     case CK_ConstructorConversion:
     case CK_UserDefinedConversion:
+      // FIXME: Add tests that excercise CK_UncheckedDerivedToBase,
+      // CK_ConstructorConversion, and CK_UserDefinedConversion.
     case CK_NoOp: {
       // FIXME: Consider making `Environment::getStorageLocation` skip noop
       // expressions (this and other similar expressions in the file) instead
@@ -740,6 +684,15 @@
     propagateValue(*SubExpr, *S, Env);
   }
 
+  void VisitCXXStaticCastExpr(const CXXStaticCastExpr *S) {
+    if (S->getCastKind() == CK_NoOp) {
+      const Expr *SubExpr = S->getSubExpr();
+      assert(SubExpr != nullptr);
+
+      propagateValueOrStorageLocation(*SubExpr, *S, Env);
+    }
+  }
+
   void VisitConditionalOperator(const ConditionalOperator *S) {
     const Environment *TrueEnv = StmtToEnv.getEnvironment(*S->getTrueExpr());
     const Environment *FalseEnv = StmtToEnv.getEnvironment(*S->getFalseExpr());
diff -ruN --strip-trailing-cr a/clang/unittests/Analysis/FlowSensitive/TransferTest.cpp b/clang/unittests/Analysis/FlowSensitive/TransferTest.cpp
--- a/clang/unittests/Analysis/FlowSensitive/TransferTest.cpp
+++ b/clang/unittests/Analysis/FlowSensitive/TransferTest.cpp
@@ -9,25 +9,17 @@
 #include "TestingSupport.h"
 #include "clang/AST/ASTContext.h"
 #include "clang/AST/Decl.h"
-#include "clang/AST/Expr.h"
-#include "clang/AST/ExprCXX.h"
-#include "clang/AST/OperationKinds.h"
-#include "clang/ASTMatchers/ASTMatchFinder.h"
 #include "clang/ASTMatchers/ASTMatchers.h"
-#include "clang/Analysis/FlowSensitive/DataflowAnalysis.h"
 #include "clang/Analysis/FlowSensitive/DataflowAnalysisContext.h"
 #include "clang/Analysis/FlowSensitive/DataflowEnvironment.h"
 #include "clang/Analysis/FlowSensitive/NoopAnalysis.h"
-#include "clang/Analysis/FlowSensitive/NoopLattice.h"
 #include "clang/Analysis/FlowSensitive/RecordOps.h"
 #include "clang/Analysis/FlowSensitive/StorageLocation.h"
 #include "clang/Analysis/FlowSensitive/Value.h"
 #include "clang/Basic/LangStandard.h"
 #include "clang/Testing/TestAST.h"
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/StringMap.h"
 #include "llvm/ADT/StringRef.h"
-#include "llvm/Support/Casting.h"
 #include "llvm/Testing/Support/Error.h"
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
@@ -35,7 +27,6 @@
 #include <string>
 #include <string_view>
 #include <utility>
-#include <vector>
 
 namespace clang {
 namespace dataflow {
@@ -3550,7 +3541,7 @@
   testFunction(Code, "noexceptTarget");
 }
 
-TEST(TransferTest, StaticCastNoOp) {
+TEST(TransferTest, StaticCast) {
   std::string Code = R"(
     void target(int Foo) {
       int Bar = static_cast<int>(Foo);
@@ -3570,13 +3561,6 @@
         const ValueDecl *BarDecl = findValueDecl(ASTCtx, "Bar");
         ASSERT_THAT(BarDecl, NotNull());
 
-        const auto *Cast = ast_matchers::selectFirst<CXXStaticCastExpr>(
-            "cast",
-            ast_matchers::match(ast_matchers::cxxStaticCastExpr().bind("cast"),
-                                ASTCtx));
-        ASSERT_THAT(Cast, NotNull());
-        ASSERT_EQ(Cast->getCastKind(), CK_NoOp);
-
         const auto *FooVal = Env.getValue(*FooDecl);
         const auto *BarVal = Env.getValue(*BarDecl);
         EXPECT_TRUE(isa<IntegerValue>(FooVal));
@@ -3585,268 +3569,6 @@
       });
 }
 
-TEST(TransferTest, StaticCastBaseToDerived) {
-  std::string Code = R"cc(
-    struct Base {
-      char C;
-    };
-    struct Intermediate : public Base {
-      bool B;
-    };
-    struct Derived : public Intermediate {
-      int I;
-    };
-    Base& getBaseRef();
-    void target(Base* BPtr) {
-      Derived* DPtr = static_cast<Derived*>(BPtr);
-      DPtr->C;
-      DPtr->B;
-      DPtr->I;
-      Derived& DRef = static_cast<Derived&>(*BPtr);
-      DRef.C;
-      DRef.B;
-      DRef.I;
-      Derived& DRefFromFunc = static_cast<Derived&>(getBaseRef());
-      DRefFromFunc.C;
-      DRefFromFunc.B;
-      DRefFromFunc.I;
-      // [[p]]
-    }
-  )cc";
-  runDataflow(
-      Code,
-      [](const llvm::StringMap<DataflowAnalysisState<NoopLattice>> &Results,
-         ASTContext &ASTCtx) {
-        ASSERT_THAT(Results.keys(), UnorderedElementsAre("p"));
-        const Environment &Env = getEnvironmentAtAnnotation(Results, "p");
-
-        const ValueDecl *BPtrDecl = findValueDecl(ASTCtx, "BPtr");
-        ASSERT_THAT(BPtrDecl, NotNull());
-
-        const ValueDecl *DPtrDecl = findValueDecl(ASTCtx, "DPtr");
-        ASSERT_THAT(DPtrDecl, NotNull());
-
-        const ValueDecl *DRefDecl = findValueDecl(ASTCtx, "DRef");
-        ASSERT_THAT(DRefDecl, NotNull());
-
-        const ValueDecl *DRefFromFuncDecl =
-            findValueDecl(ASTCtx, "DRefFromFunc");
-        ASSERT_THAT(DRefFromFuncDecl, NotNull());
-
-        const auto *Cast = ast_matchers::selectFirst<CXXStaticCastExpr>(
-            "cast",
-            ast_matchers::match(ast_matchers::cxxStaticCastExpr().bind("cast"),
-                                ASTCtx));
-        ASSERT_THAT(Cast, NotNull());
-        ASSERT_EQ(Cast->getCastKind(), CK_BaseToDerived);
-
-        EXPECT_EQ(Env.getValue(*BPtrDecl), Env.getValue(*DPtrDecl));
-        EXPECT_EQ(&Env.get<PointerValue>(*BPtrDecl)->getPointeeLoc(),
-                  Env.getStorageLocation(*DRefDecl));
-        // For DRefFromFunc, not crashing when analyzing the field accesses is
-        // enough.
-      });
-}
-
-TEST(TransferTest, ExplicitDerivedToBaseCast) {
-  std::string Code = R"cc(
-    struct Base {};
-    struct Derived : public Base {};
-    void target(Derived D) {
-      (Base*)&D;
-      // [[p]]
-    }
-)cc";
-  runDataflow(
-      Code,
-      [](const llvm::StringMap<DataflowAnalysisState<NoopLattice>> &Results,
-         ASTContext &ASTCtx) {
-        ASSERT_THAT(Results.keys(), UnorderedElementsAre("p"));
-        const Environment &Env = getEnvironmentAtAnnotation(Results, "p");
-
-        auto *Cast = ast_matchers::selectFirst<ImplicitCastExpr>(
-            "cast", ast_matchers::match(
-                        ast_matchers::implicitCastExpr().bind("cast"), ASTCtx));
-        ASSERT_THAT(Cast, NotNull());
-        ASSERT_EQ(Cast->getCastKind(), CK_DerivedToBase);
-
-        auto *AddressOf = ast_matchers::selectFirst<UnaryOperator>(
-            "addressof",
-            ast_matchers::match(ast_matchers::unaryOperator().bind("addressof"),
-                                ASTCtx));
-        ASSERT_THAT(AddressOf, NotNull());
-        ASSERT_EQ(AddressOf->getOpcode(), UO_AddrOf);
-
-        EXPECT_EQ(Env.getValue(*Cast), Env.getValue(*AddressOf));
-      });
-}
-
-TEST(TransferTest, ConstructorConversion) {
-  std::string Code = R"cc(
-    struct Base {};
-    struct Derived : public Base {};
-    void target(Derived D) {
-      Base B = (Base)D;
-      // [[p]]
-    }
-)cc";
-  runDataflow(
-      Code,
-      [](const llvm::StringMap<DataflowAnalysisState<NoopLattice>> &Results,
-         ASTContext &ASTCtx) {
-        ASSERT_THAT(Results.keys(), UnorderedElementsAre("p"));
-        const Environment &Env = getEnvironmentAtAnnotation(Results, "p");
-
-        auto *Cast = ast_matchers::selectFirst<CStyleCastExpr>(
-            "cast", ast_matchers::match(
-                        ast_matchers::cStyleCastExpr().bind("cast"), ASTCtx));
-        ASSERT_THAT(Cast, NotNull());
-        ASSERT_EQ(Cast->getCastKind(), CK_ConstructorConversion);
-
-        auto &DLoc = getLocForDecl<StorageLocation>(ASTCtx, Env, "D");
-        auto &BLoc = getLocForDecl<StorageLocation>(ASTCtx, Env, "B");
-        EXPECT_NE(&BLoc, &DLoc);
-      });
-}
-
-TEST(TransferTest, UserDefinedConversion) {
-  std::string Code = R"cc(
-    struct To {};
-    struct From {
-        operator To();
-    };
-    void target(From F) {
-        To T = (To)F;
-        // [[p]]
-    }
-)cc";
-  runDataflow(
-      Code,
-      [](const llvm::StringMap<DataflowAnalysisState<NoopLattice>> &Results,
-         ASTContext &ASTCtx) {
-        ASSERT_THAT(Results.keys(), UnorderedElementsAre("p"));
-        const Environment &Env = getEnvironmentAtAnnotation(Results, "p");
-
-        auto *Cast = ast_matchers::selectFirst<ImplicitCastExpr>(
-            "cast", ast_matchers::match(
-                        ast_matchers::implicitCastExpr().bind("cast"), ASTCtx));
-        ASSERT_THAT(Cast, NotNull());
-        ASSERT_EQ(Cast->getCastKind(), CK_UserDefinedConversion);
-
-        auto &FLoc = getLocForDecl<StorageLocation>(ASTCtx, Env, "F");
-        auto &TLoc = getLocForDecl<StorageLocation>(ASTCtx, Env, "T");
-        EXPECT_NE(&TLoc, &FLoc);
-      });
-}
-
-TEST(TransferTest, ImplicitUncheckedDerivedToBaseCast) {
-  std::string Code = R"cc(
-    struct Base {
-      void method();
-    };
-    struct Derived : public Base {};
-    void target(Derived D) {
-      D.method();
-      // [[p]]
-    }
-)cc";
-  runDataflow(
-      Code,
-      [](const llvm::StringMap<DataflowAnalysisState<NoopLattice>> &Results,
-         ASTContext &ASTCtx) {
-        ASSERT_THAT(Results.keys(), UnorderedElementsAre("p"));
-        const Environment &Env = getEnvironmentAtAnnotation(Results, "p");
-
-        auto *Cast = ast_matchers::selectFirst<ImplicitCastExpr>(
-            "cast", ast_matchers::match(
-                        ast_matchers::implicitCastExpr().bind("cast"), ASTCtx));
-        ASSERT_THAT(Cast, NotNull());
-        ASSERT_EQ(Cast->getCastKind(), CK_UncheckedDerivedToBase);
-
-        auto &DLoc = getLocForDecl<StorageLocation>(ASTCtx, Env, "D");
-        EXPECT_EQ(Env.getStorageLocation(*Cast), &DLoc);
-      });
-}
-
-TEST(TransferTest, ImplicitDerivedToBaseCast) {
-  std::string Code = R"cc(
-    struct Base {};
-    struct Derived : public Base {};
-    void target() {
-      Base* B = new Derived();
-      // [[p]]
-    }
-)cc";
-  runDataflow(
-      Code,
-      [](const llvm::StringMap<DataflowAnalysisState<NoopLattice>> &Results,
-         ASTContext &ASTCtx) {
-        ASSERT_THAT(Results.keys(), UnorderedElementsAre("p"));
-        const Environment &Env = getEnvironmentAtAnnotation(Results, "p");
-
-        auto *Cast = ast_matchers::selectFirst<ImplicitCastExpr>(
-            "cast", ast_matchers::match(
-                        ast_matchers::implicitCastExpr().bind("cast"), ASTCtx));
-        ASSERT_THAT(Cast, NotNull());
-        ASSERT_EQ(Cast->getCastKind(), CK_DerivedToBase);
-
-        auto *New = ast_matchers::selectFirst<CXXNewExpr>(
-            "new", ast_matchers::match(ast_matchers::cxxNewExpr().bind("new"),
-                                       ASTCtx));
-        ASSERT_THAT(New, NotNull());
-
-        EXPECT_EQ(Env.getValue(*Cast), Env.getValue(*New));
-      });
-}
-
-TEST(TransferTest, ReinterpretCast) {
-  std::string Code = R"cc(
-    struct S {
-        int I;
-    };
-
-    void target(unsigned char* Bytes) {
-        S& SRef = reinterpret_cast<S&>(Bytes);
-        SRef.I;
-        S* SPtr = reinterpret_cast<S*>(Bytes);
-        SPtr->I;
-        // [[p]]
-    }
-  )cc";
-  runDataflow(Code, [](const llvm::StringMap<DataflowAnalysisState<NoopLattice>>
-                           &Results,
-                       ASTContext &ASTCtx) {
-    ASSERT_THAT(Results.keys(), UnorderedElementsAre("p"));
-    const Environment &Env = getEnvironmentAtAnnotation(Results, "p");
-    const ValueDecl *I = findValueDecl(ASTCtx, "I");
-    ASSERT_THAT(I, NotNull());
-
-    // No particular knowledge of I's value is modeled, but for both casts,
-    // the fields of S are modeled.
-
-    {
-      auto &Loc = getLocForDecl<RecordStorageLocation>(ASTCtx, Env, "SRef");
-      std::vector<const ValueDecl *> Children;
-      for (const auto &Entry : Loc.children()) {
-        Children.push_back(Entry.getFirst());
-      }
-
-      EXPECT_THAT(Children, UnorderedElementsAre(I));
-    }
-
-    {
-      auto &Loc = cast<RecordStorageLocation>(
-          getValueForDecl<PointerValue>(ASTCtx, Env, "SPtr").getPointeeLoc());
-      std::vector<const ValueDecl *> Children;
-      for (const auto &Entry : Loc.children()) {
-        Children.push_back(Entry.getFirst());
-      }
-
-      EXPECT_THAT(Children, UnorderedElementsAre(I));
-    }
-  });
-}
-
 TEST(TransferTest, IntegralCast) {
   std::string Code = R"(
     void target(int Foo) {
diff -ruN --strip-trailing-cr a/llvm/include/llvm/Linker/IRMover.h b/llvm/include/llvm/Linker/IRMover.h
--- a/llvm/include/llvm/Linker/IRMover.h
+++ b/llvm/include/llvm/Linker/IRMover.h
@@ -10,6 +10,7 @@
 #define LLVM_LINKER_IRMOVER_H
 
 #include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/DenseMap.h"
 #include "llvm/ADT/DenseSet.h"
 #include "llvm/ADT/FunctionExtras.h"
 #include "llvm/Support/Compiler.h"
@@ -19,6 +20,8 @@
 class Error;
 class GlobalValue;
 class Metadata;
+class MDNode;
+class NamedMDNode;
 class Module;
 class StructType;
 class TrackingMDRef;
@@ -67,6 +70,8 @@
   using LazyCallback =
       llvm::unique_function<void(GlobalValue &GV, ValueAdder Add)>;
 
+  using NamedMDNodesT = DenseMap<const NamedMDNode *, DenseSet<const MDNode *>>;
+
   /// Move in the provide values in \p ValuesToLink from \p Src.
   ///
   /// - \p AddLazyFor is a call back that the IRMover will call when a global
@@ -86,6 +91,7 @@
   Module &Composite;
   IdentifiedStructTypeSet IdentifiedStructTypes;
   MDMapT SharedMDs; ///< A Metadata map to use for all calls to \a move().
+  NamedMDNodesT NamedMDNodes; ///< Cache for IRMover::linkNamedMDNodes().
 };
 
 } // End llvm namespace
diff -ruN --strip-trailing-cr a/llvm/lib/Linker/IRMover.cpp b/llvm/lib/Linker/IRMover.cpp
--- a/llvm/lib/Linker/IRMover.cpp
+++ b/llvm/lib/Linker/IRMover.cpp
@@ -293,7 +293,7 @@
   std::unique_ptr<Module> SrcM;
 
   // Lookup table to optimize IRMover::linkNamedMDNodes().
-  DenseMap<StringRef, DenseSet<MDNode *>> NamedMDNodes;
+  IRMover::NamedMDNodesT &NamedMDNodes;
 
   /// See IRMover::move().
   IRMover::LazyCallback AddLazyFor;
@@ -440,10 +440,12 @@
   IRLinker(Module &DstM, MDMapT &SharedMDs,
            IRMover::IdentifiedStructTypeSet &Set, std::unique_ptr<Module> SrcM,
            ArrayRef<GlobalValue *> ValuesToLink,
-           IRMover::LazyCallback AddLazyFor, bool IsPerformingImport)
-      : DstM(DstM), SrcM(std::move(SrcM)), AddLazyFor(std::move(AddLazyFor)),
-        TypeMap(Set), GValMaterializer(*this), LValMaterializer(*this),
-        SharedMDs(SharedMDs), IsPerformingImport(IsPerformingImport),
+           IRMover::LazyCallback AddLazyFor, bool IsPerformingImport,
+           IRMover::NamedMDNodesT &NamedMDNodes)
+      : DstM(DstM), SrcM(std::move(SrcM)), NamedMDNodes(NamedMDNodes),
+        AddLazyFor(std::move(AddLazyFor)), TypeMap(Set),
+        GValMaterializer(*this), LValMaterializer(*this), SharedMDs(SharedMDs),
+        IsPerformingImport(IsPerformingImport),
         Mapper(ValueMap, RF_ReuseAndMutateDistinctMDs | RF_IgnoreMissingLocals,
                &TypeMap, &GValMaterializer),
         IndirectSymbolMCID(Mapper.registerAlternateMappingContext(
@@ -1138,7 +1140,7 @@
 
     NamedMDNode *DestNMD = DstM.getOrInsertNamedMetadata(NMD.getName());
 
-    auto &Inserted = NamedMDNodes[DestNMD->getName()];
+    auto &Inserted = NamedMDNodes[DestNMD];
     if (Inserted.empty()) {
       // Must be the first module, copy everything from DestNMD.
       Inserted.insert(DestNMD->operands().begin(), DestNMD->operands().end());
@@ -1683,6 +1685,6 @@
                     LazyCallback AddLazyFor, bool IsPerformingImport) {
   IRLinker TheIRLinker(Composite, SharedMDs, IdentifiedStructTypes,
                        std::move(Src), ValuesToLink, std::move(AddLazyFor),
-                       IsPerformingImport);
+                       IsPerformingImport, NamedMDNodes);
   return TheIRLinker.run();
 }
diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/libc/BUILD.bazel b/utils/bazel/llvm-project-overlay/libc/BUILD.bazel
--- a/utils/bazel/llvm-project-overlay/libc/BUILD.bazel
+++ b/utils/bazel/llvm-project-overlay/libc/BUILD.bazel
@@ -3749,6 +3749,14 @@
 )
 
 libc_math_function(
+    name = "fmodbf16",
+    additional_deps = [
+        ":__support_fputil_bfloat16",
+        ":__support_fputil_generic_fmod",
+    ],
+)
+
+libc_math_function(
     name = "fmodf",
     additional_deps = [
         ":__support_fputil_generic_fmod",
diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/libc/test/src/math/smoke/BUILD.bazel b/utils/bazel/llvm-project-overlay/libc/test/src/math/smoke/BUILD.bazel
--- a/utils/bazel/llvm-project-overlay/libc/test/src/math/smoke/BUILD.bazel
+++ b/utils/bazel/llvm-project-overlay/libc/test/src/math/smoke/BUILD.bazel
@@ -739,6 +739,16 @@
 )
 
 math_test(
+    name = "fmodbf16",
+    hdrs = [
+        "FModTest.h",
+    ],
+    deps = [
+        "//libc:__support_fputil_bfloat16",
+    ],
+)
+
+math_test(
     name = "fmodf",
     hdrs = ["FModTest.h"],
 )
diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/llvm/BUILD.bazel b/utils/bazel/llvm-project-overlay/llvm/BUILD.bazel
--- a/utils/bazel/llvm-project-overlay/llvm/BUILD.bazel
+++ b/utils/bazel/llvm-project-overlay/llvm/BUILD.bazel
@@ -2223,7 +2223,6 @@
             "lib/Target/AArch64/AArch64GenDisassemblerTables.inc": [
                 "-gen-disassembler",
                 "-ignore-non-decodable-operands",
-                "-ignore-fully-defined-operands",
             ],
             "lib/Target/AArch64/AArch64GenSystemOperands.inc": ["-gen-searchable-tables"],
             "lib/Target/AArch64/AArch64GenExegesis.inc": ["-gen-exegesis"],
