Auto generated patch. Do not edit or delete it, even if empty.
diff -ruN --strip-trailing-cr a/clang/lib/Format/Format.cpp b/clang/lib/Format/Format.cpp
--- a/clang/lib/Format/Format.cpp
+++ b/clang/lib/Format/Format.cpp
@@ -2643,13 +2643,14 @@
       for (FormatToken *Tok = Line->First; Tok && Tok->Next; Tok = Tok->Next) {
         if (Tok->isNot(TT_PointerOrReference))
           continue;
-        // Don't treat space in `void foo() &&` as evidence.
+        // Don't treat space in `void foo() &&` or `void() &&` as evidence.
         if (const auto *Prev = Tok->getPreviousNonComment()) {
           if (Prev->is(tok::r_paren) && Prev->MatchingParen) {
             if (const auto *Func =
                     Prev->MatchingParen->getPreviousNonComment()) {
               if (Func->isOneOf(TT_FunctionDeclarationName, TT_StartOfName,
-                                TT_OverloadedOperator)) {
+                                TT_OverloadedOperator) ||
+                  Func->isTypeName(LangOpts)) {
                 continue;
               }
             }
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaDeclAttr.cpp b/clang/lib/Sema/SemaDeclAttr.cpp
--- a/clang/lib/Sema/SemaDeclAttr.cpp
+++ b/clang/lib/Sema/SemaDeclAttr.cpp
@@ -1970,6 +1970,13 @@
   if (!FD)
     return;
 
+  // Skip explicit specializations here as they may have
+  // a user-provided definition that may deliberately differ from the primary
+  // template. If an explicit specialization truly never returns, the user
+  // should explicitly mark it with [[noreturn]].
+  if (FD->getTemplateSpecializationKind() == TSK_ExplicitSpecialization)
+    return;
+
   auto *NonConstFD = const_cast<FunctionDecl *>(FD);
   DiagnosticsEngine &Diags = S.getDiagnostics();
   if (Diags.isIgnored(diag::warn_falloff_nonvoid, FD->getLocation()) &&
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaDecl.cpp b/clang/lib/Sema/SemaDecl.cpp
--- a/clang/lib/Sema/SemaDecl.cpp
+++ b/clang/lib/Sema/SemaDecl.cpp
@@ -3267,6 +3267,14 @@
     if (isa<UsedAttr>(I) || isa<RetainAttr>(I))
       continue;
 
+    if (isa<InferredNoReturnAttr>(I)) {
+      if (auto *FD = dyn_cast<FunctionDecl>(New)) {
+        if (FD->getTemplateSpecializationKind() == TSK_ExplicitSpecialization)
+          continue; // Don't propagate inferred noreturn attributes to explicit
+                    // specializations.
+      }
+    }
+
     if (mergeDeclAttribute(*this, New, I, LocalAMK))
       foundAny = true;
   }
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaOverload.cpp b/clang/lib/Sema/SemaOverload.cpp
--- a/clang/lib/Sema/SemaOverload.cpp
+++ b/clang/lib/Sema/SemaOverload.cpp
@@ -8042,8 +8042,8 @@
 
     Candidate.IgnoreObjectArgument =
         isa<CXXMethodDecl>(Candidate.Function) &&
-        cast<CXXMethodDecl>(Candidate.Function)
-            ->isImplicitObjectMemberFunction() &&
+        !cast<CXXMethodDecl>(Candidate.Function)
+             ->isExplicitObjectMemberFunction() &&
         !isa<CXXConstructorDecl>(Candidate.Function);
 
     Candidate.ExplicitCallArguments = Args.size();
diff -ruN --strip-trailing-cr a/clang/test/Driver/offload-target.c b/clang/test/Driver/offload-target.c
--- a/clang/test/Driver/offload-target.c
+++ b/clang/test/Driver/offload-target.c
@@ -10,7 +10,7 @@
 // RUN: | FileCheck %s -check-prefix=CUDA
 // CUDA: "nvptx64-nvidia-cuda" - "clang", inputs: ["[[INPUT:.+]]"], output: "[[NV_OBJ:.+]]"
 
-// RUN: %clang -### --offload-targets=amdgcn-amd-amdhsa,nvptx64-nvidia-cuda -fopenmp \
+// RUN: %clang -### --offload-targets=amdgcn-amd-amdhsa,nvptx64-nvidia-cuda -fopenmp=libomp \
 // RUN:   -Xarch_amdgcn --offload-arch=gfx90a -Xarch_nvptx64 --offload-arch=sm_89 \
 // RUN:   -nogpulib -nogpuinc %s -ccc-print-bindings 2>&1 \
 // RUN: | FileCheck %s -check-prefix=OPENMP
diff -ruN --strip-trailing-cr a/clang/test/Interpreter/pretty-print.c b/clang/test/Interpreter/pretty-print.c
--- a/clang/test/Interpreter/pretty-print.c
+++ b/clang/test/Interpreter/pretty-print.c
@@ -3,7 +3,7 @@
 // RUN: cat %s | clang-repl -Xcc -xc  | FileCheck %s
 // RUN: cat %s | clang-repl -Xcc -std=c++11 | FileCheck %s
 
-// UNSUPPORTED: hwasan
+// UNSUPPORTED: hwasan, msan
 
 
 char c = 'a'; c
diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/cxx2b-deducing-this.cpp b/clang/test/SemaCXX/cxx2b-deducing-this.cpp
--- a/clang/test/SemaCXX/cxx2b-deducing-this.cpp
+++ b/clang/test/SemaCXX/cxx2b-deducing-this.cpp
@@ -1357,3 +1357,35 @@
 }
 
 }
+
+namespace GH147046_regression {
+
+template <typename z> struct ai {
+    ai(z::ah);
+};
+
+template <typename z> struct ak {
+    template <typename am> void an(am, z);
+    template <typename am> static void an(am, ai<z>);
+};
+template <typename> struct ao {};
+
+template <typename ap>
+auto ar(ao<ap> at) -> decltype(ak<ap>::an(at, 0));
+// expected-note@-1 {{candidate template ignored: substitution failure [with ap = GH147046_regression::ay]: no matching function for call to 'an'}}
+
+class aw;
+struct ax {
+    typedef int ah;
+};
+struct ay {
+    typedef aw ah;
+};
+
+ao<ay> az ;
+ai<ax> bd(0);
+void f() {
+    ar(az); // expected-error {{no matching function for call to 'ar'}}
+}
+
+}
diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/wreturn-always-throws.cpp b/clang/test/SemaCXX/wreturn-always-throws.cpp
--- a/clang/test/SemaCXX/wreturn-always-throws.cpp
+++ b/clang/test/SemaCXX/wreturn-always-throws.cpp
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -fsyntax-only -fcxx-exceptions -fexceptions -Wreturn-type -verify %s
+// RUN: %clang_cc1 -fsyntax-only -fcxx-exceptions -fexceptions -Wreturn-type -Winvalid-noreturn -verify %s
 // expected-no-diagnostics
 
 namespace std {
@@ -44,3 +44,22 @@
   throwErrorTemplate("ERROR");
   (void)ensureZeroTemplate(42);
 }
+
+// Ensure that explicit specialization of a member function does not inherit
+// the warning from the primary template.
+
+template<typename T>
+struct S {
+  void f();
+  void g();
+};
+
+template<typename T>
+void S<T>::f() { throw 0; } 
+template<>
+void S<int>::f() {}
+
+template<typename T> 
+void S<T>::g() {}  
+template<> 
+void S<int>::g() { throw 0; }
diff -ruN --strip-trailing-cr a/clang/unittests/Format/FormatTest.cpp b/clang/unittests/Format/FormatTest.cpp
--- a/clang/unittests/Format/FormatTest.cpp
+++ b/clang/unittests/Format/FormatTest.cpp
@@ -12103,6 +12103,8 @@
   Prefix = "void a() const &;\n"
            "void b() const &;\n";
   verifyFormat(Prefix + "int *x;", Prefix + "int* x;", DerivePointerAlignment);
+
+  verifyGoogleFormat("MACRO(int*, std::function<void() &&>);");
 }
 
 TEST_F(FormatTest, PointerAlignmentFallback) {
diff -ruN --strip-trailing-cr a/clang-tools-extra/clangd/refactor/tweaks/CMakeLists.txt b/clang-tools-extra/clangd/refactor/tweaks/CMakeLists.txt
--- a/clang-tools-extra/clangd/refactor/tweaks/CMakeLists.txt
+++ b/clang-tools-extra/clangd/refactor/tweaks/CMakeLists.txt
@@ -14,9 +14,9 @@
 add_clang_library(clangDaemonTweaks OBJECT
   AddUsing.cpp
   AnnotateHighlightings.cpp
+  DumpAST.cpp
   DefineInline.cpp
   DefineOutline.cpp
-  DumpAST.cpp
   ExpandDeducedType.cpp
   ExpandMacro.cpp
   ExtractFunction.cpp
@@ -24,7 +24,6 @@
   MemberwiseConstructor.cpp
   ObjCLocalizeStringLiteral.cpp
   ObjCMemberwiseInitializer.cpp
-  OverridePureVirtuals.cpp
   PopulateSwitch.cpp
   RawStringLiteral.cpp
   RemoveUsingNamespace.cpp
diff -ruN --strip-trailing-cr a/clang-tools-extra/clangd/refactor/tweaks/OverridePureVirtuals.cpp b/clang-tools-extra/clangd/refactor/tweaks/OverridePureVirtuals.cpp
--- a/clang-tools-extra/clangd/refactor/tweaks/OverridePureVirtuals.cpp
+++ b/clang-tools-extra/clangd/refactor/tweaks/OverridePureVirtuals.cpp
@@ -1,374 +0,0 @@
-//===--- OverridePureVirtuals.cpp --------------------------------*- C++-*-===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-//
-// Tweak to automatically generate stubs for pure virtual methods inherited from
-// base classes.
-//
-// Purpose:
-//   - Simplifies making a derived class concrete by automating the creation of
-//     required method overrides from abstract bases.
-//
-// Tweak Summary:
-//
-// 1. Activation Conditions (prepare):
-//    - The tweak activates when the cursor is over a C++ class definition.
-//    - The class must be abstract (it, or its base classes, have unimplemented
-//      pure virtual functions).
-//    - It must also inherit from at least one other abstract class.
-//
-// 2. Identifying Missing Methods:
-//    - The tweak scans the inheritance hierarchy of the current class.
-//    - It identifies all unique pure virtual methods from base classes
-//      that are not yet implemented or overridden.
-//    - These missing methods are then grouped by their original access
-//      specifier (e.g., public, protected).
-//
-// 3. Code Generation and Insertion:
-//    - For each group of missing methods, stubs are inserted.
-//    - If an access specifier section (like `public:`) exists, stubs are
-//      inserted there; otherwise, a new section is created and appended.
-//    - Each generated stub includes the `override` keyword, a `// TODO:`
-//      comment, and a `static_assert(false, ...)` to force a compile-time
-//      error if the method remains unimplemented.
-//    - The base method's signature is adjusted (e.g., `virtual` and `= 0`
-//      are removed for the override).
-//
-// 4. Code Action Provided:
-//    - A single code action titled "Override pure virtual methods" is offered.
-//    - Applying this action results in a single source file modification
-//      containing all the generated method stubs.
-//
-// Example:
-//
-//  class Base {
-//  public:
-//    virtual void publicMethod() = 0;
-//  protected:
-//    virtual auto privateMethod() const -> int = 0;
-//  };
-//
-// Before:
-//                              // cursor here
-//  class Derived : public Base {}^;
-//
-// After:
-//
-// class Derived : public Base {
-//  public:
-//   void publicMethod() override {
-//     // TODO: Implement this pure virtual method.
-//     static_assert(false, "Method `publicMethod` is not implemented.");
-//   }
-//
-//  protected:
-//   auto privateMethod() const -> int override {
-//     // TODO: Implement this pure virtual method.
-//     static_assert(false, "Method `privateMethod` is not implemented.");
-//   }
-// };
-//
-//===----------------------------------------------------------------------===//
-
-#include "refactor/Tweak.h"
-#include "support/Token.h"
-
-#include "clang/AST/ASTContext.h"
-#include "clang/AST/DeclCXX.h"
-#include "clang/AST/Type.h"
-#include "clang/AST/TypeLoc.h"
-#include "clang/Basic/LLVM.h"
-#include "clang/Basic/SourceLocation.h"
-#include "clang/Tooling/Core/Replacement.h"
-#include "llvm/ADT/DenseSet.h"
-#include "llvm/Support/FormatVariadic.h"
-#include <string>
-
-namespace clang {
-namespace clangd {
-namespace {
-
-// This function removes the "virtual" and the "= 0" at the end;
-// e.g.:
-//   "virtual void foo(int var = 0) = 0"  // input.
-//   "void foo(int var = 0)"              // output.
-std::string removePureVirtualSyntax(const std::string &MethodDecl,
-                                    const LangOptions &LangOpts) {
-  assert(!MethodDecl.empty());
-
-  TokenStream TS = lex(MethodDecl, LangOpts);
-
-  std::string DeclString;
-  for (const clangd::Token &Tk : TS.tokens()) {
-    if (Tk.Kind == clang::tok::raw_identifier && Tk.text() == "virtual")
-      continue;
-
-    // If the ending two tokens are "= 0", we break here and we already have the
-    // method's string without the pure virtual syntax.
-    const auto &Next = Tk.next();
-    if (Next.next().Kind == tok::eof && Tk.Kind == clang::tok::equal &&
-        Next.text() == "0")
-      break;
-
-    DeclString += Tk.text();
-    if (Tk.Kind != tok::l_paren && Next.Kind != tok::comma &&
-        Next.Kind != tok::r_paren && Next.Kind != tok::l_paren)
-      DeclString += ' ';
-  }
-  // Trim the last whitespace.
-  if (DeclString.back() == ' ')
-    DeclString.pop_back();
-
-  return DeclString;
-}
-
-class OverridePureVirtuals final : public Tweak {
-public:
-  const char *id() const final; // defined by REGISTER_TWEAK.
-  bool prepare(const Selection &Sel) override;
-  Expected<Effect> apply(const Selection &Sel) override;
-  std::string title() const override { return "Override pure virtual methods"; }
-  llvm::StringLiteral kind() const override {
-    return CodeAction::QUICKFIX_KIND;
-  }
-
-private:
-  // Stores the CXXRecordDecl of the class being modified.
-  const CXXRecordDecl *CurrentDeclDef = nullptr;
-  // Stores pure virtual methods that need overriding, grouped by their original
-  // access specifier.
-  llvm::MapVector<AccessSpecifier, llvm::SmallVector<const CXXMethodDecl *>>
-      MissingMethodsByAccess;
-  // Stores the source locations of existing access specifiers in CurrentDecl.
-  llvm::MapVector<AccessSpecifier, SourceLocation> AccessSpecifierLocations;
-  // Helper function to gather information before applying the tweak.
-  void collectMissingPureVirtuals();
-};
-
-REGISTER_TWEAK(OverridePureVirtuals)
-
-// Function to get all unique pure virtual methods from the entire
-// base class hierarchy of CurrentDeclDef.
-llvm::SmallVector<const clang::CXXMethodDecl *>
-getAllUniquePureVirtualsFromBaseHierarchy(
-    const clang::CXXRecordDecl *CurrentDeclDef) {
-  llvm::SmallVector<const clang::CXXMethodDecl *> AllPureVirtualsInHierarchy;
-  llvm::DenseSet<const clang::CXXMethodDecl *> CanonicalPureVirtualsSeen;
-
-  if (!CurrentDeclDef || !CurrentDeclDef->getDefinition())
-    return AllPureVirtualsInHierarchy;
-
-  const clang::CXXRecordDecl *Def = CurrentDeclDef->getDefinition();
-
-  Def->forallBases([&](const clang::CXXRecordDecl *BaseDefinition) {
-    for (const clang::CXXMethodDecl *Method : BaseDefinition->methods()) {
-      if (Method->isPureVirtual() &&
-          CanonicalPureVirtualsSeen.insert(Method->getCanonicalDecl()).second)
-        AllPureVirtualsInHierarchy.emplace_back(Method);
-    }
-    // Continue iterating through all bases.
-    return true;
-  });
-
-  return AllPureVirtualsInHierarchy;
-}
-
-// Gets canonical declarations of methods already overridden or implemented in
-// class D.
-llvm::SetVector<const CXXMethodDecl *>
-getImplementedOrOverriddenCanonicals(const CXXRecordDecl *D) {
-  llvm::SetVector<const CXXMethodDecl *> ImplementedSet;
-  for (const CXXMethodDecl *M : D->methods()) {
-    // If M provides an implementation for any virtual method it overrides.
-    // A method is an "implementation" if it's virtual and not pure.
-    // Or if it directly overrides a base method.
-    for (const CXXMethodDecl *OverriddenM : M->overridden_methods())
-      ImplementedSet.insert(OverriddenM->getCanonicalDecl());
-  }
-  return ImplementedSet;
-}
-
-// Get the location of every colon of the `AccessSpecifier`.
-llvm::MapVector<AccessSpecifier, SourceLocation>
-getSpecifierLocations(const CXXRecordDecl *D) {
-  llvm::MapVector<AccessSpecifier, SourceLocation> Locs;
-  for (auto *DeclNode : D->decls()) {
-    if (const auto *ASD = llvm::dyn_cast<AccessSpecDecl>(DeclNode))
-      Locs[ASD->getAccess()] = ASD->getColonLoc();
-  }
-  return Locs;
-}
-
-bool hasAbstractBaseAncestor(const clang::CXXRecordDecl *CurrentDecl) {
-  assert(CurrentDecl && CurrentDecl->getDefinition());
-
-  return llvm::any_of(
-      CurrentDecl->getDefinition()->bases(), [](CXXBaseSpecifier BaseSpec) {
-        const auto *D = BaseSpec.getType()->getAsCXXRecordDecl();
-        const auto *Def = D ? D->getDefinition() : nullptr;
-        return Def && Def->isAbstract();
-      });
-}
-
-// The tweak is available if the selection is over an abstract C++ class
-// definition that also inherits from at least one other abstract class.
-bool OverridePureVirtuals::prepare(const Selection &Sel) {
-  const SelectionTree::Node *Node = Sel.ASTSelection.commonAncestor();
-  if (!Node)
-    return false;
-
-  // Make sure we have a definition.
-  CurrentDeclDef = Node->ASTNode.get<CXXRecordDecl>();
-  if (!CurrentDeclDef || !CurrentDeclDef->getDefinition())
-    return false;
-
-  // From now on, we should work with the definition.
-  CurrentDeclDef = CurrentDeclDef->getDefinition();
-
-  // Only offer for abstract classes with abstract bases.
-  return CurrentDeclDef->isAbstract() &&
-         hasAbstractBaseAncestor(CurrentDeclDef);
-}
-
-// Collects all pure virtual methods from base classes that `CurrentDeclDef` has
-// not yet overridden, grouped by their original access specifier.
-//
-// Results are stored in `MissingMethodsByAccess` and `AccessSpecifierLocations`
-// is also populated.
-void OverridePureVirtuals::collectMissingPureVirtuals() {
-  if (!CurrentDeclDef)
-    return;
-
-  AccessSpecifierLocations = getSpecifierLocations(CurrentDeclDef);
-  MissingMethodsByAccess.clear();
-
-  // Get all unique pure virtual methods from the entire base class hierarchy.
-  llvm::SmallVector<const CXXMethodDecl *> AllPureVirtualsInHierarchy =
-      getAllUniquePureVirtualsFromBaseHierarchy(CurrentDeclDef);
-
-  // Get methods already implemented or overridden in CurrentDecl.
-  const auto ImplementedOrOverriddenSet =
-      getImplementedOrOverriddenCanonicals(CurrentDeclDef);
-
-  // Filter AllPureVirtualsInHierarchy to find those not in
-  // ImplementedOrOverriddenSet, which needs to be overriden.
-  for (const CXXMethodDecl *BaseMethod : AllPureVirtualsInHierarchy) {
-    bool AlreadyHandled = ImplementedOrOverriddenSet.contains(BaseMethod);
-    if (!AlreadyHandled)
-      MissingMethodsByAccess[BaseMethod->getAccess()].emplace_back(BaseMethod);
-  }
-}
-
-std::string generateOverrideString(const CXXMethodDecl *Method,
-                                   const LangOptions &LangOpts) {
-  std::string MethodDecl;
-  auto OS = llvm::raw_string_ostream(MethodDecl);
-  Method->print(OS);
-
-  return llvm::formatv(
-             "\n  {0} override {{\n"
-             "    // TODO: Implement this pure virtual method.\n"
-             "    static_assert(false, \"Method `{1}` is not implemented.\");\n"
-             "  }",
-             removePureVirtualSyntax(MethodDecl, LangOpts), Method->getName())
-      .str();
-}
-
-// Free function to generate the string for a group of method overrides.
-std::string generateOverridesStringForGroup(
-    llvm::SmallVector<const CXXMethodDecl *> Methods,
-    const LangOptions &LangOpts) {
-  llvm::SmallVector<std::string> MethodsString;
-  MethodsString.reserve(Methods.size());
-
-  for (const CXXMethodDecl *Method : Methods) {
-    MethodsString.emplace_back(generateOverrideString(Method, LangOpts));
-  }
-
-  return llvm::join(MethodsString, "\n") + '\n';
-}
-
-Expected<Tweak::Effect> OverridePureVirtuals::apply(const Selection &Sel) {
-  // The correctness of this tweak heavily relies on the accurate population of
-  // these members.
-  collectMissingPureVirtuals();
-  // The `prepare` should prevent this. If the prepare identifies an abstract
-  // method, then is must have missing methods.
-  assert(!MissingMethodsByAccess.empty());
-
-  const auto &SM = Sel.AST->getSourceManager();
-  const auto &LangOpts = Sel.AST->getLangOpts();
-
-  tooling::Replacements EditReplacements;
-  // Stores text for new access specifier sections that are not already present
-  // in the class.
-  // Example:
-  //  public:    // ...
-  //  protected: // ...
-  std::string NewSectionsToAppendText;
-
-  for (const auto &[AS, Methods] : MissingMethodsByAccess) {
-    assert(!Methods.empty());
-
-    std::string MethodsGroupString =
-        generateOverridesStringForGroup(Methods, LangOpts);
-
-    auto *ExistingSpecLocIter = AccessSpecifierLocations.find(AS);
-    bool ASExists = ExistingSpecLocIter != AccessSpecifierLocations.end();
-    if (ASExists) {
-      // Access specifier section already exists in the class.
-      // Get location immediately *after* the colon.
-      SourceLocation InsertLoc =
-          ExistingSpecLocIter->second.getLocWithOffset(1);
-
-      // Create a replacement to insert the method declarations.
-      // The replacement is at InsertLoc, has length 0 (insertion), and uses
-      // InsertionText.
-      std::string InsertionText = MethodsGroupString;
-      tooling::Replacement Rep(SM, InsertLoc, 0, InsertionText);
-      if (auto Err = EditReplacements.add(Rep))
-        return llvm::Expected<Tweak::Effect>(std::move(Err));
-    } else {
-      // Access specifier section does not exist in the class.
-      // These methods will be grouped into NewSectionsToAppendText and added
-      // towards the end of the class definition.
-      NewSectionsToAppendText +=
-          getAccessSpelling(AS).str() + ':' + MethodsGroupString;
-    }
-  }
-
-  // After processing all access specifiers, add any newly created sections
-  // (stored in NewSectionsToAppendText) to the end of the class.
-  if (!NewSectionsToAppendText.empty()) {
-    // AppendLoc is the SourceLocation of the closing brace '}' of the class.
-    // The replacement will insert text *before* this closing brace.
-    SourceLocation AppendLoc = CurrentDeclDef->getBraceRange().getEnd();
-    std::string FinalAppendText = std::move(NewSectionsToAppendText);
-
-    if (!CurrentDeclDef->decls_empty() || !EditReplacements.empty()) {
-      FinalAppendText = '\n' + FinalAppendText;
-    }
-
-    // Create a replacement to append the new sections.
-    tooling::Replacement Rep(SM, AppendLoc, 0, FinalAppendText);
-    if (auto Err = EditReplacements.add(Rep))
-      return llvm::Expected<Tweak::Effect>(std::move(Err));
-  }
-
-  if (EditReplacements.empty()) {
-    return llvm::make_error<llvm::StringError>(
-        "No changes to apply (internal error or no methods generated).",
-        llvm::inconvertibleErrorCode());
-  }
-
-  // Return the collected replacements as the effect of this tweak.
-  return Effect::mainFileEdit(SM, EditReplacements);
-}
-
-} // namespace
-} // namespace clangd
-} // namespace clang
diff -ruN --strip-trailing-cr a/clang-tools-extra/clangd/unittests/CMakeLists.txt b/clang-tools-extra/clangd/unittests/CMakeLists.txt
--- a/clang-tools-extra/clangd/unittests/CMakeLists.txt
+++ b/clang-tools-extra/clangd/unittests/CMakeLists.txt
@@ -131,7 +131,6 @@
   tweaks/MemberwiseConstructorTests.cpp
   tweaks/ObjCLocalizeStringLiteralTests.cpp
   tweaks/ObjCMemberwiseInitializerTests.cpp
-  tweaks/OverridePureVirtualsTests.cpp
   tweaks/PopulateSwitchTests.cpp
   tweaks/RawStringLiteralTests.cpp
   tweaks/RemoveUsingNamespaceTests.cpp
diff -ruN --strip-trailing-cr a/clang-tools-extra/clangd/unittests/tweaks/OverridePureVirtualsTests.cpp b/clang-tools-extra/clangd/unittests/tweaks/OverridePureVirtualsTests.cpp
--- a/clang-tools-extra/clangd/unittests/tweaks/OverridePureVirtualsTests.cpp
+++ b/clang-tools-extra/clangd/unittests/tweaks/OverridePureVirtualsTests.cpp
@@ -1,720 +0,0 @@
-//===-- OverridePureVirtualsTests.cpp ---------------------------*- C++ -*-===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#include "TweakTesting.h"
-#include "gtest/gtest.h"
-
-namespace clang {
-namespace clangd {
-namespace {
-
-class OverridePureVirtualsTests : public TweakTest {
-protected:
-  OverridePureVirtualsTests() : TweakTest("OverridePureVirtuals") {}
-};
-
-TEST_F(OverridePureVirtualsTests, MinimalUnavailable) {
-  EXPECT_UNAVAILABLE("class ^C {};");
-}
-
-TEST_F(OverridePureVirtualsTests, MinimalAvailable) {
-  EXPECT_AVAILABLE(R"cpp(
-class B { public: virtual void Foo() = 0; };
-class ^C : public B {};
-)cpp");
-}
-
-TEST_F(OverridePureVirtualsTests, UnavailableWhenOverriden) {
-  EXPECT_UNAVAILABLE(
-      R"cpp(
-class B {
-public:
-  virtual void foo() = 0;
-};
-
-class ^D : public B {
-public:
-  void foo() override;
-};
-)cpp");
-}
-
-TEST_F(OverridePureVirtualsTests, AvailabilityNoOverride) {
-  EXPECT_AVAILABLE(R"cpp(
-class Base {
-public:
-virtual ~Base() = default;
-virtual void F1() = 0;
-virtual void F2() = 0;
-};
-
-class ^Derived : public Base {
-public:
-};
-
-)cpp");
-}
-
-TEST_F(OverridePureVirtualsTests, AvailabilityPartiallyOverridden) {
-  EXPECT_AVAILABLE(R"cpp(
-class Base {
-public:
-virtual ~Base() = default;
-virtual void F1() = 0;
-virtual void F2() = 0;
-};
-
-class ^Derived : public Base {
-public:
-void F1() override;
-};
-)cpp");
-}
-
-TEST_F(OverridePureVirtualsTests, EmptyDerivedClass) {
-  const char *Before = R"cpp(
-class Base {
-public:
-virtual ~Base() = default;
-virtual void F1() = 0;
-virtual void F2(int P1, const int &P2) = 0;
-};
-
-class ^Derived : public Base {};
-)cpp";
-  const auto *Expected = R"cpp(
-class Base {
-public:
-virtual ~Base() = default;
-virtual void F1() = 0;
-virtual void F2(int P1, const int &P2) = 0;
-};
-
-class Derived : public Base {
-public:
-  void F1() override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `F1` is not implemented.");
-  }
-
-  void F2(int P1, const int & P2) override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `F2` is not implemented.");
-  }
-};
-)cpp";
-  auto Applied = apply(Before);
-  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
-}
-
-TEST_F(OverridePureVirtualsTests, SingleBaseClassPartiallyImplemented) {
-  auto Applied = apply(
-      R"cpp(
-class Base {
-public:
-virtual ~Base() = default;
-virtual void F1() = 0;
-virtual void F2() = 0;
-};
-
-class ^Derived : public Base {
-public:
-  void F1() override;
-};
-)cpp");
-
-  const auto *Expected = R"cpp(
-class Base {
-public:
-virtual ~Base() = default;
-virtual void F1() = 0;
-virtual void F2() = 0;
-};
-
-class Derived : public Base {
-public:
-  void F2() override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `F2` is not implemented.");
-  }
-
-  void F1() override;
-};
-)cpp";
-  EXPECT_EQ(Applied, Expected) << "Applied result:\n" << Applied;
-}
-
-TEST_F(OverridePureVirtualsTests, MultipleDirectBaseClasses) {
-  const char *Before = R"cpp(
-class Base1 {
-public:
-  virtual void func1() = 0;
-};
-class Base2 {
-protected:
-  virtual bool func2(char c) const = 0;
-};
-
-class ^Derived : public Base1, public Base2 {};
-)cpp";
-  const auto *Expected = R"cpp(
-class Base1 {
-public:
-  virtual void func1() = 0;
-};
-class Base2 {
-protected:
-  virtual bool func2(char c) const = 0;
-};
-
-class Derived : public Base1, public Base2 {
-public:
-  void func1() override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `func1` is not implemented.");
-  }
-protected:
-  bool func2(char c) const override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `func2` is not implemented.");
-  }
-};
-)cpp";
-  auto Applied = apply(Before);
-  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
-}
-
-TEST_F(OverridePureVirtualsTests, UnnamedParametersInBase) {
-  const char *Before = R"cpp(
-struct S {};
-class Base {
-public:
-  virtual void func(int, const S&, char*) = 0;
-};
-
-class ^Derived : public Base {};
-)cpp";
-
-  const auto *Expected = R"cpp(
-struct S {};
-class Base {
-public:
-  virtual void func(int, const S&, char*) = 0;
-};
-
-class Derived : public Base {
-public:
-  void func(int, const S &, char *) override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `func` is not implemented.");
-  }
-};
-)cpp";
-  auto Applied = apply(Before);
-  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
-}
-
-TEST_F(OverridePureVirtualsTests, DiamondInheritance) {
-  const char *Before = R"cpp(
-class Top {
-public:
-  virtual ~Top() = default;
-  virtual void diamond_func() = 0;
-};
-class Left : virtual public Top {};
-class Right : virtual public Top {};
-class ^Bottom : public Left, public Right {};
-)cpp";
-  const auto *Expected = R"cpp(
-class Top {
-public:
-  virtual ~Top() = default;
-  virtual void diamond_func() = 0;
-};
-class Left : virtual public Top {};
-class Right : virtual public Top {};
-class Bottom : public Left, public Right {
-public:
-  void diamond_func() override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `diamond_func` is not implemented.");
-  }
-};
-)cpp";
-  auto Applied = apply(Before);
-  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
-}
-
-TEST_F(OverridePureVirtualsTests, MixedAccessSpecifiers) {
-  const char *Before = R"cpp(
-class Base {
-public:
-  virtual void pub_func() = 0;
-  virtual void pub_func2(char) const = 0;
-protected:
-  virtual int prot_func(int x) const = 0;
-};
-
-class ^Derived : public Base {
-  int member; // Existing member
-public:
-  Derived(int m) : member(m) {}
-};
-)cpp";
-  const auto *Expected = R"cpp(
-class Base {
-public:
-  virtual void pub_func() = 0;
-  virtual void pub_func2(char) const = 0;
-protected:
-  virtual int prot_func(int x) const = 0;
-};
-
-class Derived : public Base {
-  int member; // Existing member
-public:
-  void pub_func() override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `pub_func` is not implemented.");
-  }
-
-  void pub_func2(char) const override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `pub_func2` is not implemented.");
-  }
-
-  Derived(int m) : member(m) {}
-
-protected:
-  int prot_func(int x) const override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `prot_func` is not implemented.");
-  }
-};
-)cpp";
-  auto Applied = apply(Before);
-  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
-}
-
-TEST_F(OverridePureVirtualsTests, OutOfOrderMixedAccessSpecifiers) {
-  const char *Before = R"cpp(
-class Base {
-public:
-  virtual void pub_func() = 0;
-  virtual void pub_func2(char) const = 0;
-protected:
-  virtual int prot_func(int x) const = 0;
-};
-
-class ^Derived : public Base {
-  int member; // Existing member
-protected:
-  void foo();
-public:
-  Derived(int m) : member(m) {}
-};
-)cpp";
-  const auto *Expected = R"cpp(
-class Base {
-public:
-  virtual void pub_func() = 0;
-  virtual void pub_func2(char) const = 0;
-protected:
-  virtual int prot_func(int x) const = 0;
-};
-
-class Derived : public Base {
-  int member; // Existing member
-protected:
-  int prot_func(int x) const override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `prot_func` is not implemented.");
-  }
-
-  void foo();
-public:
-  void pub_func() override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `pub_func` is not implemented.");
-  }
-
-  void pub_func2(char) const override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `pub_func2` is not implemented.");
-  }
-
-  Derived(int m) : member(m) {}
-};
-)cpp";
-  auto Applied = apply(Before);
-  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
-}
-
-TEST_F(OverridePureVirtualsTests, MultiAccessSpecifiersOverride) {
-  constexpr auto Before = R"cpp(
-class Base {
-public:
-  virtual void foo() = 0;
-protected:
-  virtual void bar() = 0;
-};
-
-class ^Derived : public Base {};
-)cpp";
-
-  constexpr auto Expected = R"cpp(
-class Base {
-public:
-  virtual void foo() = 0;
-protected:
-  virtual void bar() = 0;
-};
-
-class Derived : public Base {
-public:
-  void foo() override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `foo` is not implemented.");
-  }
-protected:
-  void bar() override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `bar` is not implemented.");
-  }
-};
-)cpp";
-  auto Applied = apply(Before);
-  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
-}
-
-TEST_F(OverridePureVirtualsTests, AccessSpecifierAlreadyExisting) {
-  const char *Before = R"cpp(
-class Base {
-public:
-  virtual void func1() = 0;
-};
-
-class ^Derived : public Base {
-public:
-};
-)cpp";
-
-  const auto *Expected = R"cpp(
-class Base {
-public:
-  virtual void func1() = 0;
-};
-
-class Derived : public Base {
-public:
-  void func1() override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `func1` is not implemented.");
-  }
-
-};
-)cpp";
-  auto Applied = apply(Before);
-  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
-}
-
-TEST_F(OverridePureVirtualsTests, ConstexprSpecifier) {
-  ExtraArgs.push_back("-std=c++20");
-
-  constexpr auto Before = R"cpp(
-class B {
-public:
-  constexpr virtual int getValue() const = 0;
-};
-
-class ^D : public B {};
-)cpp";
-
-  constexpr auto Expected = R"cpp(
-class B {
-public:
-  constexpr virtual int getValue() const = 0;
-};
-
-class D : public B {
-public:
-  constexpr int getValue() const override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `getValue` is not implemented.");
-  }
-};
-)cpp";
-  auto Applied = apply(Before);
-  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
-}
-
-TEST_F(OverridePureVirtualsTests, ConstevalSpecifier) {
-  ExtraArgs.push_back("-std=c++20");
-
-  constexpr auto Before = R"cpp(
-class B {
-public:
-  virtual consteval float calculate() = 0;
-};
-
-class ^D : public B {};
-)cpp";
-
-  constexpr auto Expected = R"cpp(
-class B {
-public:
-  virtual consteval float calculate() = 0;
-};
-
-class D : public B {
-public:
-  consteval float calculate() override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `calculate` is not implemented.");
-  }
-};
-)cpp";
-  auto Applied = apply(Before);
-  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
-}
-
-TEST_F(OverridePureVirtualsTests, LValueRefQualifier) {
-  constexpr auto Before = R"cpp(
-class B {
-public:
-  virtual void process() & = 0;
-};
-
-class ^D : public B {};
-)cpp";
-
-  constexpr auto Expected = R"cpp(
-class B {
-public:
-  virtual void process() & = 0;
-};
-
-class D : public B {
-public:
-  void process() & override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `process` is not implemented.");
-  }
-};
-)cpp";
-  auto Applied = apply(Before);
-  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
-}
-
-TEST_F(OverridePureVirtualsTests, RValueRefQualifier) {
-  constexpr auto Before = R"cpp(
-class B {
-public:
-  virtual bool isValid() && = 0;
-};
-
-class ^D : public B {};
-)cpp";
-
-  constexpr auto Expected = R"cpp(
-class B {
-public:
-  virtual bool isValid() && = 0;
-};
-
-class D : public B {
-public:
-  bool isValid() && override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `isValid` is not implemented.");
-  }
-};
-)cpp";
-  auto Applied = apply(Before);
-  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
-}
-
-TEST_F(OverridePureVirtualsTests, SimpleTrailingReturnType) {
-  constexpr auto Before = R"cpp(
-class B {
-public:
-  virtual auto getStatus() -> bool = 0;
-};
-
-class ^D : public B {};
-)cpp";
-
-  constexpr auto Expected = R"cpp(
-class B {
-public:
-  virtual auto getStatus() -> bool = 0;
-};
-
-class D : public B {
-public:
-  auto getStatus() -> bool override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `getStatus` is not implemented.");
-  }
-};
-)cpp";
-  auto Applied = apply(Before);
-  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
-}
-
-TEST_F(OverridePureVirtualsTests, ConstexprLValueRefAndTrailingReturn) {
-  ExtraArgs.push_back("-std=c++20");
-
-  constexpr auto Before = R"cpp(
-class B {
-public:
-  constexpr virtual auto getData() & -> const char * = 0;
-};
-
-class ^D : public B {};
-)cpp";
-
-  constexpr auto Expected = R"cpp(
-class B {
-public:
-  constexpr virtual auto getData() & -> const char * = 0;
-};
-
-class D : public B {
-public:
-  constexpr auto getData() & -> const char * override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `getData` is not implemented.");
-  }
-};
-)cpp";
-  auto Applied = apply(Before);
-  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
-}
-
-TEST_F(OverridePureVirtualsTests, ConstevalRValueRefAndTrailingReturn) {
-  ExtraArgs.push_back("-std=c++20");
-
-  constexpr auto Before = R"cpp(
-class B {
-public:
-  virtual consteval auto foo() && -> double = 0;
-};
-
-class ^D : public B {};
-)cpp";
-
-  constexpr auto Expected = R"cpp(
-class B {
-public:
-  virtual consteval auto foo() && -> double = 0;
-};
-
-class D : public B {
-public:
-  consteval auto foo() && -> double override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `foo` is not implemented.");
-  }
-};
-)cpp";
-  auto Applied = apply(Before);
-  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
-}
-
-TEST_F(OverridePureVirtualsTests, CombinedFeaturesWithTrailingReturnTypes) {
-  ExtraArgs.push_back("-std=c++20");
-
-  constexpr auto Before = R"cpp(
-class B {
-public:
-  virtual auto f1() & -> int = 0;
-  constexpr virtual auto f2() && -> int = 0;
-  virtual consteval auto f3() -> int = 0;
-  virtual auto f4() const & -> char = 0;
-  constexpr virtual auto f5() const && -> bool = 0;
-};
-
-class ^D : public B {};
-)cpp";
-
-  constexpr auto Expected = R"cpp(
-class B {
-public:
-  virtual auto f1() & -> int = 0;
-  constexpr virtual auto f2() && -> int = 0;
-  virtual consteval auto f3() -> int = 0;
-  virtual auto f4() const & -> char = 0;
-  constexpr virtual auto f5() const && -> bool = 0;
-};
-
-class D : public B {
-public:
-  auto f1() & -> int override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `f1` is not implemented.");
-  }
-
-  constexpr auto f2() && -> int override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `f2` is not implemented.");
-  }
-
-  consteval auto f3() -> int override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `f3` is not implemented.");
-  }
-
-  auto f4() const & -> char override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `f4` is not implemented.");
-  }
-
-  constexpr auto f5() const && -> bool override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `f5` is not implemented.");
-  }
-};
-)cpp";
-  auto Applied = apply(Before);
-  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
-}
-
-TEST_F(OverridePureVirtualsTests, DefaultParameters) {
-  ExtraArgs.push_back("-std=c++20");
-
-  constexpr auto Before = R"cpp(
-class B {
-public:
-  virtual void foo(int var = 0) = 0;
-};
-
-class ^D : public B {};
-)cpp";
-
-  constexpr auto Expected = R"cpp(
-class B {
-public:
-  virtual void foo(int var = 0) = 0;
-};
-
-class D : public B {
-public:
-  void foo(int var = 0) override {
-    // TODO: Implement this pure virtual method.
-    static_assert(false, "Method `foo` is not implemented.");
-  }
-};
-)cpp";
-  auto Applied = apply(Before);
-  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
-}
-
-} // namespace
-} // namespace clangd
-} // namespace clang
diff -ruN --strip-trailing-cr a/libc/src/__support/FPUtil/bfloat16.h b/libc/src/__support/FPUtil/bfloat16.h
--- a/libc/src/__support/FPUtil/bfloat16.h
+++ b/libc/src/__support/FPUtil/bfloat16.h
@@ -12,6 +12,7 @@
 #include "src/__support/CPP/bit.h"
 #include "src/__support/CPP/type_traits.h"
 #include "src/__support/FPUtil/cast.h"
+#include "src/__support/FPUtil/comparison_operations.h"
 #include "src/__support/FPUtil/dyadic_float.h"
 #include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
@@ -57,6 +58,30 @@
     uint32_t x_bits = static_cast<uint32_t>(bits) << 16U;
     return cpp::bit_cast<float>(x_bits);
   }
+
+  LIBC_INLINE constexpr bool operator==(BFloat16 other) const {
+    return fputil::equals(*this, other);
+  }
+
+  LIBC_INLINE constexpr bool operator!=(BFloat16 other) const {
+    return !fputil::equals(*this, other);
+  }
+
+  LIBC_INLINE constexpr bool operator<(BFloat16 other) const {
+    return fputil::less_than(*this, other);
+  }
+
+  LIBC_INLINE constexpr bool operator<=(BFloat16 other) const {
+    return fputil::less_than_or_equals(*this, other);
+  }
+
+  LIBC_INLINE constexpr bool operator>(BFloat16 other) const {
+    return fputil::greater_than(*this, other);
+  }
+
+  LIBC_INLINE constexpr bool operator>=(BFloat16 other) const {
+    return fputil::greater_than_or_equals(*this, other);
+  }
 }; // struct BFloat16
 
 } // namespace fputil
diff -ruN --strip-trailing-cr a/libc/src/__support/FPUtil/CMakeLists.txt b/libc/src/__support/FPUtil/CMakeLists.txt
--- a/libc/src/__support/FPUtil/CMakeLists.txt
+++ b/libc/src/__support/FPUtil/CMakeLists.txt
@@ -274,6 +274,7 @@
     bfloat16.h
   DEPENDS
     .cast
+    .comparison_operations
     .dyadic_float
     libc.src.__support.CPP.bit
     libc.src.__support.CPP.type_traits
diff -ruN --strip-trailing-cr a/lldb/source/Plugins/ObjectFile/Minidump/MinidumpFileBuilder.cpp b/lldb/source/Plugins/ObjectFile/Minidump/MinidumpFileBuilder.cpp
--- a/lldb/source/Plugins/ObjectFile/Minidump/MinidumpFileBuilder.cpp
+++ b/lldb/source/Plugins/ObjectFile/Minidump/MinidumpFileBuilder.cpp
@@ -201,7 +201,7 @@
     return error;
   };
 
-  llvm::minidump::SystemInfo sys_info;
+  llvm::minidump::SystemInfo sys_info{};
   sys_info.ProcessorArch =
       static_cast<llvm::support::little_t<ProcessorArchitecture>>(arch);
   // Global offset to beginning of a csd_string in a data section
@@ -378,7 +378,7 @@
     helper_data.AppendData(&signature, sizeof(llvm::support::ulittle32_t));
     helper_data.AppendData(uuid.begin(), uuid.size());
 
-    llvm::minidump::Module m;
+    llvm::minidump::Module m{};
     m.BaseOfImage = static_cast<llvm::support::ulittle64_t>(
         mod->GetObjectFile()->GetBaseAddress().GetLoadAddress(&target));
     m.SizeOfImage = static_cast<llvm::support::ulittle32_t>(mod_size);
@@ -745,7 +745,7 @@
   if (error.Fail())
     return error;
 
-  lldb_private::minidump::MinidumpMiscInfo misc_info;
+  lldb_private::minidump::MinidumpMiscInfo misc_info{};
   misc_info.size = static_cast<llvm::support::ulittle32_t>(
       sizeof(lldb_private::minidump::MinidumpMiscInfo));
   // Default set flags1 to 0, in case that we will not be able to
diff -ruN --strip-trailing-cr a/llvm/test/CodeGen/NVPTX/pr126337.ll b/llvm/test/CodeGen/NVPTX/pr126337.ll
--- a/llvm/test/CodeGen/NVPTX/pr126337.ll
+++ b/llvm/test/CodeGen/NVPTX/pr126337.ll
@@ -1,6 +1,6 @@
 ; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
 ; RUN: llc < %s -mtriple=nvptx64 -mcpu=sm_70 | FileCheck %s
-; RUN: %if ptxas %{ llc < %s -mtriple=nvptx64 -mcpu=sm_70 | %ptxas-verify %}
+; RUN: %if ptxas %{ llc < %s -mtriple=nvptx64 -mcpu=sm_70 | %ptxas -arch=sm_70 -c - %}
 
 ; This IR should compile without triggering assertions in LICM
 ; when the CopyToReg from %0 in the first BB gets eliminated
diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/libc/BUILD.bazel b/utils/bazel/llvm-project-overlay/libc/BUILD.bazel
--- a/utils/bazel/llvm-project-overlay/libc/BUILD.bazel
+++ b/utils/bazel/llvm-project-overlay/libc/BUILD.bazel
@@ -1002,6 +1002,19 @@
 )
 
 libc_support_library(
+    name = "__support_fputil_comparison_operations",
+    hdrs = [
+        "src/__support/FPUtil/comparison_operations.h",
+    ],
+    deps = [
+        ":__support_cpp_type_traits",
+        ":__support_fputil_fenv_impl",
+        ":__support_fputil_fp_bits",
+        ":__support_macros_config",
+    ],
+)
+
+libc_support_library(
     name = "__support_file_file",
     srcs = [
         "include/llvm-libc-types/off_t.h",
@@ -1085,6 +1098,7 @@
         ":__support_cpp_bit",
         ":__support_cpp_type_traits",
         ":__support_fputil_cast",
+        ":__support_fputil_comparison_operations",
         ":__support_fputil_dyadic_float",
         ":__support_macros_config",
         ":__support_macros_properties_types",
@@ -1159,6 +1173,7 @@
     name = "__support_fputil_rounding_mode",
     hdrs = ["src/__support/FPUtil/rounding_mode.h"],
     deps = [
+        ":__support_cpp_type_traits",
         ":__support_macros_attributes",
         ":__support_macros_config",
         ":hdr_fenv_macros",
@@ -1919,8 +1934,8 @@
     srcs = ["src/math/generic/common_constants.cpp"],
     hdrs = ["src/math/generic/common_constants.h"],
     deps = [
-        ":__support_math_exp_constants",
         ":__support_math_acosh_float_constants",
+        ":__support_math_exp_constants",
         ":__support_number_pair",
     ],
 )
@@ -2003,10 +2018,10 @@
         ":__support_fputil_fma",
         ":__support_fputil_multiply_add",
         ":__support_fputil_nearest_integer",
-        ":__support_math_exp_utils",
-        ":__support_math_exp10f_utils",
-        ":__support_math_acoshf_utils",
         ":__support_macros_properties_cpu_features",
+        ":__support_math_acoshf_utils",
+        ":__support_math_exp10f_utils",
+        ":__support_math_exp_utils",
         ":common_constants",
     ],
 )
@@ -2058,8 +2073,8 @@
         ":__support_fputil_cast",
         ":__support_fputil_fp_bits",
         ":__support_fputil_nearest_integer",
-        ":__support_math_expf16_utils",
         ":__support_math_exp10_float16_constants",
+        ":__support_math_expf16_utils",
     ],
 )
 
@@ -2067,7 +2082,6 @@
     name = "__support_math_acos",
     hdrs = ["src/__support/math/acos.h"],
     deps = [
-        ":__support_math_asin_utils",
         ":__support_fputil_double_double",
         ":__support_fputil_dyadic_float",
         ":__support_fputil_fenv_impl",
@@ -2076,8 +2090,9 @@
         ":__support_fputil_polyeval",
         ":__support_fputil_sqrt",
         ":__support_macros_optimization",
-        ":__support_macros_properties_types",
         ":__support_macros_properties_cpu_features",
+        ":__support_macros_properties_types",
+        ":__support_math_asin_utils",
     ],
 )
 
@@ -2085,13 +2100,13 @@
     name = "__support_math_acosf",
     hdrs = ["src/__support/math/acosf.h"],
     deps = [
-        ":__support_math_inv_trigf_utils",
         ":__support_fputil_except_value_utils",
         ":__support_fputil_fp_bits",
         ":__support_fputil_multiply_add",
         ":__support_fputil_polyeval",
         ":__support_fputil_sqrt",
         ":__support_macros_optimization",
+        ":__support_math_inv_trigf_utils",
     ],
 )
 
@@ -2100,6 +2115,7 @@
     hdrs = ["src/__support/math/acosf16.h"],
     deps = [
         ":__support_fputil_cast",
+        ":__support_fputil_except_value_utils",
         ":__support_fputil_fma",
         ":__support_fputil_multiply_add",
         ":__support_fputil_nearest_integer",
@@ -2121,10 +2137,10 @@
     name = "__support_math_acoshf_utils",
     hdrs = ["src/__support/math/acoshf_utils.h"],
     deps = [
-        ":__support_math_acosh_float_constants",
         ":__support_fputil_fp_bits",
         ":__support_fputil_multiply_add",
         ":__support_fputil_polyeval",
+        ":__support_math_acosh_float_constants",
     ],
 )
 
@@ -2132,12 +2148,12 @@
     name = "__support_math_acoshf",
     hdrs = ["src/__support/math/acoshf.h"],
     deps = [
-        ":__support_math_acoshf_utils",
         ":__support_fputil_fenv_impl",
         ":__support_fputil_fp_bits",
         ":__support_fputil_multiply_add",
         ":__support_fputil_sqrt",
         ":__support_macros_optimization",
+        ":__support_math_acoshf_utils",
     ],
 )
 
@@ -2145,7 +2161,6 @@
     name = "__support_math_acoshf16",
     hdrs = ["src/__support/math/acoshf16.h"],
     deps = [
-        ":__support_math_acoshf_utils",
         ":__support_fputil_cast",
         ":__support_fputil_except_value_utils",
         ":__support_fputil_fenv_impl",
@@ -2154,6 +2169,7 @@
         ":__support_fputil_polyeval",
         ":__support_fputil_sqrt",
         ":__support_macros_optimization",
+        ":__support_math_acoshf_utils",
     ],
 )
 
@@ -2161,12 +2177,12 @@
     name = "__support_math_asin_utils",
     hdrs = ["src/__support/math/asin_utils.h"],
     deps = [
-        ":__support_integer_literals",
         ":__support_fputil_double_double",
         ":__support_fputil_dyadic_float",
         ":__support_fputil_multiply_add",
         ":__support_fputil_nearest_integer",
         ":__support_fputil_polyeval",
+        ":__support_integer_literals",
         ":__support_macros_optimization",
     ],
 )
@@ -2175,6 +2191,8 @@
     name = "__support_math_erff",
     hdrs = ["src/__support/math/erff.h"],
     deps = [
+        ":__support_fputil_except_value_utils",
+        ":__support_fputil_fp_bits",
         ":__support_fputil_multiply_add",
         ":__support_fputil_polyeval",
         ":__support_macros_optimization",
@@ -2215,7 +2233,7 @@
         ":__support_fputil_nearest_integer",
         ":__support_fputil_polyeval",
         ":__support_macros_attributes",
-        ":llvm_libc_macros_float16_macros"
+        ":llvm_libc_macros_float16_macros",
     ],
 )
 
@@ -2224,7 +2242,6 @@
     hdrs = ["src/__support/math/expf16.h"],
     deps = [
         ":__support_common",
-        ":__support_libc_errno",
         ":__support_cpp_array",
         ":__support_fputil_cast",
         ":__support_fputil_except_value_utils",
@@ -2234,9 +2251,10 @@
         ":__support_fputil_nearest_integer",
         ":__support_fputil_polyeval",
         ":__support_fputil_rounding_mode",
+        ":__support_libc_errno",
         ":__support_macros_optimization",
         ":__support_math_expf16_utils",
-        ":llvm_libc_macros_float16_macros"
+        ":llvm_libc_macros_float16_macros",
     ],
 )
 
@@ -2244,8 +2262,8 @@
     name = "__support_math_frexpf128",
     hdrs = ["src/__support/math/frexpf128.h"],
     deps = [
-        ":__support_macros_properties_types",
         ":__support_fputil_manipulation_functions",
+        ":__support_macros_properties_types",
     ],
 )
 
@@ -2253,9 +2271,9 @@
     name = "__support_math_inv_trigf_utils",
     hdrs = ["src/__support/math/inv_trigf_utils.h"],
     deps = [
+        ":__support_common",
         ":__support_fputil_multiply_add",
         ":__support_fputil_polyeval",
-        ":__support_common",
     ],
 )
 
@@ -2263,10 +2281,10 @@
     name = "__support_math_frexpf16",
     hdrs = ["src/__support/math/frexpf16.h"],
     deps = [
+        ":__support_fputil_manipulation_functions",
         ":__support_macros_config",
         ":__support_macros_properties_types",
-        ":__support_fputil_manipulation_functions",
-        ":llvm_libc_macros_float16_macros"
+        ":llvm_libc_macros_float16_macros",
     ],
 )
 
@@ -2284,7 +2302,7 @@
     deps = [
         ":__support_fputil_manipulation_functions",
         ":__support_macros_properties_types",
-        ":llvm_libc_types_float128"
+        ":llvm_libc_types_float128",
     ],
 )
 
@@ -2292,9 +2310,9 @@
     name = "__support_math_ldexpf16",
     hdrs = ["src/__support/math/ldexpf16.h"],
     deps = [
-        ":__support_macros_properties_types",
         ":__support_fputil_manipulation_functions",
-        ":llvm_libc_macros_float16_macros"
+        ":__support_macros_properties_types",
+        ":llvm_libc_macros_float16_macros",
     ],
 )
 
@@ -2318,8 +2336,8 @@
     name = "__support_math_exp_utils",
     hdrs = ["src/__support/math/exp_utils.h"],
     deps = [
-        ":__support_cpp_optional",
         ":__support_cpp_bit",
+        ":__support_cpp_optional",
         ":__support_fputil_fp_bits",
     ],
 )
@@ -2328,10 +2346,9 @@
     name = "__support_math_exp",
     hdrs = ["src/__support/math/exp.h"],
     deps = [
-        ":__support_math_exp_constants",
-        ":__support_math_exp_utils",
         ":__support_cpp_bit",
         ":__support_cpp_optional",
+        ":__support_fputil_double_double",
         ":__support_fputil_dyadic_float",
         ":__support_fputil_fenv_impl",
         ":__support_fputil_fp_bits",
@@ -2340,9 +2357,10 @@
         ":__support_fputil_polyeval",
         ":__support_fputil_rounding_mode",
         ":__support_fputil_triple_double",
-        ":__support_fputil_double_double",
         ":__support_integer_literals",
         ":__support_macros_optimization",
+        ":__support_math_exp_constants",
+        ":__support_math_exp_utils",
     ],
 )
 
@@ -2350,8 +2368,6 @@
     name = "__support_math_exp10",
     hdrs = ["src/__support/math/exp10.h"],
     deps = [
-        ":__support_math_exp_constants",
-        ":__support_math_exp_utils",
         ":__support_fputil_double_double",
         ":__support_fputil_dyadic_float",
         ":__support_fputil_multiply_add",
@@ -2361,6 +2377,8 @@
         ":__support_fputil_triple_double",
         ":__support_integer_literals",
         ":__support_macros_optimization",
+        ":__support_math_exp_constants",
+        ":__support_math_exp_utils",
     ],
 )
 
@@ -2368,12 +2386,12 @@
     name = "__support_math_exp10f_utils",
     hdrs = ["src/__support/math/exp10f_utils.h"],
     deps = [
+        ":__support_common",
         ":__support_fputil_basic_operations",
         ":__support_fputil_fenv_impl",
         ":__support_fputil_multiply_add",
         ":__support_fputil_nearest_integer",
         ":__support_fputil_polyeval",
-        ":__support_common",
         ":__support_math_exp_utils",
     ],
 )
@@ -2382,12 +2400,12 @@
     name = "__support_math_exp10f",
     hdrs = ["src/__support/math/exp10f.h"],
     deps = [
-        ":__support_math_exp10f_utils",
         ":__support_fputil_fenv_impl",
         ":__support_fputil_fp_bits",
         ":__support_fputil_multiply_add",
         ":__support_fputil_rounding_mode",
         ":__support_macros_optimization",
+        ":__support_math_exp10f_utils",
     ],
 )
 
@@ -2403,9 +2421,9 @@
     name = "__support_math_exp10f16_utils",
     hdrs = ["src/__support/math/exp10f16_utils.h"],
     deps = [
+        ":__support_fputil_fp_bits",
         ":__support_math_exp10_float16_constants",
         ":__support_math_expf16_utils",
-        ":__support_fputil_fp_bits",
     ],
 )
 
@@ -2413,13 +2431,13 @@
     name = "__support_math_exp10f16",
     hdrs = ["src/__support/math/exp10f16.h"],
     deps = [
-        ":__support_math_exp10f16_utils",
-        ":__support_fputil_fp_bits",
         ":__support_fputil_cast",
-        ":__support_fputil_rounding_mode",
         ":__support_fputil_except_value_utils",
+        ":__support_fputil_fp_bits",
+        ":__support_fputil_rounding_mode",
         ":__support_macros_optimization",
         ":__support_macros_properties_cpu_features",
+        ":__support_math_exp10f16_utils",
     ],
 )
 
@@ -2991,7 +3009,7 @@
 libc_math_function(
     name = "erff",
     additional_deps = [
-        ":__support_math_erff"
+        ":__support_math_erff",
     ],
 )
 
@@ -3462,13 +3480,13 @@
     name = "frexpf128",
     additional_deps = [
         ":__support_math_frexpf128",
-    ]
+    ],
 )
 
 libc_math_function(
     name = "frexpf16",
     additional_deps = [
-        ":__support_math_frexpf16"
+        ":__support_math_frexpf16",
     ],
 )
 
@@ -3563,7 +3581,7 @@
     name = "ldexpf",
     additional_deps = [
         ":__support_math_ldexpf",
-    ]
+    ],
 )
 
 libc_math_function(name = "ldexpl")
diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/libc/test/src/__support/FPUtil/BUILD.bazel b/utils/bazel/llvm-project-overlay/libc/test/src/__support/FPUtil/BUILD.bazel
--- a/utils/bazel/llvm-project-overlay/libc/test/src/__support/FPUtil/BUILD.bazel
+++ b/utils/bazel/llvm-project-overlay/libc/test/src/__support/FPUtil/BUILD.bazel
@@ -58,3 +58,15 @@
         "//libc/utils/MPFRWrapper:mpfr_wrapper",
     ],
 )
+
+libc_test(
+    name = "comparison_operations_test",
+    srcs = ["comparison_operations_test.cpp"],
+    deps = [
+        "//libc:__support_fputil_bfloat16",
+        "//libc:__support_fputil_comparison_operations",
+        "//libc:__support_fputil_rounding_mode",
+        "//libc:__support_macros_properties_types",
+        "//libc/test/UnitTest:fp_test_helpers",
+    ],
+)
diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/libc/utils/MPFRWrapper/BUILD.bazel b/utils/bazel/llvm-project-overlay/libc/utils/MPFRWrapper/BUILD.bazel
--- a/utils/bazel/llvm-project-overlay/libc/utils/MPFRWrapper/BUILD.bazel
+++ b/utils/bazel/llvm-project-overlay/libc/utils/MPFRWrapper/BUILD.bazel
@@ -44,6 +44,7 @@
         "//libc:__support_cpp_type_traits",
         "//libc:__support_fputil_bfloat16",
         "//libc:__support_fputil_cast",
+        "//libc:__support_fputil_comparison_operations",
         "//libc:__support_fputil_fp_bits",
         "//libc:__support_macros_config",
         "//libc:__support_macros_properties_types",
