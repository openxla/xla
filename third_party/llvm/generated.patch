Auto generated patch. Do not edit or delete it, even if empty.
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaType.cpp b/clang/lib/Sema/SemaType.cpp
--- a/clang/lib/Sema/SemaType.cpp
+++ b/clang/lib/Sema/SemaType.cpp
@@ -9309,59 +9309,11 @@
 
   // If this definition was instantiated from a template, map back to the
   // pattern from which it was instantiated.
-  if (isa<TagDecl>(D) && cast<TagDecl>(D)->isBeingDefined())
+  if (isa<TagDecl>(D) && cast<TagDecl>(D)->isBeingDefined()) {
     // We're in the middle of defining it; this definition should be treated
     // as visible.
     return true;
-
-  auto DefinitionIsAcceptable = [&](NamedDecl *D) {
-    // The (primary) definition might be in a visible module.
-    if (isAcceptable(D, Kind))
-      return true;
-
-    // A visible module might have a merged definition instead.
-    if (D->isModulePrivate() ? hasMergedDefinitionInCurrentModule(D)
-                             : hasVisibleMergedDefinition(D)) {
-      if (CodeSynthesisContexts.empty() &&
-          !getLangOpts().ModulesLocalVisibility) {
-        // Cache the fact that this definition is implicitly visible because
-        // there is a visible merged definition.
-        D->setVisibleDespiteOwningModule();
-      }
-      return true;
-    }
-
-    return false;
-  };
-  auto IsDefinition = [](NamedDecl *D) {
-    if (auto *RD = dyn_cast<CXXRecordDecl>(D))
-      return RD->isThisDeclarationADefinition();
-    if (auto *ED = dyn_cast<EnumDecl>(D))
-      return ED->isThisDeclarationADefinition();
-    if (auto *FD = dyn_cast<FunctionDecl>(D))
-      return FD->isThisDeclarationADefinition();
-    if (auto *VD = dyn_cast<VarDecl>(D))
-      return VD->isThisDeclarationADefinition() == VarDecl::Definition;
-    llvm_unreachable("unexpected decl type");
-  };
-  auto FoundAcceptableDefinition = [&](NamedDecl *D) {
-    if (!isa<CXXRecordDecl, FunctionDecl, EnumDecl, VarDecl>(D))
-      return DefinitionIsAcceptable(D);
-
-    for (auto *RD : D->redecls()) {
-      auto *ND = cast<NamedDecl>(RD);
-      if (!IsDefinition(ND))
-        continue;
-      if (DefinitionIsAcceptable(ND)) {
-        *Suggested = ND;
-        return true;
-      }
-    }
-
-    return false;
-  };
-
-  if (auto *RD = dyn_cast<CXXRecordDecl>(D)) {
+  } else if (auto *RD = dyn_cast<CXXRecordDecl>(D)) {
     if (auto *Pattern = RD->getTemplateInstantiationPattern())
       RD = Pattern;
     D = RD->getDefinition();
@@ -9400,14 +9352,34 @@
 
   *Suggested = D;
 
-  if (FoundAcceptableDefinition(D))
+  auto DefinitionIsAcceptable = [&] {
+    // The (primary) definition might be in a visible module.
+    if (isAcceptable(D, Kind))
+      return true;
+
+    // A visible module might have a merged definition instead.
+    if (D->isModulePrivate() ? hasMergedDefinitionInCurrentModule(D)
+                             : hasVisibleMergedDefinition(D)) {
+      if (CodeSynthesisContexts.empty() &&
+          !getLangOpts().ModulesLocalVisibility) {
+        // Cache the fact that this definition is implicitly visible because
+        // there is a visible merged definition.
+        D->setVisibleDespiteOwningModule();
+      }
+      return true;
+    }
+
+    return false;
+  };
+
+  if (DefinitionIsAcceptable())
     return true;
 
   // The external source may have additional definitions of this entity that are
   // visible, so complete the redeclaration chain now and ask again.
   if (auto *Source = Context.getExternalSource()) {
     Source->CompleteRedeclChain(D);
-    return FoundAcceptableDefinition(D);
+    return DefinitionIsAcceptable();
   }
 
   return false;
diff -ruN --strip-trailing-cr a/clang/lib/Serialization/ASTReaderDecl.cpp b/clang/lib/Serialization/ASTReaderDecl.cpp
--- a/clang/lib/Serialization/ASTReaderDecl.cpp
+++ b/clang/lib/Serialization/ASTReaderDecl.cpp
@@ -3642,9 +3642,23 @@
 void ASTDeclReader::attachPreviousDeclImpl(ASTReader &Reader,
                                            Redeclarable<VarDecl> *D,
                                            Decl *Previous, Decl *Canon) {
+  auto *VD = static_cast<VarDecl *>(D);
   auto *PrevVD = cast<VarDecl>(Previous);
   D->RedeclLink.setPrevious(PrevVD);
   D->First = PrevVD->First;
+
+  // We should keep at most one definition on the chain.
+  // FIXME: Cache the definition once we've found it. Building a chain with
+  // N definitions currently takes O(N^2) time here.
+  if (VD->isThisDeclarationADefinition() == VarDecl::Definition) {
+    for (VarDecl *CurD = PrevVD; CurD; CurD = CurD->getPreviousDecl()) {
+      if (CurD->isThisDeclarationADefinition() == VarDecl::Definition) {
+        Reader.mergeDefinitionVisibility(CurD, VD);
+        VD->demoteThisDefinitionToDeclaration();
+        break;
+      }
+    }
+  }
 }
 
 static bool isUndeducedReturnType(QualType T) {
diff -ruN --strip-trailing-cr a/clang/test/Modules/demote-var-def.cpp b/clang/test/Modules/demote-var-def.cpp
--- a/clang/test/Modules/demote-var-def.cpp
+++ b/clang/test/Modules/demote-var-def.cpp
@@ -1,94 +0,0 @@
-// RUN: rm -rf %t
-// RUN: mkdir -p %t
-// RUN: split-file %s %t
-// RUN: cd %t
-//
-// DEFINE: %{common-flags}= -I %t -isystem %t -xc++ -std=c++20 -fmodules
-//
-// RUN: mkdir -p %t/b2
-// RUN: mkdir -p %t/b1
-// RUN: %clang_cc1 %{common-flags} -emit-module -fmodule-name=module_d \
-// RUN:     d.cppmap -o d.pcm
-// RUN: %clang_cc1 %{common-flags} -emit-module -fmodule-name=module_a \
-// RUN:     -fmodule-file=d.pcm  a.cppmap -o a.pcm
-// RUN: %clang_cc1 %{common-flags} -emit-module -fmodule-name=module_b2 \
-// RUN:     -fmodule-file=a.pcm b2/b.cppmap -o b2/b.pcm
-// RUN: %clang_cc1 %{common-flags} -emit-module -fmodule-name=module_b1 \
-// RUN:     -fmodule-file=b2/b.pcm b1/b.cppmap -o b1/b.pcm
-// RUN: %clang_cc1 %{common-flags} -emit-module -fmodule-name=module_f \
-// RUN:     -fmodule-file=b1/b.pcm f.cppmap -o f.pcm
-// RUN: %clang_cc1 %{common-flags} -emit-module -fmodule-name=module_c \
-// RUN:     -fmodule-file=f.pcm c.cppmap -o c.pcm
-// RUN: %clang_cc1 %{common-flags} -emit-module \
-// RUN:     -fmodule-name=module_e e.cppmap -o e.pcm
-//
-// RUN: %clang_cc1 %{common-flags} \
-// RUN:     -fmodule-file=c.pcm -fmodule-file=e.pcm \
-// RUN:     src.cpp -o src.pic.o
-
-//--- invoke.h
-#ifndef _LIBCPP___TYPE_TRAITS_IS_SAME_H
-#define _LIBCPP___TYPE_TRAITS_IS_SAME_H
-namespace std { inline namespace _LIBCPP_ABI_NAMESPACE {
-template <class _Tp, class _Up>
-constexpr bool is_same_v = __is_same(_Tp, _Up);
-} }
-#endif
-
-//--- memory
-#include <invoke.h>
-namespace std { inline namespace _LIBCPP_ABI_NAMESPACE {
-template <class _Tp>
-using __decay_t = __decay(_Tp);
-template <class _Tp>
-using decay_t = __decay_t<_Tp>;
-} }
-
-//--- other.h
-#include <invoke.h>
-
-//--- a.cppmap
-module "module_a" {
-}
-
-//--- b1/b.cppmap
-module "module_b1" {
-}
-
-//--- b2/b.cppmap
-module "module_b2" {
-}
-
-//--- c.cppmap
-module "module_c" {
-}
-
-//--- d.cppmap
-module "module_d" {
-    header "d.h"
-}
-
-//--- d.h
-#include <other.h>
-
-//--- e.cppmap
-module "module_e" {
-    header "e.h"
-}
-
-//--- e.h
-#include <memory>
-
-//--- f.cppmap
-module "module_f" {
-}
-
-//--- src.cpp
-#include <d.h>
-#include <memory>
-template <typename T>
-concept coroutine_result =
-    std::is_same_v<std::decay_t<T>, T>;
-template <coroutine_result R>
-class Co;
-using T = Co<void>;
diff -ruN --strip-trailing-cr a/clang/test/Modules/pr149404-02.cppm b/clang/test/Modules/pr149404-02.cppm
--- a/clang/test/Modules/pr149404-02.cppm
+++ b/clang/test/Modules/pr149404-02.cppm
@@ -1,104 +0,0 @@
-// RUN: rm -rf %t
-// RUN: mkdir -p %t
-// RUN: split-file %s %t
-
-// RUN: %clang_cc1 -std=c++20 -emit-module-interface -o %t/format.pcm %t/format.cppm
-// RUN: %clang_cc1 -std=c++20  -emit-module-interface -o %t/includes_in_gmf.pcm %t/includes_in_gmf.cppm
-// RUN: %clang_cc1 -std=c++20 -fprebuilt-module-path=%t %t/test.cpp -verify -fsyntax-only
-
-// RUN: %clang_cc1 -std=c++20 -emit-reduced-module-interface -o %t/format.pcm %t/format.cppm
-// RUN: %clang_cc1 -std=c++20  -emit-reduced-module-interface -o %t/includes_in_gmf.pcm %t/includes_in_gmf.cppm
-// RUN: %clang_cc1 -std=c++20 -fprebuilt-module-path=%t %t/test.cpp -verify -fsyntax-only
-
-//--- format.h
-#pragma once
-
-namespace test {
-
-template <class _Tp>
-struct type_identity {
-    typedef _Tp type;
-};
-
-template <class _Tp>
-using type_identity_t = typename type_identity<_Tp>::type;
-
-
-template <class _Tp, class _CharT>
-struct formatter
-{
-    formatter() = delete;
-};
-
-template <>
-struct formatter<char, char>
-{};
-
-template <class _CharT, class... _Args>
-struct basic_format_string {
-    static inline const int __handles_{ [] {
-        formatter<char, _CharT> f;
-        (void)f;
-        return 0;
-        }() };
-    
-    consteval basic_format_string(const _CharT*) {
-        (void)__handles_;
-    }
-};
-
-template <class... _Args>
-using wformat_string = basic_format_string<wchar_t, type_identity_t<_Args>...>;
-
-template <class... _Args>
-using format_string = basic_format_string<char, type_identity_t<_Args>...>;
-
-template <class... _Args>
-void format(format_string<_Args...> __fmt, _Args&&... __args) {}
-
-template <class... _Args>
-void format(wformat_string<_Args...> __fmt, _Args&&... __args) {}
-
-}
-
-//--- format.cppm
-module;
-#include "format.h"
-export module format;
-
-export namespace test {
-	using test::format;
-	using test::formatter;
-	using test::format_string;
-}
-
-auto something() -> void
-{
-	auto a = 'a';
-	test::format("{}", a);
-}
-
-//--- includes_in_gmf.cppm
-module;
-#include "format.h"
-export module includes_in_gmf;
-
-namespace test {
-	using test::format;
-	using test::formatter;
-	using test::format_string;
-}
-
-//--- test.cpp
-// expected-no-diagnostics
-import format;
-import includes_in_gmf;
-
-auto what() -> void
-{
-    auto a = 'a';
-    test::format("{}", a);
-
-    constexpr auto fs = "{}"; // test::format_string<char>{ "{}" }; // <- same result even passing exact param type
-    test::format(fs, 'r');
-}
diff -ruN --strip-trailing-cr a/clang/test/Modules/pr172241.cppm b/clang/test/Modules/pr172241.cppm
--- a/clang/test/Modules/pr172241.cppm
+++ b/clang/test/Modules/pr172241.cppm
@@ -1,47 +0,0 @@
-// RUN: rm -rf %t
-// RUN: mkdir -p %t
-// RUN: split-file %s %t
-//
-// RUN: %clang_cc1 -std=c++20 -triple %itanium_abi_triple %t/m.cppm -emit-module-interface -o %t/m.pcm
-// RUN: %clang_cc1 -std=c++20 -triple %itanium_abi_triple %t/use.cpp -fmodule-file=m=%t/m.pcm -emit-llvm -o - | FileCheck %t/use.cpp
-//
-// RUN: %clang_cc1 -std=c++20 -triple %itanium_abi_triple %t/m.cppm -emit-reduced-module-interface -o %t/m.pcm
-// RUN: %clang_cc1 -std=c++20 -triple %itanium_abi_triple %t/use.cpp -fmodule-file=m=%t/m.pcm -emit-llvm -o - | FileCheck %t/use.cpp
-
-//--- header.h
-#pragma once
-
-template <unsigned T>
-class Templ {
-public:
-    void lock() { __set_locked_bit(); }
-
-private:
-    static constexpr auto __set_locked_bit = [](){};
-};
-
-class JT {
-public:
-    ~JT() {
-        Templ<4> state;
-        state.lock();
-    }
-};
-
-//--- m.cppm
-module;
-#include "header.h"
-export module m;
-export struct M {
-    JT jt;
-};
-//--- use.cpp
-#include "header.h"
-import m;
-
-int main() {
-    M m;
-    return 0;
-}
-
-// CHECK: @_ZN5TemplILj4EE16__set_locked_bitE = {{.*}}linkonce_odr
diff -ruN --strip-trailing-cr a/clang/test/Modules/var-inst-def.cppm b/clang/test/Modules/var-inst-def.cppm
--- a/clang/test/Modules/var-inst-def.cppm
+++ b/clang/test/Modules/var-inst-def.cppm
@@ -1,110 +0,0 @@
-// RUN: rm -rf %t
-// RUN: mkdir -p %t
-// RUN: split-file %s %t
-// RUN: cd %t
-//
-// RUN: %clang_cc1 -fmodule-name=A -xc++ -emit-module -fmodules \
-// RUN:   -fno-cxx-modules -fno-implicit-modules \
-// RUN:   -fmodule-map-file-home-is-cwd -std=c++20 -I. a.modulemap -o a.pcm
-//
-// RUN: %clang_cc1 -fmodule-name=B -xc++ -emit-module -fmodules \
-// RUN:   -fno-cxx-modules -fno-implicit-modules \
-// RUN:   -fmodule-map-file-home-is-cwd -std=c++20 -I. b.modulemap -o b.pcm
-//
-// RUN: %clang_cc1 -fmodule-name=C -xc++ -emit-module -fmodules \
-// RUN:   -fno-cxx-modules -fno-implicit-modules \
-// RUN:   -fmodule-map-file-home-is-cwd -std=c++20 -I. c.modulemap -o c.pcm
-//
-// RUN: %clang_cc1 -fno-cxx-modules -fmodules -fno-implicit-modules \
-// RUN:   -fmodule-map-file-home-is-cwd \
-// RUN:   -fmodule-file=a.pcm -fmodule-file=b.pcm -fmodule-file=c.pcm \
-// RUN:   -std=c++20 -I. main.cpp -o /dev/null
-
-//--- a.modulemap
-module "A" { header "a.h" }
-//--- b.modulemap
-module "B" { header "b.h" }
-//--- c.modulemap
-module "C" { header "c.h" }
-
-//--- common.h
-#pragma once
-#include "stl.h"
-
-//--- a.h
-#pragma once
-#include "common.h"
-#include "repro.h"
-
-//--- b.h
-#pragma once
-#include "common.h"
-#include "repro.h"
-
-//--- c.h
-#pragma once
-#include "common.h"
-#include "repro.h"
-
-//--- repro.h
-#pragma once
-#include "stl.h"
-
-namespace k {
-template <template <typename> class , typename >
-struct is_instantiation : std::integral_constant<bool, false> {};
-template <template <typename> class C, typename T>
-constexpr bool is_instantiation_v = is_instantiation<C, T>::value;
-}  
-
-struct ThreadState;
-
-namespace cc::subtle {
-template <typename T>
-class U;
-}  
-namespace cc {
-template <typename T> class Co;
-namespace internal {
-template <typename T>
-class Promise {
-  static_assert(!k::is_instantiation_v<subtle::U, T>);
-};
-}  
-}
-
-//--- stl.h
-#pragma once
-namespace std {
-inline namespace abi {
-template <class _Tp, _Tp __v>
-struct integral_constant {
-  static const _Tp value = __v;
-};
-template <class _Tp, class _Up>
-constexpr bool is_same_v = __is_same(_Tp, _Up);
-template <class _Tp>
-using decay_t = __decay(_Tp);
-
-template <class>
-struct __invoke_result_impl ;
-template <class... _Args>
-using invoke_result_t = __invoke_result_impl<_Args...>;
-}
-}
-
-//--- main.cpp
-#include "stl.h"
-#include "a.h"
-
-namespace cc {
-template <typename F>
-  requires k::is_instantiation_v<Co, std::invoke_result_t<F>>
-using result_type =
-    std::invoke_result_t<F>;
-}  
-namespace cc::internal {
-class final {
- Promise<ThreadState> outgoing_work_;
-};
-}
diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
@@ -9223,7 +9223,23 @@
         if (auto *VPI = dyn_cast<VPInstruction>(PhiR->getStartValue())) {
           assert(VPI->getOpcode() == VPInstruction::ReductionStartVector &&
                  "unexpected start value");
-          VPI->setOperand(0, StartVal);
+          // Partial sub-reductions always start at 0 and account for the
+          // reduction start value in a final subtraction. Update it to use the
+          // resume value from the main vector loop.
+          if (PhiR->getVFScaleFactor() > 1 &&
+              PhiR->getRecurrenceKind() == RecurKind::Sub) {
+            auto *Sub = cast<VPInstruction>(RdxResult->getSingleUser());
+            assert(Sub->getOpcode() == Instruction::Sub && "Unexpected opcode");
+            assert(isa<VPIRValue>(Sub->getOperand(0)) &&
+                   "Expected operand to match the original start value of the "
+                   "reduction");
+            assert(VPlanPatternMatch::match(VPI->getOperand(0),
+                                            VPlanPatternMatch::m_ZeroInt()) &&
+                   "Expected start value for partial sub-reduction to start at "
+                   "zero");
+            Sub->setOperand(0, StartVal);
+          } else
+            VPI->setOperand(0, StartVal);
           continue;
         }
       }
diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LoopVectorize/AArch64/partial-reduce-sub-epilogue-vec.ll b/llvm/test/Transforms/LoopVectorize/AArch64/partial-reduce-sub-epilogue-vec.ll
--- a/llvm/test/Transforms/LoopVectorize/AArch64/partial-reduce-sub-epilogue-vec.ll
+++ b/llvm/test/Transforms/LoopVectorize/AArch64/partial-reduce-sub-epilogue-vec.ll
@@ -0,0 +1,188 @@
+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --check-globals none --version 6
+; RUN: opt -passes=loop-vectorize -force-vector-interleave=1 -enable-epilogue-vectorization=true -epilogue-vectorization-force-VF=4 -vectorizer-maximize-bandwidth -S < %s | FileCheck %s --check-prefix=CHECK-EPI
+; RUN: opt -passes=loop-vectorize -force-vector-interleave=1 -enable-epilogue-vectorization=true -epilogue-vectorization-force-VF=8 -vectorizer-maximize-bandwidth -S < %s | FileCheck %s --check-prefix=CHECK-PARTIAL-RED-EPI
+
+target triple = "aarch64"
+
+define i32 @sub_reduction(i32 %startval, ptr %src1, ptr %src2) #0 {
+; CHECK-EPI-LABEL: define i32 @sub_reduction(
+; CHECK-EPI-SAME: i32 [[STARTVAL:%.*]], ptr [[SRC1:%.*]], ptr [[SRC2:%.*]]) #[[ATTR0:[0-9]+]] {
+; CHECK-EPI-NEXT:  [[ITER_CHECK:.*]]:
+; CHECK-EPI-NEXT:    br i1 false, label %[[VEC_EPILOG_SCALAR_PH:.*]], label %[[VECTOR_MAIN_LOOP_ITER_CHECK:.*]]
+; CHECK-EPI:       [[VECTOR_MAIN_LOOP_ITER_CHECK]]:
+; CHECK-EPI-NEXT:    [[TMP0:%.*]] = call i32 @llvm.vscale.i32()
+; CHECK-EPI-NEXT:    [[TMP1:%.*]] = shl nuw i32 [[TMP0]], 4
+; CHECK-EPI-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i32 39, [[TMP1]]
+; CHECK-EPI-NEXT:    br i1 [[MIN_ITERS_CHECK]], label %[[VEC_EPILOG_PH:.*]], label %[[VECTOR_PH:.*]]
+; CHECK-EPI:       [[VECTOR_PH]]:
+; CHECK-EPI-NEXT:    [[TMP2:%.*]] = call i32 @llvm.vscale.i32()
+; CHECK-EPI-NEXT:    [[TMP3:%.*]] = shl nuw i32 [[TMP2]], 4
+; CHECK-EPI-NEXT:    [[N_MOD_VF:%.*]] = urem i32 39, [[TMP3]]
+; CHECK-EPI-NEXT:    [[N_VEC:%.*]] = sub i32 39, [[N_MOD_VF]]
+; CHECK-EPI-NEXT:    br label %[[VECTOR_BODY:.*]]
+; CHECK-EPI:       [[VECTOR_BODY]]:
+; CHECK-EPI-NEXT:    [[INDEX:%.*]] = phi i32 [ 0, %[[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], %[[VECTOR_BODY]] ]
+; CHECK-EPI-NEXT:    [[VEC_PHI:%.*]] = phi <vscale x 4 x i32> [ zeroinitializer, %[[VECTOR_PH]] ], [ [[PARTIAL_REDUCE:%.*]], %[[VECTOR_BODY]] ]
+; CHECK-EPI-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[SRC1]], i32 [[INDEX]]
+; CHECK-EPI-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 16 x i8>, ptr [[TMP4]], align 4
+; CHECK-EPI-NEXT:    [[WIDE_LOAD1:%.*]] = load <vscale x 16 x i8>, ptr [[TMP4]], align 4
+; CHECK-EPI-NEXT:    [[TMP5:%.*]] = sext <vscale x 16 x i8> [[WIDE_LOAD]] to <vscale x 16 x i32>
+; CHECK-EPI-NEXT:    [[TMP6:%.*]] = sext <vscale x 16 x i8> [[WIDE_LOAD1]] to <vscale x 16 x i32>
+; CHECK-EPI-NEXT:    [[TMP7:%.*]] = mul <vscale x 16 x i32> [[TMP5]], [[TMP6]]
+; CHECK-EPI-NEXT:    [[PARTIAL_REDUCE]] = call <vscale x 4 x i32> @llvm.vector.partial.reduce.add.nxv4i32.nxv16i32(<vscale x 4 x i32> [[VEC_PHI]], <vscale x 16 x i32> [[TMP7]])
+; CHECK-EPI-NEXT:    [[INDEX_NEXT]] = add nuw i32 [[INDEX]], [[TMP3]]
+; CHECK-EPI-NEXT:    [[TMP8:%.*]] = icmp eq i32 [[INDEX_NEXT]], [[N_VEC]]
+; CHECK-EPI-NEXT:    br i1 [[TMP8]], label %[[MIDDLE_BLOCK:.*]], label %[[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
+; CHECK-EPI:       [[MIDDLE_BLOCK]]:
+; CHECK-EPI-NEXT:    [[TMP9:%.*]] = call i32 @llvm.vector.reduce.add.nxv4i32(<vscale x 4 x i32> [[PARTIAL_REDUCE]])
+; CHECK-EPI-NEXT:    [[TMP10:%.*]] = sub i32 [[STARTVAL]], [[TMP9]]
+; CHECK-EPI-NEXT:    [[CMP_N:%.*]] = icmp eq i32 39, [[N_VEC]]
+; CHECK-EPI-NEXT:    br i1 [[CMP_N]], label %[[EXIT:.*]], label %[[VEC_EPILOG_ITER_CHECK:.*]]
+; CHECK-EPI:       [[VEC_EPILOG_ITER_CHECK]]:
+; CHECK-EPI-NEXT:    [[MIN_EPILOG_ITERS_CHECK:%.*]] = icmp ult i32 [[N_MOD_VF]], 4
+; CHECK-EPI-NEXT:    br i1 [[MIN_EPILOG_ITERS_CHECK]], label %[[VEC_EPILOG_SCALAR_PH]], label %[[VEC_EPILOG_PH]], !prof [[PROF3:![0-9]+]]
+; CHECK-EPI:       [[VEC_EPILOG_PH]]:
+; CHECK-EPI-NEXT:    [[VEC_EPILOG_RESUME_VAL:%.*]] = phi i32 [ [[N_VEC]], %[[VEC_EPILOG_ITER_CHECK]] ], [ 0, %[[VECTOR_MAIN_LOOP_ITER_CHECK]] ]
+; CHECK-EPI-NEXT:    [[BC_MERGE_RDX:%.*]] = phi i32 [ [[TMP10]], %[[VEC_EPILOG_ITER_CHECK]] ], [ [[STARTVAL]], %[[VECTOR_MAIN_LOOP_ITER_CHECK]] ]
+; CHECK-EPI-NEXT:    [[TMP11:%.*]] = insertelement <4 x i32> zeroinitializer, i32 [[BC_MERGE_RDX]], i32 0
+; CHECK-EPI-NEXT:    br label %[[VEC_EPILOG_VECTOR_BODY:.*]]
+; CHECK-EPI:       [[VEC_EPILOG_VECTOR_BODY]]:
+; CHECK-EPI-NEXT:    [[INDEX2:%.*]] = phi i32 [ [[VEC_EPILOG_RESUME_VAL]], %[[VEC_EPILOG_PH]] ], [ [[INDEX_NEXT6:%.*]], %[[VEC_EPILOG_VECTOR_BODY]] ]
+; CHECK-EPI-NEXT:    [[VEC_PHI3:%.*]] = phi <4 x i32> [ [[TMP11]], %[[VEC_EPILOG_PH]] ], [ [[TMP16:%.*]], %[[VEC_EPILOG_VECTOR_BODY]] ]
+; CHECK-EPI-NEXT:    [[TMP12:%.*]] = getelementptr i8, ptr [[SRC1]], i32 [[INDEX2]]
+; CHECK-EPI-NEXT:    [[WIDE_LOAD4:%.*]] = load <4 x i8>, ptr [[TMP12]], align 4
+; CHECK-EPI-NEXT:    [[TMP13:%.*]] = sext <4 x i8> [[WIDE_LOAD4]] to <4 x i32>
+; CHECK-EPI-NEXT:    [[WIDE_LOAD5:%.*]] = load <4 x i8>, ptr [[TMP12]], align 4
+; CHECK-EPI-NEXT:    [[TMP14:%.*]] = sext <4 x i8> [[WIDE_LOAD5]] to <4 x i32>
+; CHECK-EPI-NEXT:    [[TMP15:%.*]] = mul <4 x i32> [[TMP13]], [[TMP14]]
+; CHECK-EPI-NEXT:    [[TMP16]] = sub <4 x i32> [[VEC_PHI3]], [[TMP15]]
+; CHECK-EPI-NEXT:    [[INDEX_NEXT6]] = add nuw i32 [[INDEX2]], 4
+; CHECK-EPI-NEXT:    [[TMP17:%.*]] = icmp eq i32 [[INDEX_NEXT6]], 36
+; CHECK-EPI-NEXT:    br i1 [[TMP17]], label %[[VEC_EPILOG_MIDDLE_BLOCK:.*]], label %[[VEC_EPILOG_VECTOR_BODY]], !llvm.loop [[LOOP4:![0-9]+]]
+; CHECK-EPI:       [[VEC_EPILOG_MIDDLE_BLOCK]]:
+; CHECK-EPI-NEXT:    [[TMP18:%.*]] = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> [[TMP16]])
+; CHECK-EPI-NEXT:    br i1 false, label %[[EXIT]], label %[[VEC_EPILOG_SCALAR_PH]]
+; CHECK-EPI:       [[VEC_EPILOG_SCALAR_PH]]:
+; CHECK-EPI-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i32 [ 36, %[[VEC_EPILOG_MIDDLE_BLOCK]] ], [ [[N_VEC]], %[[VEC_EPILOG_ITER_CHECK]] ], [ 0, %[[ITER_CHECK]] ]
+; CHECK-EPI-NEXT:    [[BC_MERGE_RDX7:%.*]] = phi i32 [ [[TMP18]], %[[VEC_EPILOG_MIDDLE_BLOCK]] ], [ [[TMP10]], %[[VEC_EPILOG_ITER_CHECK]] ], [ [[STARTVAL]], %[[ITER_CHECK]] ]
+; CHECK-EPI-NEXT:    br label %[[LOOP:.*]]
+; CHECK-EPI:       [[LOOP]]:
+; CHECK-EPI-NEXT:    [[IV:%.*]] = phi i32 [ [[BC_RESUME_VAL]], %[[VEC_EPILOG_SCALAR_PH]] ], [ [[IV_NEXT:%.*]], %[[LOOP]] ]
+; CHECK-EPI-NEXT:    [[ACCUM:%.*]] = phi i32 [ [[BC_MERGE_RDX7]], %[[VEC_EPILOG_SCALAR_PH]] ], [ [[SUB:%.*]], %[[LOOP]] ]
+; CHECK-EPI-NEXT:    [[SRC1_GEP:%.*]] = getelementptr i8, ptr [[SRC1]], i32 [[IV]]
+; CHECK-EPI-NEXT:    [[SRC1_LOAD:%.*]] = load i8, ptr [[SRC1_GEP]], align 4
+; CHECK-EPI-NEXT:    [[SRC1_LOAD_EXT:%.*]] = sext i8 [[SRC1_LOAD]] to i32
+; CHECK-EPI-NEXT:    [[SRC2_GEP:%.*]] = getelementptr i8, ptr [[SRC1]], i32 [[IV]]
+; CHECK-EPI-NEXT:    [[SRC2_LOAD:%.*]] = load i8, ptr [[SRC2_GEP]], align 4
+; CHECK-EPI-NEXT:    [[SRC2_LOAD_EXT:%.*]] = sext i8 [[SRC2_LOAD]] to i32
+; CHECK-EPI-NEXT:    [[MUL:%.*]] = mul i32 [[SRC1_LOAD_EXT]], [[SRC2_LOAD_EXT]]
+; CHECK-EPI-NEXT:    [[SUB]] = sub i32 [[ACCUM]], [[MUL]]
+; CHECK-EPI-NEXT:    [[IV_NEXT]] = add i32 [[IV]], 1
+; CHECK-EPI-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i32 [[IV]], 38
+; CHECK-EPI-NEXT:    br i1 [[EXITCOND_NOT]], label %[[EXIT]], label %[[LOOP]], !llvm.loop [[LOOP5:![0-9]+]]
+; CHECK-EPI:       [[EXIT]]:
+; CHECK-EPI-NEXT:    [[SUB_LCSSA:%.*]] = phi i32 [ [[SUB]], %[[LOOP]] ], [ [[TMP10]], %[[MIDDLE_BLOCK]] ], [ [[TMP18]], %[[VEC_EPILOG_MIDDLE_BLOCK]] ]
+; CHECK-EPI-NEXT:    ret i32 [[SUB_LCSSA]]
+;
+; CHECK-PARTIAL-RED-EPI-LABEL: define i32 @sub_reduction(
+; CHECK-PARTIAL-RED-EPI-SAME: i32 [[STARTVAL:%.*]], ptr [[SRC1:%.*]], ptr [[SRC2:%.*]]) #[[ATTR0:[0-9]+]] {
+; CHECK-PARTIAL-RED-EPI-NEXT:  [[ITER_CHECK:.*]]:
+; CHECK-PARTIAL-RED-EPI-NEXT:    br i1 false, label %[[VEC_EPILOG_SCALAR_PH:.*]], label %[[VECTOR_MAIN_LOOP_ITER_CHECK:.*]]
+; CHECK-PARTIAL-RED-EPI:       [[VECTOR_MAIN_LOOP_ITER_CHECK]]:
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[TMP0:%.*]] = call i32 @llvm.vscale.i32()
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[TMP1:%.*]] = shl nuw i32 [[TMP0]], 4
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i32 39, [[TMP1]]
+; CHECK-PARTIAL-RED-EPI-NEXT:    br i1 [[MIN_ITERS_CHECK]], label %[[VEC_EPILOG_PH:.*]], label %[[VECTOR_PH:.*]]
+; CHECK-PARTIAL-RED-EPI:       [[VECTOR_PH]]:
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[TMP2:%.*]] = call i32 @llvm.vscale.i32()
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[TMP3:%.*]] = shl nuw i32 [[TMP2]], 4
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[N_MOD_VF:%.*]] = urem i32 39, [[TMP3]]
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[N_VEC:%.*]] = sub i32 39, [[N_MOD_VF]]
+; CHECK-PARTIAL-RED-EPI-NEXT:    br label %[[VECTOR_BODY:.*]]
+; CHECK-PARTIAL-RED-EPI:       [[VECTOR_BODY]]:
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[INDEX:%.*]] = phi i32 [ 0, %[[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], %[[VECTOR_BODY]] ]
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[VEC_PHI:%.*]] = phi <vscale x 4 x i32> [ zeroinitializer, %[[VECTOR_PH]] ], [ [[PARTIAL_REDUCE:%.*]], %[[VECTOR_BODY]] ]
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[SRC1]], i32 [[INDEX]]
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 16 x i8>, ptr [[TMP4]], align 4
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[WIDE_LOAD1:%.*]] = load <vscale x 16 x i8>, ptr [[TMP4]], align 4
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[TMP5:%.*]] = sext <vscale x 16 x i8> [[WIDE_LOAD]] to <vscale x 16 x i32>
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[TMP6:%.*]] = sext <vscale x 16 x i8> [[WIDE_LOAD1]] to <vscale x 16 x i32>
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[TMP7:%.*]] = mul <vscale x 16 x i32> [[TMP5]], [[TMP6]]
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[PARTIAL_REDUCE]] = call <vscale x 4 x i32> @llvm.vector.partial.reduce.add.nxv4i32.nxv16i32(<vscale x 4 x i32> [[VEC_PHI]], <vscale x 16 x i32> [[TMP7]])
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[INDEX_NEXT]] = add nuw i32 [[INDEX]], [[TMP3]]
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[TMP8:%.*]] = icmp eq i32 [[INDEX_NEXT]], [[N_VEC]]
+; CHECK-PARTIAL-RED-EPI-NEXT:    br i1 [[TMP8]], label %[[MIDDLE_BLOCK:.*]], label %[[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
+; CHECK-PARTIAL-RED-EPI:       [[MIDDLE_BLOCK]]:
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[TMP9:%.*]] = call i32 @llvm.vector.reduce.add.nxv4i32(<vscale x 4 x i32> [[PARTIAL_REDUCE]])
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[TMP10:%.*]] = sub i32 [[STARTVAL]], [[TMP9]]
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[CMP_N:%.*]] = icmp eq i32 39, [[N_VEC]]
+; CHECK-PARTIAL-RED-EPI-NEXT:    br i1 [[CMP_N]], label %[[EXIT:.*]], label %[[VEC_EPILOG_ITER_CHECK:.*]]
+; CHECK-PARTIAL-RED-EPI:       [[VEC_EPILOG_ITER_CHECK]]:
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[MIN_EPILOG_ITERS_CHECK:%.*]] = icmp ult i32 [[N_MOD_VF]], 8
+; CHECK-PARTIAL-RED-EPI-NEXT:    br i1 [[MIN_EPILOG_ITERS_CHECK]], label %[[VEC_EPILOG_SCALAR_PH]], label %[[VEC_EPILOG_PH]], !prof [[PROF3:![0-9]+]]
+; CHECK-PARTIAL-RED-EPI:       [[VEC_EPILOG_PH]]:
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[VEC_EPILOG_RESUME_VAL:%.*]] = phi i32 [ [[N_VEC]], %[[VEC_EPILOG_ITER_CHECK]] ], [ 0, %[[VECTOR_MAIN_LOOP_ITER_CHECK]] ]
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[BC_MERGE_RDX:%.*]] = phi i32 [ [[TMP10]], %[[VEC_EPILOG_ITER_CHECK]] ], [ [[STARTVAL]], %[[VECTOR_MAIN_LOOP_ITER_CHECK]] ]
+; CHECK-PARTIAL-RED-EPI-NEXT:    br label %[[VEC_EPILOG_VECTOR_BODY:.*]]
+; CHECK-PARTIAL-RED-EPI:       [[VEC_EPILOG_VECTOR_BODY]]:
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[INDEX2:%.*]] = phi i32 [ [[VEC_EPILOG_RESUME_VAL]], %[[VEC_EPILOG_PH]] ], [ [[INDEX_NEXT7:%.*]], %[[VEC_EPILOG_VECTOR_BODY]] ]
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[VEC_PHI3:%.*]] = phi <2 x i32> [ zeroinitializer, %[[VEC_EPILOG_PH]] ], [ [[PARTIAL_REDUCE6:%.*]], %[[VEC_EPILOG_VECTOR_BODY]] ]
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[TMP12:%.*]] = getelementptr i8, ptr [[SRC1]], i32 [[INDEX2]]
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[WIDE_LOAD4:%.*]] = load <8 x i8>, ptr [[TMP12]], align 4
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[WIDE_LOAD5:%.*]] = load <8 x i8>, ptr [[TMP12]], align 4
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[TMP13:%.*]] = sext <8 x i8> [[WIDE_LOAD4]] to <8 x i32>
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[TMP14:%.*]] = sext <8 x i8> [[WIDE_LOAD5]] to <8 x i32>
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[TMP15:%.*]] = mul <8 x i32> [[TMP13]], [[TMP14]]
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[PARTIAL_REDUCE6]] = call <2 x i32> @llvm.vector.partial.reduce.add.v2i32.v8i32(<2 x i32> [[VEC_PHI3]], <8 x i32> [[TMP15]])
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[INDEX_NEXT7]] = add nuw i32 [[INDEX2]], 8
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[TMP16:%.*]] = icmp eq i32 [[INDEX_NEXT7]], 32
+; CHECK-PARTIAL-RED-EPI-NEXT:    br i1 [[TMP16]], label %[[VEC_EPILOG_MIDDLE_BLOCK:.*]], label %[[VEC_EPILOG_VECTOR_BODY]], !llvm.loop [[LOOP4:![0-9]+]]
+; CHECK-PARTIAL-RED-EPI:       [[VEC_EPILOG_MIDDLE_BLOCK]]:
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[TMP17:%.*]] = call i32 @llvm.vector.reduce.add.v2i32(<2 x i32> [[PARTIAL_REDUCE6]])
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[TMP18:%.*]] = sub i32 [[BC_MERGE_RDX]], [[TMP17]]
+; CHECK-PARTIAL-RED-EPI-NEXT:    br i1 false, label %[[EXIT]], label %[[VEC_EPILOG_SCALAR_PH]]
+; CHECK-PARTIAL-RED-EPI:       [[VEC_EPILOG_SCALAR_PH]]:
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i32 [ 32, %[[VEC_EPILOG_MIDDLE_BLOCK]] ], [ [[N_VEC]], %[[VEC_EPILOG_ITER_CHECK]] ], [ 0, %[[ITER_CHECK]] ]
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[BC_MERGE_RDX8:%.*]] = phi i32 [ [[TMP18]], %[[VEC_EPILOG_MIDDLE_BLOCK]] ], [ [[STARTVAL]], %[[VEC_EPILOG_ITER_CHECK]] ], [ [[STARTVAL]], %[[ITER_CHECK]] ]
+; CHECK-PARTIAL-RED-EPI-NEXT:    br label %[[LOOP:.*]]
+; CHECK-PARTIAL-RED-EPI:       [[LOOP]]:
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[IV:%.*]] = phi i32 [ [[BC_RESUME_VAL]], %[[VEC_EPILOG_SCALAR_PH]] ], [ [[IV_NEXT:%.*]], %[[LOOP]] ]
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[ACCUM:%.*]] = phi i32 [ [[BC_MERGE_RDX8]], %[[VEC_EPILOG_SCALAR_PH]] ], [ [[SUB:%.*]], %[[LOOP]] ]
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[SRC1_GEP:%.*]] = getelementptr i8, ptr [[SRC1]], i32 [[IV]]
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[SRC1_LOAD:%.*]] = load i8, ptr [[SRC1_GEP]], align 4
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[SRC1_LOAD_EXT:%.*]] = sext i8 [[SRC1_LOAD]] to i32
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[SRC2_GEP:%.*]] = getelementptr i8, ptr [[SRC1]], i32 [[IV]]
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[SRC2_LOAD:%.*]] = load i8, ptr [[SRC2_GEP]], align 4
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[SRC2_LOAD_EXT:%.*]] = sext i8 [[SRC2_LOAD]] to i32
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[MUL:%.*]] = mul i32 [[SRC1_LOAD_EXT]], [[SRC2_LOAD_EXT]]
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[SUB]] = sub i32 [[ACCUM]], [[MUL]]
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[IV_NEXT]] = add i32 [[IV]], 1
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i32 [[IV]], 38
+; CHECK-PARTIAL-RED-EPI-NEXT:    br i1 [[EXITCOND_NOT]], label %[[EXIT]], label %[[LOOP]], !llvm.loop [[LOOP5:![0-9]+]]
+; CHECK-PARTIAL-RED-EPI:       [[EXIT]]:
+; CHECK-PARTIAL-RED-EPI-NEXT:    [[SUB_LCSSA:%.*]] = phi i32 [ [[SUB]], %[[LOOP]] ], [ [[TMP10]], %[[MIDDLE_BLOCK]] ], [ [[TMP18]], %[[VEC_EPILOG_MIDDLE_BLOCK]] ]
+; CHECK-PARTIAL-RED-EPI-NEXT:    ret i32 [[SUB_LCSSA]]
+;
+entry:
+  br label %loop
+
+loop:
+  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
+  %accum = phi i32 [ %startval, %entry ], [ %sub, %loop ]
+  %src1.gep = getelementptr i8, ptr %src1, i32 %iv
+  %src1.load = load i8, ptr %src1.gep, align 4
+  %src1.load.ext = sext i8 %src1.load to i32
+  %src2.gep = getelementptr i8, ptr %src1, i32 %iv
+  %src2.load = load i8, ptr %src2.gep, align 4
+  %src2.load.ext = sext i8 %src2.load to i32
+  %mul = mul i32 %src1.load.ext, %src2.load.ext
+  %sub = sub i32 %accum, %mul
+  %iv.next = add i32 %iv, 1
+  %exitcond.not = icmp eq i32 %iv, 38
+  br i1 %exitcond.not, label %exit, label %loop
+
+exit:
+  ret i32 %sub
+}
+
+attributes #0 = { vscale_range(1,16) "target-features"="+sve" }
diff -ruN --strip-trailing-cr a/mlir/include/mlir/Bytecode/BytecodeImplementation.h b/mlir/include/mlir/Bytecode/BytecodeImplementation.h
--- a/mlir/include/mlir/Bytecode/BytecodeImplementation.h
+++ b/mlir/include/mlir/Bytecode/BytecodeImplementation.h
@@ -398,6 +398,10 @@
   /// written as-is, with no additional compression or compaction.
   virtual void writeOwnedBlob(ArrayRef<char> blob) = 0;
 
+  /// Write a blob to the bytecode, which is not owned by the caller. The blob
+  /// is copied into the bytecode, and need not strictly outlive the call.
+  virtual void writeUnownedBlob(ArrayRef<char> blob) = 0;
+
   /// Write a bool to the output stream.
   virtual void writeOwnedBool(bool value) = 0;
 
diff -ruN --strip-trailing-cr a/mlir/include/mlir/IR/BuiltinDialectBytecode.td b/mlir/include/mlir/IR/BuiltinDialectBytecode.td
--- a/mlir/include/mlir/IR/BuiltinDialectBytecode.td
+++ b/mlir/include/mlir/IR/BuiltinDialectBytecode.td
@@ -175,10 +175,11 @@
 def DenseElementsAttr : WithType<"DenseElementsAttr", Attribute>;
 def DenseIntOrFPElementsAttr : DialectAttribute<(attr
   ShapedType:$type,
-  Blob:$rawData
-)> {
-  let cBuilder = "cast<$_resultType>($_resultType::getFromRawBuffer($_args))";
-}
+  WithBuilder<"$_args",
+    WithType<"SmallVector<char>",
+    WithParser<"succeeded(readDenseIntOrFPElementsAttr($_reader, type, $_var))",
+    WithPrinter<"writeDenseIntOrFPElementsAttr($_writer, $_name)">>>>:$rawData
+)>;
 
 def DenseStringElementsAttr : DialectAttribute<(attr
   ShapedType:$type,
diff -ruN --strip-trailing-cr a/mlir/lib/Bytecode/Writer/BytecodeWriter.cpp b/mlir/lib/Bytecode/Writer/BytecodeWriter.cpp
--- a/mlir/lib/Bytecode/Writer/BytecodeWriter.cpp
+++ b/mlir/lib/Bytecode/Writer/BytecodeWriter.cpp
@@ -465,6 +465,14 @@
         "dialect blob");
   }
 
+  void writeUnownedBlob(ArrayRef<char> blob) override {
+    emitter.emitVarInt(blob.size(), "dialect blob");
+    emitter.emitBytes(
+        ArrayRef<uint8_t>(reinterpret_cast<const uint8_t *>(blob.data()),
+                          blob.size()),
+        "dialect blob");
+  }
+
   void writeOwnedBool(bool value) override {
     emitter.emitByte(value, "dialect bool");
   }
diff -ruN --strip-trailing-cr a/mlir/lib/Bytecode/Writer/IRNumbering.cpp b/mlir/lib/Bytecode/Writer/IRNumbering.cpp
--- a/mlir/lib/Bytecode/Writer/IRNumbering.cpp
+++ b/mlir/lib/Bytecode/Writer/IRNumbering.cpp
@@ -50,6 +50,7 @@
   }
   void writeOwnedBlob(ArrayRef<char> blob) override {}
   void writeOwnedBool(bool value) override {}
+  void writeUnownedBlob(ArrayRef<char> blob) override {}
 
   int64_t getBytecodeVersion() const override {
     return state.getDesiredBytecodeVersion();
diff -ruN --strip-trailing-cr a/mlir/lib/IR/BuiltinDialectBytecode.cpp b/mlir/lib/IR/BuiltinDialectBytecode.cpp
--- a/mlir/lib/IR/BuiltinDialectBytecode.cpp
+++ b/mlir/lib/IR/BuiltinDialectBytecode.cpp
@@ -148,6 +148,68 @@
   writer.writeVarInt(range.getEndColumn());
 }
 
+static LogicalResult
+readDenseIntOrFPElementsAttr(DialectBytecodeReader &reader, ShapedType type,
+                             SmallVectorImpl<char> &rawData) {
+  ArrayRef<char> blob;
+  if (failed(reader.readBlob(blob)))
+    return failure();
+
+  // If the type is not i1, just copy the blob.
+  if (!type.getElementType().isInteger(1)) {
+    rawData.append(blob.begin(), blob.end());
+    return success();
+  }
+
+  // Check to see if this is using the packed format.
+  // Note: this could be asserted instead as this should be the case. But we
+  // did have period where the unpacked was being serialized, this enables
+  // consuming those still and the check for which case we are in is pretty
+  // cheap.
+  size_t numElements = type.getNumElements();
+  size_t packedSize = llvm::divideCeil(numElements, 8);
+  if (blob.size() == packedSize && blob.size() != numElements &&
+      blob.size() != 1) {
+    // Unpack the blob.
+    rawData.resize(numElements);
+    for (size_t i = 0; i < numElements; ++i)
+      rawData[i] = (blob[i / 8] & (1 << (i % 8))) ? 0xFF : 0x00;
+    return success();
+  }
+  // Otherwise, fallback to the default behavior.
+  rawData.append(blob.begin(), blob.end());
+  return success();
+}
+
+static void writeDenseIntOrFPElementsAttr(DialectBytecodeWriter &writer,
+                                          DenseIntOrFPElementsAttr attr) {
+  // Check to see if this is an i1 dense attribute.
+  if (attr.getElementType().isInteger(1)) {
+    // Pack the data.
+    SmallVector<char> data;
+    ArrayRef<char> rawData = attr.getRawData();
+
+    // If the attribute is a splat, we can just splat the value directly.
+    if (attr.isSplat()) {
+      data.resize(1);
+      data[0] = rawData[0] ? 0xFF : 0x00;
+      writer.writeUnownedBlob(data);
+      return;
+    }
+
+    size_t numElements = attr.getNumElements();
+    data.resize(llvm::divideCeil(numElements, 8));
+    // Otherwise, pack the data manually.
+    for (size_t i = 0; i < numElements; ++i)
+      if (rawData[i])
+        data[i / 8] |= (1 << (i % 8));
+    writer.writeUnownedBlob(data);
+    return;
+  }
+
+  writer.writeOwnedBlob(attr.getRawData());
+}
+
 #include "mlir/IR/BuiltinDialectBytecode.cpp.inc"
 
 /// This class implements the bytecode interface for the builtin dialect.
diff -ruN --strip-trailing-cr a/mlir/test/Bytecode/bytecode_callback_write_unowned_blob.mlir b/mlir/test/Bytecode/bytecode_callback_write_unowned_blob.mlir
--- a/mlir/test/Bytecode/bytecode_callback_write_unowned_blob.mlir
+++ b/mlir/test/Bytecode/bytecode_callback_write_unowned_blob.mlir
@@ -0,0 +1,9 @@
+// RUN: mlir-opt %s -split-input-file --test-bytecode-roundtrip="test-kind=7" | FileCheck %s
+
+func.func @base_test(%arg0: !test.i32) {
+  return
+}
+
+// CHECK: Writing unowned blob...
+// CHECK: Successfully read the unowned blob.
+// CHECK: func.func @base_test([[ARG0:%.+]]: !test.i32) {
diff -ruN --strip-trailing-cr a/mlir/test/Bytecode/i1_splat_roundtrip.mlir b/mlir/test/Bytecode/i1_splat_roundtrip.mlir
--- a/mlir/test/Bytecode/i1_splat_roundtrip.mlir
+++ b/mlir/test/Bytecode/i1_splat_roundtrip.mlir
@@ -0,0 +1,17 @@
+// RUN: mlir-opt %s -emit-bytecode | mlir-opt | FileCheck %s
+
+func.func @test_i1_splat_true() -> tensor<100xi1> {
+  %0 = arith.constant dense<true> : tensor<100xi1>
+  return %0 : tensor<100xi1>
+}
+
+// CHECK-LABEL: func.func @test_i1_splat_true
+// CHECK: arith.constant dense<true> : tensor<100xi1>
+
+func.func @test_i1_splat_false() -> tensor<100xi1> {
+  %0 = arith.constant dense<false> : tensor<100xi1>
+  return %0 : tensor<100xi1>
+}
+
+// CHECK-LABEL: func.func @test_i1_splat_false
+// CHECK: arith.constant dense<false> : tensor<100xi1>
diff -ruN --strip-trailing-cr a/mlir/test/lib/IR/TestBytecodeRoundtrip.cpp b/mlir/test/lib/IR/TestBytecodeRoundtrip.cpp
--- a/mlir/test/lib/IR/TestBytecodeRoundtrip.cpp
+++ b/mlir/test/lib/IR/TestBytecodeRoundtrip.cpp
@@ -84,6 +84,8 @@
       // test-kind 6 is a plain roundtrip with downgrade/upgrade to/from
       // `targetVersion`.
       return runTest6(getOperation());
+    case (7):
+      return runTest7(getOperation());
     default:
       llvm_unreachable("unhandled test kind for TestBytecodeCallbacks pass");
     }
@@ -412,6 +414,59 @@
     doRoundtripWithConfigs(op, writeConfig, parseConfig);
   }
 
+  // Test7: When writing bytecode, we override the encoding of TestI32Type with
+  // the encoding of builtin IntegerType, but we also write an unowned blob.
+  // We can natively parse this without the use of a callback, relying on the
+  // existing builtin reader mechanism.
+  void runTest7(Operation *op) {
+    auto *builtin = op->getContext()->getLoadedDialect<mlir::BuiltinDialect>();
+    BytecodeDialectInterface *iface =
+        builtin->getRegisteredInterface<BytecodeDialectInterface>();
+    BytecodeWriterConfig writeConfig;
+    writeConfig.attachTypeCallback(
+        [&](Type entryValue, std::optional<StringRef> &dialectGroupName,
+            DialectBytecodeWriter &writer) -> LogicalResult {
+          // Emit TestIntegerType using the builtin dialect encoding.
+          if (llvm::isa<test::TestI32Type>(entryValue)) {
+            auto builtinI32Type =
+                IntegerType::get(op->getContext(), 32,
+                                 IntegerType::SignednessSemantics::Signless);
+            // Specify that this type will need to be written as part of the
+            // builtin group. This will override the default dialect group of
+            // the attribute (test).
+            dialectGroupName = StringLiteral("builtin");
+            if (succeeded(iface->writeType(builtinI32Type, writer))) {
+              char dummyBlob[] = "test_blob";
+              llvm::outs() << "Writing unowned blob...\n";
+              writer.writeUnownedBlob(ArrayRef<char>(dummyBlob, 9));
+              return success();
+            }
+          }
+          return failure();
+        });
+    ParserConfig parseConfig(op->getContext(), /*verifyAfterParse=*/true);
+    parseConfig.getBytecodeReaderConfig().attachTypeCallback(
+        [&](DialectBytecodeReader &reader, StringRef dialectName,
+            Type &entry) -> LogicalResult {
+          if (dialectName != StringLiteral("builtin"))
+            return failure();
+          Type builtinAttr = iface->readType(reader);
+          if (auto integerType =
+                  llvm::dyn_cast_or_null<IntegerType>(builtinAttr)) {
+            if (integerType.getWidth() == 32 && integerType.isSignless()) {
+              ArrayRef<char> blob;
+              if (succeeded(reader.readBlob(blob)) &&
+                  blob == ArrayRef<char>("test_blob", 9)) {
+                llvm::outs() << "Successfully read the unowned blob.\n";
+                entry = test::TestI32Type::get(reader.getContext());
+              }
+            }
+          }
+          return success();
+        });
+    doRoundtripWithConfigs(op, writeConfig, parseConfig);
+  }
+
   test::TestDialect *testDialect;
 };
 } // namespace
