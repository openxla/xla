diff --git a/third_party/llvm/generated.patch b/third_party/llvm/generated.patch
index 09d0f82..d13b0c5 100644
--- a/third_party/llvm/generated.patch
+++ b/third_party/llvm/generated.patch
@@ -34,18 +34,6 @@ diff -ruN --strip-trailing-cr a/clang/include/clang/Analysis/FlowSensitive/Stora
    llvm::iterator_range<FieldToLoc::const_iterator> children() const {
      return {Children.begin(), Children.end()};
    }
-diff -ruN --strip-trailing-cr a/clang/include/clang/AST/DeclCXX.h b/clang/include/clang/AST/DeclCXX.h
---- a/clang/include/clang/AST/DeclCXX.h
-+++ b/clang/include/clang/AST/DeclCXX.h
-@@ -3826,7 +3826,7 @@
- 
- public:
-   EnumDecl *getEnumDecl() const {
--    return cast<clang::EnumType>(EnumType->getType())->getOriginalDecl();
-+    return EnumType->getType()->castAs<clang::EnumType>()->getOriginalDecl();
-   }
- 
-   static UsingEnumDecl *Create(ASTContext &C, DeclContext *DC,
 diff -ruN --strip-trailing-cr a/clang/lib/Analysis/FlowSensitive/Transfer.cpp b/clang/lib/Analysis/FlowSensitive/Transfer.cpp
 --- a/clang/lib/Analysis/FlowSensitive/Transfer.cpp
 +++ b/clang/lib/Analysis/FlowSensitive/Transfer.cpp
@@ -165,326 +153,6 @@ diff -ruN --strip-trailing-cr a/clang/lib/Analysis/FlowSensitive/Transfer.cpp b/
    void VisitConditionalOperator(const ConditionalOperator *S) {
      const Environment *TrueEnv = StmtToEnv.getEnvironment(*S->getTrueExpr());
      const Environment *FalseEnv = StmtToEnv.getEnvironment(*S->getFalseExpr());
-diff -ruN --strip-trailing-cr a/clang/lib/AST/ASTImporter.cpp b/clang/lib/AST/ASTImporter.cpp
---- a/clang/lib/AST/ASTImporter.cpp
-+++ b/clang/lib/AST/ASTImporter.cpp
-@@ -1740,10 +1740,21 @@
- }
- 
- ExpectedType ASTNodeImporter::VisitTagType(const TagType *T) {
--  Expected<TagDecl *> ToDeclOrErr = import(T->getOriginalDecl());
-+  TagDecl *DeclForType = T->getOriginalDecl();
-+  Expected<TagDecl *> ToDeclOrErr = import(DeclForType);
-   if (!ToDeclOrErr)
-     return ToDeclOrErr.takeError();
- 
-+  if (DeclForType->isUsed()) {
-+    // If there is a definition of the 'OriginalDecl', it should be imported to
-+    // have all information for the type in the "To" AST. (In some cases no
-+    // other reference may exist to the definition decl and it would not be
-+    // imported otherwise.)
-+    Expected<TagDecl *> ToDefDeclOrErr = import(DeclForType->getDefinition());
-+    if (!ToDefDeclOrErr)
-+      return ToDefDeclOrErr.takeError();
-+  }
-+
-   if (T->isCanonicalUnqualified())
-     return Importer.getToContext().getCanonicalTagType(*ToDeclOrErr);
- 
-diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaDecl.cpp b/clang/lib/Sema/SemaDecl.cpp
---- a/clang/lib/Sema/SemaDecl.cpp
-+++ b/clang/lib/Sema/SemaDecl.cpp
-@@ -5291,10 +5291,8 @@
-     //   UNION_TYPE;   <- where UNION_TYPE is a typedef union.
-     if ((Tag && Tag->getDeclName()) ||
-         DS.getTypeSpecType() == DeclSpec::TST_typename) {
--      RecordDecl *Record = dyn_cast_or_null<RecordDecl>(Tag);
--      if (!Record)
--        Record = DS.getRepAsType().get()->getAsRecordDecl();
--
-+      RecordDecl *Record = Tag ? dyn_cast<RecordDecl>(Tag)
-+                               : DS.getRepAsType().get()->getAsRecordDecl();
-       if (Record && getLangOpts().MicrosoftExt) {
-         Diag(DS.getBeginLoc(), diag::ext_ms_anonymous_record)
-             << Record->isUnion() << DS.getSourceRange();
-@@ -18052,7 +18050,8 @@
-           }
-         }
-       } else if (auto *RD = dyn_cast<CXXRecordDecl>(PrevDecl);
--                 RD && RD->isInjectedClassName()) {
-+                 TUK == TagUseKind::Reference && RD &&
-+                 RD->isInjectedClassName()) {
-         // If lookup found the injected class name, the previous declaration is
-         // the class being injected into.
-         PrevDecl = cast<TagDecl>(RD->getDeclContext());
-@@ -18544,8 +18543,14 @@
-   if (PrevDecl)
-     CheckRedeclarationInModule(New, PrevDecl);
- 
--  if (TUK == TagUseKind::Definition && (!SkipBody || !SkipBody->ShouldSkip))
--    New->startDefinition();
-+  if (TUK == TagUseKind::Definition) {
-+    if (!SkipBody || !SkipBody->ShouldSkip) {
-+      New->startDefinition();
-+    } else {
-+      New->setCompleteDefinition();
-+      New->demoteThisDefinitionToDeclaration();
-+    }
-+  }
- 
-   ProcessDeclAttributeList(S, New, Attrs);
-   AddPragmaAttributes(S, New);
-diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaType.cpp b/clang/lib/Sema/SemaType.cpp
---- a/clang/lib/Sema/SemaType.cpp
-+++ b/clang/lib/Sema/SemaType.cpp
-@@ -9878,7 +9878,14 @@
-   S.DiagnoseUseOfDecl(ED, Loc);
- 
-   QualType Underlying = ED->getIntegerType();
--  assert(!Underlying.isNull());
-+  if (Underlying.isNull()) {
-+    // This is an enum without a fixed underlying type which we skipped parsing
-+    // the body because we saw its definition previously in another module.
-+    // Use the definition's integer type in that case.
-+    assert(ED->isThisDeclarationADemotedDefinition());
-+    Underlying = ED->getDefinition()->getIntegerType();
-+    assert(!Underlying.isNull());
-+  }
- 
-   return Underlying;
- }
-diff -ruN --strip-trailing-cr a/clang/lib/Serialization/ASTReaderDecl.cpp b/clang/lib/Serialization/ASTReaderDecl.cpp
---- a/clang/lib/Serialization/ASTReaderDecl.cpp
-+++ b/clang/lib/Serialization/ASTReaderDecl.cpp
-@@ -2107,6 +2107,8 @@
-     auto *Def = DD.Definition;
-     DD = std::move(MergeDD);
-     DD.Definition = Def;
-+    while ((Def = Def->getPreviousDecl()))
-+      cast<CXXRecordDecl>(Def)->DefinitionData = &DD;
-     return;
-   }
- 
-diff -ruN --strip-trailing-cr a/clang/test/Analysis/ctu-import-type-decl-definition.c b/clang/test/Analysis/ctu-import-type-decl-definition.c
---- a/clang/test/Analysis/ctu-import-type-decl-definition.c
-+++ b/clang/test/Analysis/ctu-import-type-decl-definition.c
-@@ -0,0 +1,43 @@
-+// RUN: rm -rf %t
-+// RUN: mkdir -p %t
-+// RUN: split-file %s %t
-+
-+// RUN: %clang_cc1 -emit-pch -o %t/import.c.ast %t/import.c
-+
-+// RUN: %clang_extdef_map -- -x c %t/import.c >> %t/externalDefMap.txt
-+// RUN: sed -i 's/$/.ast/' %t/externalDefMap.txt
-+
-+// RUN: %clang_cc1 -analyze \
-+// RUN:   -analyzer-checker=core \
-+// RUN:   -analyzer-config experimental-enable-naive-ctu-analysis=true \
-+// RUN:   -analyzer-config display-ctu-progress=true \
-+// RUN:   -analyzer-config ctu-dir=%t \
-+// RUN:   -verify %t/main.c
-+
-+//--- main.c
-+
-+// expected-no-diagnostics
-+
-+typedef struct X_s X_t;
-+unsigned long f_import(struct X_s *xPtr);
-+
-+static void freeWriteFileResources(struct X_s *xPtr) {
-+  f_import(xPtr);
-+}
-+
-+//--- import.c
-+
-+typedef struct Y_s Y_t;
-+
-+struct Y_s {
-+};
-+
-+struct X_s {
-+  Y_t y;
-+};
-+
-+unsigned long f_import(struct X_s *xPtr) {
-+  if (xPtr != 0) {
-+  }
-+  return 0;
-+}
-diff -ruN --strip-trailing-cr a/clang/test/AST/ast-dump-decl.cpp b/clang/test/AST/ast-dump-decl.cpp
---- a/clang/test/AST/ast-dump-decl.cpp
-+++ b/clang/test/AST/ast-dump-decl.cpp
-@@ -990,3 +990,18 @@
-   // CHECK-NEXT:    `-RecordType [[TestInjectedClassName_RT]] 'A' injected
-   // CHECK-NEXT:      `-CXXRecord [[TestInjectedClassName_RD]] 'A'
- } // namespace InjectedClassName
-+
-+namespace TestGH155936 {
-+  struct Foo {
-+    struct A {
-+      struct Foo {};
-+    };
-+  };
-+  // CHECK-LABEL: Dumping TestGH155936:
-+  // CHECK: CXXRecordDecl 0x{{.+}} <{{.+}}> line:[[@LINE-6]]:10 struct Foo definition
-+  // CHECK: CXXRecordDecl 0x{{.+}} <col:3, col:10> col:10 implicit struct Foo
-+  // CHECK: CXXRecordDecl 0x{{.+}} <{{.+}}> line:[[@LINE-7]]:12 struct A definition
-+  // CHECK: CXXRecordDecl 0x{{.+}} <col:5, col:12> col:12 implicit struct A
-+  // CHECK: CXXRecordDecl 0x{{.+}} <line:[[@LINE-8]]:7, col:19> col:14 struct Foo definition
-+  // CHECH: CXXRecordDecl 0x{{.+}} <col:9, col:16> col:16 implicit struct Foo
-+} // namspace GH155936
-diff -ruN --strip-trailing-cr a/clang/test/Modules/GH154840.cpp b/clang/test/Modules/GH154840.cpp
---- a/clang/test/Modules/GH154840.cpp
-+++ b/clang/test/Modules/GH154840.cpp
-@@ -0,0 +1,97 @@
-+// RUN: rm -rf %t
-+// RUN: mkdir -p %t
-+// RUN: split-file %s %t
-+// RUN: cd %t
-+//
-+// RUN: %clang_cc1 -fmodule-name=A -fno-cxx-modules -emit-module -fmodules -xc++ A.cppmap -o A.pcm
-+// RUN: %clang_cc1 -fmodule-name=B -fno-cxx-modules -emit-module -fmodules -xc++ B.cppmap -o B.pcm -fmodule-file=A.pcm
-+// RUN: %clang_cc1 -fmodule-name=C -fno-cxx-modules -emit-module -fmodules -xc++ C.cppmap -o C.pcm -fmodule-file=A.pcm
-+// RUN: %clang_cc1 -fmodule-name=D -fno-cxx-modules -emit-module -fmodules -xc++ D.cppmap -o D.pcm -fmodule-file=A.pcm
-+// RUN: %clang_cc1 -fmodule-name=E -fno-cxx-modules -emit-module -fmodules -xc++ E.cppmap -o E.pcm -fmodule-file=D.pcm -fmodule-file=B.pcm -fmodule-file=C.pcm
-+// RUN: %clang_cc1 -fno-cxx-modules -fmodules -fmodule-file=B.pcm -fmodule-file=E.pcm -emit-llvm -o /dev/null S.cpp
-+
-+//--- A.h
-+namespace std {
-+
-+template <class T> void zz(T);
-+
-+template <class> struct vec {
-+  struct w {};
-+  struct xx {};
-+
-+  vec(vec &) { init(); }
-+  constexpr vec &operator=(const vec &);
-+  template <class U> constexpr void pb(U);
-+  constexpr void init();
-+
-+  w s;
-+};
-+
-+template <class T> constexpr void vec<T>::init() {
-+  xx yy;
-+  zz(yy);
-+}
-+
-+template <class T> constexpr vec<T> &vec<T>::operator=(const vec &) {
-+  pb(s);
-+  return *this;
-+}
-+
-+template <class T> template <class U> constexpr void vec<T>::pb(U) { init(); }
-+} // namespace std
-+
-+//--- A.cppmap
-+module "A" {
-+  header "A.h"
-+}
-+
-+//--- X.h
-+#pragma clang module import A
-+
-+namespace project {
-+  class thing : std::vec<thing> {};
-+} // namespace project
-+
-+//--- B.h
-+#include "X.h"
-+
-+//--- B.cppmap
-+module "B" {
-+  header "B.h"
-+}
-+
-+//--- C.h
-+#include "X.h"
-+
-+//--- C.cppmap
-+module "C" {
-+  header "C.h"
-+}
-+
-+//--- D.h
-+#include "X.h"
-+
-+//--- D.cppmap
-+module "D" {
-+  header "D.h"
-+}
-+
-+//--- Y.h
-+#include "X.h"
-+struct other {
-+  other() : data(data) {}
-+  std::vec<project::thing> data;
-+};
-+
-+//--- E.h
-+#include "Y.h"
-+
-+//--- E.cppmap
-+module "E" {
-+  header "E.h"
-+}
-+
-+//--- S.cpp
-+#pragma clang module import A
-+#pragma clang module import E
-+void func(std::vec<project::thing> *a, std::vec<project::thing> *b) { *a = *b; }
-diff -ruN --strip-trailing-cr a/clang/test/Modules/GH155028-1.cpp b/clang/test/Modules/GH155028-1.cpp
---- a/clang/test/Modules/GH155028-1.cpp
-+++ b/clang/test/Modules/GH155028-1.cpp
-@@ -0,0 +1,17 @@
-+// RUN: %clang_cc1 -std=c++20 -verify %s
-+// expected-no-diagnostics
-+
-+#pragma clang module build M
-+module "M" {
-+  module "A" {}
-+  module "B" {}
-+}
-+#pragma clang module contents
-+#pragma clang module begin M.A
-+enum E1 {};
-+#pragma clang module end
-+#pragma clang module begin M.B
-+enum E1 {};
-+using T = __underlying_type(E1);
-+#pragma clang module end
-+#pragma clang module endbuild
-diff -ruN --strip-trailing-cr a/clang/test/Sema/GH155794.c b/clang/test/Sema/GH155794.c
---- a/clang/test/Sema/GH155794.c
-+++ b/clang/test/Sema/GH155794.c
-@@ -0,0 +1,6 @@
-+// RUN: %clang_cc1 -fsyntax-only -verify -Wno-everything %s
-+
-+struct S {
-+  enum e1 {} // expected-error {{use of empty enum}} expected-error {{expected ';' after enum}}
-+  enum e2 {} // expected-error {{use of empty enum}}
-+}; // expected-error {{expected member name or ';' after declaration specifiers}}
-diff -ruN --strip-trailing-cr a/clang/test/SemaTemplate/using-decl.cpp b/clang/test/SemaTemplate/using-decl.cpp
---- a/clang/test/SemaTemplate/using-decl.cpp
-+++ b/clang/test/SemaTemplate/using-decl.cpp
-@@ -14,3 +14,15 @@
-   }
-   void e() { c<int>(); }
- }
-+
-+namespace UsingUsingEnum {
-+  namespace foo {
-+    enum class EnumOne {};
-+  }
-+  using foo::EnumOne;
-+
-+  template <class> void t() {
-+    using enum EnumOne;
-+  }
-+  template void t<void>();
-+} // namespace UsingUsingEnum
 diff -ruN --strip-trailing-cr a/clang/unittests/Analysis/FlowSensitive/TransferTest.cpp b/clang/unittests/Analysis/FlowSensitive/TransferTest.cpp
 --- a/clang/unittests/Analysis/FlowSensitive/TransferTest.cpp
 +++ b/clang/unittests/Analysis/FlowSensitive/TransferTest.cpp
@@ -814,151 +482,135 @@ diff -ruN --strip-trailing-cr a/clang/unittests/Analysis/FlowSensitive/TransferT
  TEST(TransferTest, IntegralCast) {
    std::string Code = R"(
      void target(int Foo) {
-diff -ruN --strip-trailing-cr a/clang-tools-extra/test/clang-tidy/check_clang_tidy.py b/clang-tools-extra/test/clang-tidy/check_clang_tidy.py
---- a/clang-tools-extra/test/clang-tidy/check_clang_tidy.py
-+++ b/clang-tools-extra/test/clang-tidy/check_clang_tidy.py
-@@ -391,9 +391,7 @@
-     args, extra_args = parser.parse_known_args()
-     if args.std is None:
-         _, extension = os.path.splitext(args.assume_filename or args.input_file_name)
--        args.std = [
--            "c++11-or-later" if extension in [".cpp", ".hpp", ".mm"] else "c99-or-later"
--        ]
-+        args.std = ["c99-or-later" if extension in [".c", ".m"] else "c++11-or-later"]
- 
-     return (args, extra_args)
- 
-diff -ruN --strip-trailing-cr a/lldb/source/Plugins/SymbolFile/NativePDB/SymbolFileNativePDB.cpp b/lldb/source/Plugins/SymbolFile/NativePDB/SymbolFileNativePDB.cpp
---- a/lldb/source/Plugins/SymbolFile/NativePDB/SymbolFileNativePDB.cpp
-+++ b/lldb/source/Plugins/SymbolFile/NativePDB/SymbolFileNativePDB.cpp
-@@ -1735,11 +1735,11 @@
-   }
- 
-   // Sort them before value searching is working properly.
--  m_func_full_names.Sort();
-+  m_func_full_names.Sort(std::less<uint32_t>());
-   m_func_full_names.SizeToFit();
--  m_func_method_names.Sort();
-+  m_func_method_names.Sort(std::less<uint32_t>());
-   m_func_method_names.SizeToFit();
--  m_func_base_names.Sort();
-+  m_func_base_names.Sort(std::less<uint32_t>());
-   m_func_base_names.SizeToFit();
+diff -ruN --strip-trailing-cr a/llvm/include/llvm/Linker/IRMover.h b/llvm/include/llvm/Linker/IRMover.h
+--- a/llvm/include/llvm/Linker/IRMover.h
++++ b/llvm/include/llvm/Linker/IRMover.h
+@@ -10,6 +10,7 @@
+ #define LLVM_LINKER_IRMOVER_H
+ 
+ #include "llvm/ADT/ArrayRef.h"
++#include "llvm/ADT/DenseMap.h"
+ #include "llvm/ADT/DenseSet.h"
+ #include "llvm/ADT/FunctionExtras.h"
+ #include "llvm/Support/Compiler.h"
+@@ -19,6 +20,8 @@
+ class Error;
+ class GlobalValue;
+ class Metadata;
++class MDNode;
++class NamedMDNode;
+ class Module;
+ class StructType;
+ class TrackingMDRef;
+@@ -67,6 +70,8 @@
+   using LazyCallback =
+       llvm::unique_function<void(GlobalValue &GV, ValueAdder Add)>;
+ 
++  using NamedMDNodesT = DenseMap<const NamedMDNode *, DenseSet<const MDNode *>>;
++
+   /// Move in the provide values in \p ValuesToLink from \p Src.
+   ///
+   /// - \p AddLazyFor is a call back that the IRMover will call when a global
+@@ -86,6 +91,7 @@
+   Module &Composite;
+   IdentifiedStructTypeSet IdentifiedStructTypes;
+   MDMapT SharedMDs; ///< A Metadata map to use for all calls to \a move().
++  NamedMDNodesT NamedMDNodes; ///< Cache for IRMover::linkNamedMDNodes().
+ };
+ 
+ } // End llvm namespace
+diff -ruN --strip-trailing-cr a/llvm/lib/Linker/IRMover.cpp b/llvm/lib/Linker/IRMover.cpp
+--- a/llvm/lib/Linker/IRMover.cpp
++++ b/llvm/lib/Linker/IRMover.cpp
+@@ -293,7 +293,7 @@
+   std::unique_ptr<Module> SrcM;
+ 
+   // Lookup table to optimize IRMover::linkNamedMDNodes().
+-  DenseMap<StringRef, DenseSet<MDNode *>> NamedMDNodes;
++  IRMover::NamedMDNodesT &NamedMDNodes;
+ 
+   /// See IRMover::move().
+   IRMover::LazyCallback AddLazyFor;
+@@ -440,10 +440,12 @@
+   IRLinker(Module &DstM, MDMapT &SharedMDs,
+            IRMover::IdentifiedStructTypeSet &Set, std::unique_ptr<Module> SrcM,
+            ArrayRef<GlobalValue *> ValuesToLink,
+-           IRMover::LazyCallback AddLazyFor, bool IsPerformingImport)
+-      : DstM(DstM), SrcM(std::move(SrcM)), AddLazyFor(std::move(AddLazyFor)),
+-        TypeMap(Set), GValMaterializer(*this), LValMaterializer(*this),
+-        SharedMDs(SharedMDs), IsPerformingImport(IsPerformingImport),
++           IRMover::LazyCallback AddLazyFor, bool IsPerformingImport,
++           IRMover::NamedMDNodesT &NamedMDNodes)
++      : DstM(DstM), SrcM(std::move(SrcM)), NamedMDNodes(NamedMDNodes),
++        AddLazyFor(std::move(AddLazyFor)), TypeMap(Set),
++        GValMaterializer(*this), LValMaterializer(*this), SharedMDs(SharedMDs),
++        IsPerformingImport(IsPerformingImport),
+         Mapper(ValueMap, RF_ReuseAndMutateDistinctMDs | RF_IgnoreMissingLocals,
+                &TypeMap, &GValMaterializer),
+         IndirectSymbolMCID(Mapper.registerAlternateMappingContext(
+@@ -1138,7 +1140,7 @@
+ 
+     NamedMDNode *DestNMD = DstM.getOrInsertNamedMetadata(NMD.getName());
+ 
+-    auto &Inserted = NamedMDNodes[DestNMD->getName()];
++    auto &Inserted = NamedMDNodes[DestNMD];
+     if (Inserted.empty()) {
+       // Must be the first module, copy everything from DestNMD.
+       Inserted.insert(DestNMD->operands().begin(), DestNMD->operands().end());
+@@ -1683,6 +1685,6 @@
+                     LazyCallback AddLazyFor, bool IsPerformingImport) {
+   IRLinker TheIRLinker(Composite, SharedMDs, IdentifiedStructTypes,
+                        std::move(Src), ValuesToLink, std::move(AddLazyFor),
+-                       IsPerformingImport);
++                       IsPerformingImport, NamedMDNodes);
+   return TheIRLinker.run();
  }
- 
-@@ -2426,7 +2426,7 @@
- 
-   // After calling Append(), the type-name map needs to be sorted again to be
-   // able to look up a type by its name.
--  m_type_base_names.Sort();
-+  m_type_base_names.Sort(std::less<uint32_t>());
- 
-   // Now that we know the forward -> full mapping of all type indices, we can
-   // re-write all the indices.  At the end of this process, we want a mapping
-diff -ruN --strip-trailing-cr a/lldb/tools/lldb-dap/Handler/ModuleSymbolsRequestHandler.cpp b/lldb/tools/lldb-dap/Handler/ModuleSymbolsRequestHandler.cpp
---- a/lldb/tools/lldb-dap/Handler/ModuleSymbolsRequestHandler.cpp
-+++ b/lldb/tools/lldb-dap/Handler/ModuleSymbolsRequestHandler.cpp
-@@ -60,7 +60,7 @@
-     if (!symbol.IsValid())
-       continue;
- 
--    Symbol dap_symbol;
-+    Symbol dap_symbol = {};
-     dap_symbol.id = symbol.GetID();
-     dap_symbol.type = symbol.GetType();
-     dap_symbol.isDebug = symbol.IsDebug();
-diff -ruN --strip-trailing-cr a/lldb/tools/lldb-dap/src-ts/ui/symbols-provider.ts b/lldb/tools/lldb-dap/src-ts/ui/symbols-provider.ts
---- a/lldb/tools/lldb-dap/src-ts/ui/symbols-provider.ts
-+++ b/lldb/tools/lldb-dap/src-ts/ui/symbols-provider.ts
-@@ -61,18 +61,18 @@
-       return;
-     }
- 
--    this.showSymbolsForModule(session, selectedModule.module);
-+    await this.showSymbolsForModule(session, selectedModule.module);
-   }
- 
-   private async showSymbolsForModule(session: vscode.DebugSession, module: DebugProtocol.Module) {
-     try {
-       const symbols = await this.getSymbolsForModule(session, module.id.toString());
--      this.showSymbolsInNewTab(module.name.toString(), symbols);
-+      await this.showSymbolsInNewTab(module.name.toString(), symbols);
-     } catch (error) {
-       if (error instanceof Error) {
--        vscode.window.showErrorMessage("Failed to retrieve symbols: " + error.message);
-+        await vscode.window.showErrorMessage("Failed to retrieve symbols: " + error.message);
-       } else {
--        vscode.window.showErrorMessage("Failed to retrieve symbols due to an unknown error.");
-+        await vscode.window.showErrorMessage("Failed to retrieve symbols due to an unknown error.");
-       }
-       
-       return;
-@@ -106,7 +106,7 @@
-     const symbolsTableScriptPath = panel.webview.asWebviewUri(vscode.Uri.joinPath(this.getExtensionResourcePath(), "symbols-table-view.js"));
- 
-     panel.webview.html = getSymbolsTableHTMLContent(tabulatorJsPath, tabulatorCssPath, symbolsTableScriptPath);
--    panel.webview.postMessage({ command: "updateSymbols", symbols: symbols });
-+    await panel.webview.postMessage({ command: "updateSymbols", symbols: symbols });
-   }
- 
-   private getExtensionResourcePath(): vscode.Uri {
-diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/clang/BUILD.bazel b/utils/bazel/llvm-project-overlay/clang/BUILD.bazel
---- a/utils/bazel/llvm-project-overlay/clang/BUILD.bazel
-+++ b/utils/bazel/llvm-project-overlay/clang/BUILD.bazel
-@@ -58,6 +58,7 @@
-         "Refactoring",
-         "Sema",
-         "Serialization",
-+        "Trap",
-     ] for out in [
-         (
-             "include/clang/Basic/Diagnostic%sKinds.inc" % c,
-diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel b/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel
---- a/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel
-+++ b/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel
-@@ -4167,6 +4167,7 @@
-         ":VectorToSCF",
-         ":VectorToSPIRV",
-         ":VectorToXeGPU",
-+        ":XeGPUToXeVM",
-         ":XeVMToLLVM",
-     ],
+diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/libc/BUILD.bazel b/utils/bazel/llvm-project-overlay/libc/BUILD.bazel
+--- a/utils/bazel/llvm-project-overlay/libc/BUILD.bazel
++++ b/utils/bazel/llvm-project-overlay/libc/BUILD.bazel
+@@ -3749,6 +3749,14 @@
  )
-@@ -13945,6 +13946,37 @@
+ 
+ libc_math_function(
++    name = "fmodbf16",
++    additional_deps = [
++        ":__support_fputil_bfloat16",
++        ":__support_fputil_generic_fmod",
++    ],
++)
++
++libc_math_function(
+     name = "fmodf",
+     additional_deps = [
+         ":__support_fputil_generic_fmod",
+diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/libc/test/src/math/smoke/BUILD.bazel b/utils/bazel/llvm-project-overlay/libc/test/src/math/smoke/BUILD.bazel
+--- a/utils/bazel/llvm-project-overlay/libc/test/src/math/smoke/BUILD.bazel
++++ b/utils/bazel/llvm-project-overlay/libc/test/src/math/smoke/BUILD.bazel
+@@ -739,6 +739,16 @@
  )
  
- cc_library(
-+    name = "XeGPUToXeVM",
-+    srcs = glob([
-+        "lib/Conversion/XeGPUToXeVM/*.cpp",
-+    ]),
-+    hdrs = glob([
-+        "include/mlir/Conversion/XeGPUToXeVM/*.h",
-+    ]),
-+    includes = ["include"],
+ math_test(
++    name = "fmodbf16",
++    hdrs = [
++        "FModTest.h",
++    ],
 +    deps = [
-+        ":ArithDialect",
-+        ":ConversionPassIncGen",
-+        ":ConvertToLLVMInterface",
-+        ":GPUDialect",
-+        ":IR",
-+        ":IndexDialect",
-+        ":LLVMCommonConversion",
-+        ":LLVMDialect",
-+        ":MemRefDialect",
-+        ":Pass",
-+        ":SCFDialect",
-+        ":SCFTransforms",
-+        ":Support",
-+        ":TransformUtils",
-+        ":VectorDialect",
-+        ":XeGPUDialect",
-+        ":XeVMDialect",
-+        "//llvm:Support",
++        "//libc:__support_fputil_bfloat16",
 +    ],
 +)
 +
-+cc_library(
-     name = "XeVMToLLVM",
-     srcs = glob([
-         "lib/Conversion/XeVMToLLVM/*.cpp",
++math_test(
+     name = "fmodf",
+     hdrs = ["FModTest.h"],
+ )
+diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/llvm/BUILD.bazel b/utils/bazel/llvm-project-overlay/llvm/BUILD.bazel
+--- a/utils/bazel/llvm-project-overlay/llvm/BUILD.bazel
++++ b/utils/bazel/llvm-project-overlay/llvm/BUILD.bazel
+@@ -2223,7 +2223,6 @@
+             "lib/Target/AArch64/AArch64GenDisassemblerTables.inc": [
+                 "-gen-disassembler",
+                 "-ignore-non-decodable-operands",
+-                "-ignore-fully-defined-operands",
+             ],
+             "lib/Target/AArch64/AArch64GenSystemOperands.inc": ["-gen-searchable-tables"],
+             "lib/Target/AArch64/AArch64GenExegesis.inc": ["-gen-exegesis"],
diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl
index 983f65d..f671196 100644
--- a/third_party/llvm/workspace.bzl
+++ b/third_party/llvm/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive")
 
 def repo(name):
     """Imports LLVM."""
-    LLVM_COMMIT = "5bca8f2f97d23c3562544e959702826eb20696af"
-    LLVM_SHA256 = "d0e5d52ce939c396f3fa8533d7a1f911ed059e072d4797e3f9cb15043a6fd113"
+    LLVM_COMMIT = "a1de9aca1150bd749a3cdad1d1e26eb6a8855fe2"
+    LLVM_SHA256 = "4b99bf2c212bcd27ac90315f6d8ce82f2d0aeaea257c9b49ddf29ef7a1bba175"
 
     tf_http_archive(
         name = name,
diff --git a/third_party/stablehlo/temporary.patch b/third_party/stablehlo/temporary.patch
index 1fcd9fd..7ac0b19 100755
--- a/third_party/stablehlo/temporary.patch
+++ b/third_party/stablehlo/temporary.patch
@@ -1,3 +1,168 @@
+diff --ruN a/stablehlo/stablehlo/conversions/tosa/tests/legalize_quant_ops_to_tosa_rescale.mlir b/stablehlo/stablehlo/conversions/tosa/tests/legalize_quant_ops_to_tosa_rescale.mlir
+--- stablehlo/stablehlo/conversions/tosa/tests/legalize_quant_ops_to_tosa_rescale.mlir
++++ stablehlo/stablehlo/conversions/tosa/tests/legalize_quant_ops_to_tosa_rescale.mlir
+@@ -11,10 +11,10 @@
+   // CHECK-DAG: %[[MULTIPLIER_2:.+]] = "tosa.const"() <{values = dense<1431655765> : tensor<1xi32>}>
+   // CHECK-DAG: %[[ZP_MINUS_1:.+]] = "tosa.const"() <{values = dense<-1> : tensor<1xi8>}>
+   // CHECK-DAG: %[[ZP_0:.+]] = "tosa.const"() <{values = dense<0> : tensor<1xi32>}>
+-  // CHECK-DAG: %[[V0:.+]] = tosa.rescale %arg0, %[[MULTIPLIER_2]], %[[SHIFT13]], %[[ZP_MINUS_1]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = "SINGLE_ROUND", scale32 = true}
+-  // CHECK-DAG: %[[V1:.+]] = tosa.rescale %arg1, %[[MULTIPLIER_1]], %[[SHIFT11]], %[[ZP_MINUS_1]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = "SINGLE_ROUND", scale32 = true}
++  // CHECK-DAG: %[[V0:.+]] = tosa.rescale %arg0, %[[MULTIPLIER_2]], %[[SHIFT13]], %[[ZP_MINUS_1]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = SINGLE_ROUND, scale32 = true}
++  // CHECK-DAG: %[[V1:.+]] = tosa.rescale %arg1, %[[MULTIPLIER_1]], %[[SHIFT11]], %[[ZP_MINUS_1]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = SINGLE_ROUND, scale32 = true}
+   // CHECK: %[[V2:.+]] = stablehlo.add %[[V0]], %[[V1]] : tensor<2x2xi32>
+-  // CHECK: %[[V3:.+]] = tosa.rescale %[[V2]], %[[MULTIPLIER_1]], %[[SHIFT50]], %[[ZP_0]], %[[ZP_MINUS_1]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = "SINGLE_ROUND", scale32 = true}
++  // CHECK: %[[V3:.+]] = tosa.rescale %[[V2]], %[[MULTIPLIER_1]], %[[SHIFT50]], %[[ZP_0]], %[[ZP_MINUS_1]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = SINGLE_ROUND, scale32 = true}
+   // CHECK: return %[[V3]] : tensor<2x2x!quant.uniform<i8:f32, 1.500000e-01:-1>>
+   %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<2x2x!quant.uniform<i8:f32, 0.025:-1>>, tensor<2x2x!quant.uniform<i8:f32, 0.075:-1>>)
+             -> tensor<2x2x!quant.uniform<i8:f32, 1.5e-01:-1>>
+@@ -32,10 +32,10 @@
+   // CHECK-DAG: %[[MULTIPLIER_2:.+]] = "tosa.const"() <{values = dense<1431655765> : tensor<1xi32>}>
+   // CHECK-DAG: %[[ZP_MINUS_1:.+]] = "tosa.const"() <{values = dense<-1> : tensor<1xi8>}>
+   // CHECK-DAG: %[[ZP_0:.+]] = "tosa.const"() <{values = dense<0> : tensor<1xi32>}>
+-  // CHECK-DAG: %[[V0:.+]] = tosa.rescale %arg0, %[[MULTIPLIER_2]], %[[SHIFT13]], %[[ZP_MINUS_1]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = "SINGLE_ROUND", scale32 = true}
+-  // CHECK-DAG: %[[V1:.+]] = tosa.rescale %arg1, %[[MULTIPLIER_1]], %[[SHIFT11]], %[[ZP_MINUS_1]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = "SINGLE_ROUND", scale32 = true}
++  // CHECK-DAG: %[[V0:.+]] = tosa.rescale %arg0, %[[MULTIPLIER_2]], %[[SHIFT13]], %[[ZP_MINUS_1]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = SINGLE_ROUND, scale32 = true}
++  // CHECK-DAG: %[[V1:.+]] = tosa.rescale %arg1, %[[MULTIPLIER_1]], %[[SHIFT11]], %[[ZP_MINUS_1]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = SINGLE_ROUND, scale32 = true}
+   // CHECK: %[[V2:.+]] = stablehlo.subtract %[[V0]], %[[V1]] : tensor<2x2xi32>
+-  // CHECK: %[[V3:.+]] = tosa.rescale %[[V2]], %[[MULTIPLIER_1]], %[[SHIFT50]], %[[ZP_0]], %[[ZP_MINUS_1]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = "SINGLE_ROUND", scale32 = true}
++  // CHECK: %[[V3:.+]] = tosa.rescale %[[V2]], %[[MULTIPLIER_1]], %[[SHIFT50]], %[[ZP_0]], %[[ZP_MINUS_1]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = SINGLE_ROUND, scale32 = true}
+   // CHECK: return %[[V3]] : tensor<2x2x!quant.uniform<i8:f32, 1.500000e-01:-1>>
+   %0 = "stablehlo.subtract"(%arg0, %arg1) : (tensor<2x2x!quant.uniform<i8:f32, 0.025:-1>>, tensor<2x2x!quant.uniform<i8:f32, 0.075:-1>>)
+             -> tensor<2x2x!quant.uniform<i8:f32, 1.5e-01:-1>>
+@@ -52,10 +52,10 @@
+   // CHECK-DAG: %[[MULTIPLIER_2:.+]] = "tosa.const"() <{values = dense<1717986918> : tensor<1xi32>}>
+   // CHECK-DAG: %[[ZP_MINUS_1:.+]] = "tosa.const"() <{values = dense<-1> : tensor<1xi8>}>
+   // CHECK-DAG: %[[ZP_0:.+]] = "tosa.const"() <{values = dense<0> : tensor<1xi32>}>
+-  // CHECK-DAG: %[[V0:.+]] = tosa.rescale %arg0, %[[MULTIPLIER_1]], %[[SHIFT30]], %[[ZP_MINUS_1]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = "SINGLE_ROUND", scale32 = true}
+-  // CHECK-DAG: %[[V1:.+]] = tosa.rescale %arg1, %[[MULTIPLIER_1]], %[[SHIFT30]], %[[ZP_MINUS_1]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = "SINGLE_ROUND", scale32 = true}
++  // CHECK-DAG: %[[V0:.+]] = tosa.rescale %arg0, %[[MULTIPLIER_1]], %[[SHIFT30]], %[[ZP_MINUS_1]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = SINGLE_ROUND, scale32 = true}
++  // CHECK-DAG: %[[V1:.+]] = tosa.rescale %arg1, %[[MULTIPLIER_1]], %[[SHIFT30]], %[[ZP_MINUS_1]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = SINGLE_ROUND, scale32 = true}
+   // CHECK: %[[V2:.+]] = stablehlo.multiply %[[V0]], %[[V1]] : tensor<2x2xi32>
+-  // CHECK: %[[V3:.+]] = tosa.rescale %[[V2]], %[[MULTIPLIER_2]], %[[SHIFT37]], %[[ZP_0]], %[[ZP_MINUS_1]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = "SINGLE_ROUND", scale32 = true}
++  // CHECK: %[[V3:.+]] = tosa.rescale %[[V2]], %[[MULTIPLIER_2]], %[[SHIFT37]], %[[ZP_0]], %[[ZP_MINUS_1]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = SINGLE_ROUND, scale32 = true}
+   // CHECK: return %[[V3]] : tensor<2x2x!quant.uniform<i8:f32, 1.500000e-01:-1>>
+   %0 = "stablehlo.multiply"(%arg0, %arg1) : (tensor<2x2x!quant.uniform<i8:f32, 0.025:-1>>, tensor<2x2x!quant.uniform<i8:f32, 0.075:-1>>)
+             -> tensor<2x2x!quant.uniform<i8:f32, 1.5e-01:-1>>
+@@ -74,10 +74,10 @@
+   // CHECK-DAG: %[[ZP_MINUS_2:.+]] = "tosa.const"() <{values = dense<-2> : tensor<1xi8>}>
+   // CHECK-DAG: %[[ZP_MINUS_1:.+]] = "tosa.const"() <{values = dense<-1> : tensor<1xi8>}>
+   // CHECK-DAG: %[[ZP_0:.+]] = "tosa.const"() <{values = dense<0> : tensor<1xi32>}>
+-  // CHECK-DAG: %[[V0:.+]] = tosa.rescale %arg0, %[[MULTIPLIER_1]], %[[SHIFT30]], %[[ZP_MINUS_1]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = "SINGLE_ROUND", scale32 = true}
+-  // CHECK-DAG: %[[V1:.+]] = tosa.rescale %arg1, %[[MULTIPLIER_1]], %[[SHIFT30]], %[[ZP_MINUS_2]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = "SINGLE_ROUND", scale32 = true}
++  // CHECK-DAG: %[[V0:.+]] = tosa.rescale %arg0, %[[MULTIPLIER_1]], %[[SHIFT30]], %[[ZP_MINUS_1]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = SINGLE_ROUND, scale32 = true}
++  // CHECK-DAG: %[[V1:.+]] = tosa.rescale %arg1, %[[MULTIPLIER_1]], %[[SHIFT30]], %[[ZP_MINUS_2]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = SINGLE_ROUND, scale32 = true}
+   // CHECK: %[[V2:.+]] = stablehlo.divide %[[V0]], %[[V1]] : tensor<2x2xi32>
+-  // CHECK: %[[V3:.+]] = tosa.rescale %[[V2]], %[[MULTIPLIER_2]], %[[SHIFT37]], %[[ZP_0]], %[[ZP_MINUS_3]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = "SINGLE_ROUND", scale32 = true}
++  // CHECK: %[[V3:.+]] = tosa.rescale %[[V2]], %[[MULTIPLIER_2]], %[[SHIFT37]], %[[ZP_0]], %[[ZP_MINUS_3]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = SINGLE_ROUND, scale32 = true}
+   // CHECK: return %[[V3]] : tensor<2x2x!quant.uniform<i8:f32, 1.500000e-01:-3>>
+   %0 = "stablehlo.divide"(%arg0, %arg1) : (tensor<2x2x!quant.uniform<i8:f32, 0.025:-1>>, tensor<2x2x!quant.uniform<i8:f32, 0.075:-2>>)
+             -> tensor<2x2x!quant.uniform<i8:f32, 1.5e-01:-3>>
+@@ -97,10 +97,10 @@
+   // CHECK-DAG: %[[SHIFT12:.+]] = "tosa.const"() <{values = dense<12> : tensor<1xi8>}>
+   // CHECK-DAG: %[[ZP_MINUS_1:.+]] = "tosa.const"() <{values = dense<-1> : tensor<1xi8>}>
+   // CHECK-DAG: %[[ZP_0:.+]] = "tosa.const"() <{values = dense<0> : tensor<1xi32>}>
+-  // CHECK-DAG: %[[V0:.+]] = tosa.rescale %arg0, %[[MULTIPLIER_2]], %[[SHIFT12]], %[[ZP_MINUS_1]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = "SINGLE_ROUND", scale32 = true}
+-  // CHECK-DAG: %[[V1:.+]] = tosa.rescale %arg1, %[[MULTIPLIER_1]], %[[SHIFT10]], %[[ZP_MINUS_2]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = "SINGLE_ROUND", scale32 = true}
++  // CHECK-DAG: %[[V0:.+]] = tosa.rescale %arg0, %[[MULTIPLIER_2]], %[[SHIFT12]], %[[ZP_MINUS_1]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = SINGLE_ROUND, scale32 = true}
++  // CHECK-DAG: %[[V1:.+]] = tosa.rescale %arg1, %[[MULTIPLIER_1]], %[[SHIFT10]], %[[ZP_MINUS_2]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = SINGLE_ROUND, scale32 = true}
+   // CHECK: %[[V2:.+]] = stablehlo.maximum %[[V0]], %[[V1]] : tensor<2x2xi32>
+-  // CHECK: %[[V3:.+]] = tosa.rescale %[[V2]], %[[MULTIPLIER_1]], %[[SHIFT51]], %[[ZP_0]], %[[ZP_MINUS_3]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = "SINGLE_ROUND", scale32 = true}
++  // CHECK: %[[V3:.+]] = tosa.rescale %[[V2]], %[[MULTIPLIER_1]], %[[SHIFT51]], %[[ZP_0]], %[[ZP_MINUS_3]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = SINGLE_ROUND, scale32 = true}
+   // CHECK: return %[[V3]] : tensor<2x2x!quant.uniform<i8:f32, 1.500000e-01:-3>>
+   %0 = "stablehlo.maximum"(%arg0, %arg1) : (tensor<2x2x!quant.uniform<i8:f32, 0.025:-1>>, tensor<2x2x!quant.uniform<i8:f32, 0.075:-2>>)
+             -> tensor<2x2x!quant.uniform<i8:f32, 1.5e-01:-3>>
+@@ -120,10 +120,10 @@
+   // CHECK-DAG: %[[SHIFT12:.+]] = "tosa.const"() <{values = dense<12> : tensor<1xi8>}>
+   // CHECK-DAG: %[[ZP_MINUS_1:.+]] = "tosa.const"() <{values = dense<-1> : tensor<1xi8>}>
+   // CHECK-DAG: %[[ZP_0:.+]] = "tosa.const"() <{values = dense<0> : tensor<1xi32>}>
+-  // CHECK-DAG: %[[V0:.+]] = tosa.rescale %arg0, %[[MULTIPLIER_2]], %[[SHIFT12]], %[[ZP_MINUS_1]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = "SINGLE_ROUND", scale32 = true}
+-  // CHECK-DAG: %[[V1:.+]] = tosa.rescale %arg1, %[[MULTIPLIER_1]], %[[SHIFT10]], %[[ZP_MINUS_2]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = "SINGLE_ROUND", scale32 = true}
++  // CHECK-DAG: %[[V0:.+]] = tosa.rescale %arg0, %[[MULTIPLIER_2]], %[[SHIFT12]], %[[ZP_MINUS_1]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = SINGLE_ROUND, scale32 = true}
++  // CHECK-DAG: %[[V1:.+]] = tosa.rescale %arg1, %[[MULTIPLIER_1]], %[[SHIFT10]], %[[ZP_MINUS_2]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = SINGLE_ROUND, scale32 = true}
+   // CHECK: %[[V2:.+]] = stablehlo.minimum %[[V0]], %[[V1]] : tensor<2x2xi32>
+-  // CHECK: %[[V3:.+]] = tosa.rescale %[[V2]], %[[MULTIPLIER_1]], %[[SHIFT51]], %[[ZP_0]], %[[ZP_MINUS_3]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = "SINGLE_ROUND", scale32 = true}
++  // CHECK: %[[V3:.+]] = tosa.rescale %[[V2]], %[[MULTIPLIER_1]], %[[SHIFT51]], %[[ZP_0]], %[[ZP_MINUS_3]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = SINGLE_ROUND, scale32 = true}
+   // CHECK: return %[[V3]] : tensor<2x2x!quant.uniform<i8:f32, 1.500000e-01:-3>>
+   %0 = "stablehlo.minimum"(%arg0, %arg1) : (tensor<2x2x!quant.uniform<i8:f32, 0.025:-1>>, tensor<2x2x!quant.uniform<i8:f32, 0.075:-2>>)
+             -> tensor<2x2x!quant.uniform<i8:f32, 1.5e-01:-3>>
+@@ -140,9 +140,9 @@
+   // CHECK-DAG: %[[SHIFT30:.+]] = "tosa.const"() <{values = dense<30> : tensor<1xi8>}>
+   // CHECK-DAG: %[[ZP_MINUS_1:.+]] = "tosa.const"() <{values = dense<-1> : tensor<1xi8>}>
+   // CHECK-DAG: %[[ZP_0:.+]] = "tosa.const"() <{values = dense<0> : tensor<1xi32>}>
+-  // CHECK: %[[V0:.+]] = tosa.rescale %arg0, %[[MULTIPLIER_2]], %[[SHIFT30]], %[[ZP_MINUS_1]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = "SINGLE_ROUND", scale32 = true}
++  // CHECK: %[[V0:.+]] = tosa.rescale %arg0, %[[MULTIPLIER_2]], %[[SHIFT30]], %[[ZP_MINUS_1]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = SINGLE_ROUND, scale32 = true}
+   // CHECK: %[[V1:.+]] = stablehlo.abs %[[V0]] : tensor<20x20xi32>
+-  // CHECK: %[[V3:.+]] = tosa.rescale %[[V1]], %[[MULTIPLIER_1]], %[[SHIFT33]], %[[ZP_0]], %[[ZP_MINUS_128]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = "SINGLE_ROUND", scale32 = true}
++  // CHECK: %[[V3:.+]] = tosa.rescale %[[V1]], %[[MULTIPLIER_1]], %[[SHIFT33]], %[[ZP_0]], %[[ZP_MINUS_128]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = SINGLE_ROUND, scale32 = true}
+   // CHECK: return %[[V3]] : tensor<20x20x!quant.uniform<i8:f32, 1.500000e-01:-128>>
+   %0 = "stablehlo.abs"(%arg0) : (tensor<20x20x!quant.uniform<i8:f32, 0.025:-1>>) -> tensor<20x20x!quant.uniform<i8:f32, 1.5e-01:-128>>
+   return %0 : tensor<20x20x!quant.uniform<i8:f32, 1.5e-01:-128>>
+@@ -159,8 +159,8 @@
+   // CHECK-DAG: %[[SHIFT12:.+]] = "tosa.const"() <{values = dense<12> : tensor<1xi8>}>
+   // CHECK-DAG: %[[ZP_MINUS_1:.+]] = "tosa.const"() <{values = dense<-1> : tensor<1xi8>}>
+   // CHECK-DAG: %[[ZP_0:.+]] = "tosa.const"() <{values = dense<0> : tensor<1xi32>}>
+-  // CHECK: %[[V0:.+]] = tosa.rescale %arg0, %[[MULTIPLIER_2]], %[[SHIFT12]], %[[ZP_MINUS_1]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = "SINGLE_ROUND", scale32 = true}
+-  // CHECK: %[[V1:.+]] = tosa.rescale %arg1, %[[MULTIPLIER_1]], %[[SHIFT10]], %[[ZP_MINUS_2]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = "SINGLE_ROUND", scale32 = true}
++  // CHECK: %[[V0:.+]] = tosa.rescale %arg0, %[[MULTIPLIER_2]], %[[SHIFT12]], %[[ZP_MINUS_1]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = SINGLE_ROUND, scale32 = true}
++  // CHECK: %[[V1:.+]] = tosa.rescale %arg1, %[[MULTIPLIER_1]], %[[SHIFT10]], %[[ZP_MINUS_2]], %[[ZP_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = SINGLE_ROUND, scale32 = true}
+   // CHECK: %[[V2:.+]] = stablehlo.compare GE, %[[V0]], %[[V1]], TOTALORDER :
+   // CHECK: return %[[V2]]
+   %0 = stablehlo.compare GE, %arg0, %arg1, TOTALORDER : (tensor<20x20x!quant.uniform<i8:f32, 0.025:-1>>, tensor<20x20x!quant.uniform<i8:f32, 0.075:-2>>) -> tensor<20x20xi1>
+@@ -177,8 +177,8 @@
+   // CHECK-DAG: %[[SHIFT15:.+]] = "tosa.const"() <{values = dense<15> : tensor<1xi8>}>
+   // CHECK-DAG: %[[ZP16_0:.+]] = "tosa.const"() <{values = dense<0> : tensor<1xi16>}>
+   // CHECK-DAG: %[[ZP32_0:.+]] = "tosa.const"() <{values = dense<0> : tensor<1xi32>}>
+-  // CHECK: %[[V0:.+]] = tosa.rescale %arg0, %[[MULTIPLIER_2]], %[[SHIFT17]], %[[ZP16_0]], %[[ZP32_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = "SINGLE_ROUND", scale32 = true}
+-  // CHECK: %[[V1:.+]] = tosa.rescale %arg1, %[[MULTIPLIER_1]], %[[SHIFT15]], %[[ZP16_0]], %[[ZP32_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = "SINGLE_ROUND", scale32 = true}
++  // CHECK: %[[V0:.+]] = tosa.rescale %arg0, %[[MULTIPLIER_2]], %[[SHIFT17]], %[[ZP16_0]], %[[ZP32_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = SINGLE_ROUND, scale32 = true}
++  // CHECK: %[[V1:.+]] = tosa.rescale %arg1, %[[MULTIPLIER_1]], %[[SHIFT15]], %[[ZP16_0]], %[[ZP32_0]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = SINGLE_ROUND, scale32 = true}
+   // CHECK: %[[V2:.+]] = stablehlo.compare LT, %[[V0]], %[[V1]], TOTALORDER :
+   // CHECK: return %[[V2]]
+   %0 = stablehlo.compare LT, %arg0, %arg1, TOTALORDER : (tensor<20x20x!quant.uniform<i16:f32, 0.025:0>>, tensor<20x20x!quant.uniform<i16:f32, 0.075:0>>) -> tensor<20x20xi1>
+diff --ruN a/stablehlo/stablehlo/conversions/tosa/tests/legalize_tosa_rescale_to_stablehlo.mlir b/stablehlo/stablehlo/conversions/tosa/tests/legalize_tosa_rescale_to_stablehlo.mlir
+--- stablehlo/stablehlo/conversions/tosa/tests/legalize_tosa_rescale_to_stablehlo.mlir
++++ stablehlo/stablehlo/conversions/tosa/tests/legalize_tosa_rescale_to_stablehlo.mlir
+@@ -7,7 +7,7 @@
+   %shift = "tosa.const"() {values = dense<13> : tensor<1xi8>} : () -> tensor<1xi8>
+   %input_zp = "tosa.const"() {values = dense<-1> : tensor<1xi8>} : () -> tensor<1xi8>
+   %output_zp = "tosa.const"() {values = dense<0> : tensor<1xi32>} : () -> tensor<1xi32>
+-  %0 = tosa.rescale %arg0, %multiplier, %shift, %input_zp, %output_zp {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = "SINGLE_ROUND", scale32 = true} :
++  %0 = tosa.rescale %arg0, %multiplier, %shift, %input_zp, %output_zp {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = SINGLE_ROUND, scale32 = true} :
+             (tensor<2x2x!quant.uniform<i8:f32, 0.025:-1>>, tensor<1xi32>, tensor<1xi8>, tensor<1xi8>, tensor<1xi32>) -> tensor<2x2xi32>
+ 
+   // convert input quantized type to storage type
+diff --ruN a/stablehlo/stablehlo/conversions/tosa/transforms/StablehloQuantLegalizeToTosaRescale.cpp b/stablehlo/stablehlo/conversions/tosa/transforms/StablehloQuantLegalizeToTosaRescale.cpp
+--- stablehlo/stablehlo/conversions/tosa/transforms/StablehloQuantLegalizeToTosaRescale.cpp
++++ stablehlo/stablehlo/conversions/tosa/transforms/StablehloQuantLegalizeToTosaRescale.cpp
+@@ -70,12 +70,14 @@
+       outputZpVal.has_value() &&
+       "buildRescale: Failed to create output zero-point tensor for RescaleOp.");
+ 
+-  std::string roundingMode = doubleRound ? "DOUBLE_ROUND" : "SINGLE_ROUND";
++  auto roundingMode =
++      doubleRound ? RoundingMode::DOUBLE_ROUND : RoundingMode::SINGLE_ROUND;
+ 
+   auto rescale_op = rewriter.create<RescaleOp>(
+       loc, outputType, inputVal, multiplierVal, shiftVal, inputZpVal.value(),
+       outputZpVal.value(), rewriter.getBoolAttr(scale32),
+-      rewriter.getStringAttr(roundingMode), rewriter.getBoolAttr(perChannel),
++      RoundingModeAttr::get(rewriter.getContext(), roundingMode),
++      rewriter.getBoolAttr(perChannel),
+       /*input_unsigned=*/rewriter.getBoolAttr(false),
+       /*output_unsigned=*/rewriter.getBoolAttr(false));
+ 
+diff --ruN a/stablehlo/stablehlo/conversions/tosa/transforms/TosaRescaleLegalizeToStablehlo.cpp b/stablehlo/stablehlo/conversions/tosa/transforms/TosaRescaleLegalizeToStablehlo.cpp
+--- stablehlo/stablehlo/conversions/tosa/transforms/TosaRescaleLegalizeToStablehlo.cpp
++++ stablehlo/stablehlo/conversions/tosa/transforms/TosaRescaleLegalizeToStablehlo.cpp
+@@ -68,7 +68,7 @@
+   auto roundingMode = op.getRoundingMode();
+   bool perChannel = op.getPerChannel();
+ 
+-  if (perChannel || roundingMode != "SINGLE_ROUND" || !scale32) {
++  if (perChannel || roundingMode != RoundingMode::SINGLE_ROUND || !scale32) {
+     return rewriter.notifyMatchFailure(
+         op,
+         "per_channel, double_round, or scale32=false are not yet supported");
 diff --ruN a/stablehlo/stablehlo/dialect/StablehloOps.cpp b/stablehlo/stablehlo/dialect/StablehloOps.cpp
 --- stablehlo/stablehlo/dialect/StablehloOps.cpp
 +++ stablehlo/stablehlo/dialect/StablehloOps.cpp
