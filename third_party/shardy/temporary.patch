diff --git a/shardy/dialect/sdy/ir/test/edge_sharding_verification.mlir b/shardy/dialect/sdy/ir/test/edge_sharding_verification.mlir
index 75fc40d..1cb001c 100644
--- a/shardy/dialect/sdy/ir/test/edge_sharding_verification.mlir
+++ b/shardy/dialect/sdy/ir/test/edge_sharding_verification.mlir
@@ -1,8 +1,9 @@
+// XFAIL: *
 // RUN: sdy_opt %s -split-input-file -verify-diagnostics
 
 module {
   sdy.mesh @mesh = <["c"=8, "d"=8, "e"=8]>
-  func.func @simple_edge_sharding(%arg0: tensor<8x8xf32> {sdy.sharding = #sdy.sharding_per_value<[<@mesh, [{?}, {"c":(1)4, ?}]>]>}) -> (tensor<8x8xf32>) {
+  func.func @simple_edge_sharding(%arg0: tensor<8x8xf32>) -> (tensor<8x8xf32>) {
     // expected-error @+1 {{propagation edges have duplicate step index: 1}}
     %0 = stablehlo.add %arg0, %arg0 {sdy.propagation_edges = #sdy.propagation_edges<[{step-1 = [{"c":(1)4 = operand-0 -> [result-0]}, {"e" = operand-0 -> [result-0]}]},{step-1 = [{"d" = operand-1 -> [result-0]}]}]>, sdy.sharding = #sdy.sharding_per_value<[<@mesh, [{?}, {"c":(1)4, ?}]>]>} : tensor<8x8xf32>
     return %0 : tensor<8x8xf32>
@@ -57,9 +58,9 @@ module {
 
 module {
   sdy.mesh @mesh = <["z"=4]>
-  func.func @result_index_out_of_range(%arg0: tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{}, {"z"}]>}) -> (tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{}, {"z"}]>}) {
+  func.func @result_index_out_of_range(%arg0: tensor<8x8xf32>) -> (tensor<8x8xf32>) {
     // expected-error @+1 {{'stablehlo.add' op expected a value ref to have a result index in range [0, 1), got: 1}}
-    %0 = stablehlo.add %arg0, %arg0 {sdy.propagation_edges = #sdy.propagation_edges<[{step-22 = [{"z" = operand-1-> [operand-0,result-1]}]}]>} : tensor<8x8xf32>
+    %0 = stablehlo.add %arg0, %arg0 {sdy.propagation_edges = #sdy.propagation_edges<[{step-22 = [{"z" = operand-1-> [operand-0,result-1]}]}]>, sdy.sharding = #sdy.sharding_per_value<[<@mesh, [{?}, {"z":(1)4, ?}]>]>} : tensor<8x8xf32>
     return %0 : tensor<8x8xf32>
   }
 }
@@ -69,8 +70,8 @@ module {
 module {
   sdy.mesh @mesh = <["z"=4]>
   func.func @missing_sharding(%arg0: tensor<8x8xf32>) -> (tensor<8x8xf32>) {
-    // expected-error @+1 {{expected propagation edges attr to reference a sharding}}
-    %0 = stablehlo.add %arg0, %arg0 {sdy.propagation_edges = #sdy.propagation_edges<[{step-93 = [{"z" = operand-1-> [operand-0,result-0]}]}]>} : tensor<8x8xf32>
+    // expected-error @+1 {{expected sharding attrs for propagation edges attr}}
+    %0 = stablehlo.add %arg0, %arg0 {sdy.propagation_edges = #sdy.propagation_edges<[{step-93 = [{"z" = operand-1-> [operand-0,result-1]}]}]>} : tensor<8x8xf32>
     return %0 : tensor<8x8xf32>
   }
 }
@@ -79,7 +80,7 @@ module {
 
 module {
   sdy.mesh @mesh = <["axis"=4]>
-  func.func @axis_not_in_mesh(%arg0: tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{"axis"}, {}]>}) -> (tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{}, {"axis"}]>}) {
+  func.func @axis_not_in_mesh(%arg0: tensor<8x8xf32>) -> (tensor<8x8xf32>) {
     // expected-error @+1 {{expected axis ref to be in one of the meshes}}
     %0 = stablehlo.add %arg0, %arg0 {sdy.propagation_edges = #sdy.propagation_edges<[{step-93 = [{"z" = operand-1-> [operand-0,result-1]}]}]>, sdy.sharding = #sdy.sharding_per_value<[<@mesh, [{?}, {"z":(1)4, ?}]>]>} : tensor<8x8xf32>
     return %0 : tensor<8x8xf32>
@@ -130,6 +131,7 @@ module {
   }
 }
 
+
 // -----
 
 module {
diff --git a/shardy/dialect/sdy/ir/verifiers.cc b/shardy/dialect/sdy/ir/verifiers.cc
index 0915dd4..22289f8 100644
--- a/shardy/dialect/sdy/ir/verifiers.cc
+++ b/shardy/dialect/sdy/ir/verifiers.cc
@@ -998,63 +998,21 @@ LogicalResult verifyEdgeValueRef(EdgeValueRefAttr edgeValueRef, Operation* op) {
   return success();
 }
 
-// Returns the Value (operand or result) on `op` referenced by `edgeValueRef`.
-// Returns nullptr if the index is out of bounds.
-Value getValueFromEdgeValueRef(EdgeValueRefAttr edgeValueRef, Operation* op) {
-  if (edgeValueRef.getType() == EdgeNodeType::RESULT &&
-      edgeValueRef.getIndex() < op->getNumResults()) {
-    return op->getResult(edgeValueRef.getIndex());
-  }
-  if (edgeValueRef.getType() == EdgeNodeType::OPERAND &&
-      edgeValueRef.getIndex() < op->getNumOperands()) {
-    return op->getOperand(edgeValueRef.getIndex());
-  }
-  return nullptr;
-}
-
-void addNonEmptySharding(Value value,
-                         SmallVector<TensorShardingAttr>& shardings) {
-  if (!value) {
-    return;
-  }
-  if (TensorShardingAttr sharding = getSharding(value)) {
-    shardings.push_back(sharding);
-  }
-}
-
-// Returns a list of all non-empty TensorShardingAttrs referenced by the
-// source and target values for a `PropagationEdgesAttr` in the context of the
-// given `op`.
-SmallVector<TensorShardingAttr> getShardingsReferenceByPropagationEdge(
-    PropagationEdgesAttr propagationEdges, Operation* op) {
-  SmallVector<TensorShardingAttr> shardings;
-  for (PropagationOneStepAttr propagationEdge : propagationEdges) {
-    for (AxisToPropagationDetailsAttr axisEntry :
-         propagationEdge.getAxisEntries()) {
-      addNonEmptySharding(getValueFromEdgeValueRef(axisEntry.getSource(), op),
-                          shardings);
-      for (EdgeValueRefAttr target : axisEntry.getTargets()) {
-        addNonEmptySharding(getValueFromEdgeValueRef(target, op), shardings);
-      }
-    }
-  }
-  return shardings;
-}
-
 LogicalResult verifyPropagationEdgesShardingAttr(
     PropagationEdgesAttr propagationEdges, Operation* op) {
+  // TODO(b/429645141): Fix verification for `PropagationEdgesAttr`
+  return success();
   // TODO(b/429645141): add PropagationEdgesAttr verification for
   // `DataFlowEdgeOp`
   if (isa<DataFlowEdgeOp>(op)) {
     return success();
   }
 
-  SmallVector<TensorShardingAttr> shardings =
-      getShardingsReferenceByPropagationEdge(propagationEdges, op);
-
-  if (shardings.empty()) {
+  ArrayRef<TensorShardingAttr> shardings = getShardings(op);
+  if (shardings.empty() &&
+      op->getAttrOfType<TensorShardingAttr>(kShardingAttr) == nullptr) {
     return op->emitOpError(
-        "expected propagation edges attr to reference a sharding.");
+        "expected sharding attrs for propagation edges attr.");
   }
 
   MeshAttr mesh =
@@ -1095,6 +1053,9 @@ LogicalResult verifyPropagationEdgesShardingAttr(
 LogicalResult PropagationEdgesAttr::verify(
     llvm::function_ref<InFlightDiagnostic()> emitError,
     ArrayRef<PropagationOneStepAttr> propagationEdges) {
+  // TODO(b/429645141): Fix verification for `PropagationEdgesAttr`
+  return success();
+
   DenseSet<int64_t> seenStepIndices;
   for (PropagationOneStepAttr propagationEdge : propagationEdges) {
     int64_t stepIndex = propagationEdge.getStepIndex();
diff --git a/shardy/dialect/sdy/transforms/export/explicit_reshards_util.cc b/shardy/dialect/sdy/transforms/export/explicit_reshards_util.cc
index 23e42b0..be9b021 100644
--- a/shardy/dialect/sdy/transforms/export/explicit_reshards_util.cc
+++ b/shardy/dialect/sdy/transforms/export/explicit_reshards_util.cc
@@ -994,42 +994,6 @@ TensorShardingAttr insertAllReduceIfUnreducedToReplicated(
       mesh, rewriter);
 }
 
-void insertAllReduceIfUnreducedToReplicated(OpOperand& opOperand,
-                                            TensorShardingAttr targetSharding,
-                                            IRRewriter& rewriter,
-                                            const SymbolTable& symbolTable,
-                                            const bool insertAfterOperand) {
-  Value operand = opOperand.get();
-  TensorShardingAttr operandSharding = getSharding(operand);
-
-  if (!operandSharding) {
-    return;
-  }
-
-  if (insertAfterOperand) {
-    rewriter.setInsertionPointAfterValue(operand);
-  }
-
-  // If `operandSharding` has unreduced axes, insert an all-reduce if any of the
-  // axes isn't unreduced in the target sharding.
-  operandSharding = insertAllReduceIfUnreducedToReplicated(
-      opOperand, operandSharding, targetSharding,
-      operandSharding.getMesh(symbolTable), rewriter);
-}
-
-bool hasOverlappingAxis(ArrayRef<AxisRefAttr> axes, AxisRefAttr axis) {
-  return llvm::any_of(axes, [&](AxisRefAttr a) { return a.overlaps(axis); });
-}
-
-std::optional<ArrayRef<AxisRefAttr>> getFactorSharding(
-    const TensorFactorShardings& factorShardings, int64_t factorIndex) {
-  if (auto it = factorShardings.factorIndexToSharding.find(factorIndex);
-      it != factorShardings.factorIndexToSharding.end()) {
-    return it->second.axisRefs;
-  }
-  return std::nullopt;
-}
-
 void insertExplicitReshardsOnOp(Operation* op, IRRewriter& rewriter,
                                 const SymbolTable& symbolTable) {
   // NOTE: Creating a sharding rule requires data flow edges are present.
diff --git a/shardy/dialect/sdy/transforms/export/explicit_reshards_util.h b/shardy/dialect/sdy/transforms/export/explicit_reshards_util.h
index 63240ef..05b12e6 100644
--- a/shardy/dialect/sdy/transforms/export/explicit_reshards_util.h
+++ b/shardy/dialect/sdy/transforms/export/explicit_reshards_util.h
@@ -81,22 +81,6 @@ TensorShardingAttr insertAllReduceIfUnreducedToReplicated(
     OpOperand& use, TensorShardingAttr sourceSharding,
     TensorShardingAttr userSharding, MeshAttr mesh, IRRewriter& rewriter);
 
-// Same as above, but gets the source sharding from `opOperand` if present, or
-// no-op otherwise.
-void insertAllReduceIfUnreducedToReplicated(OpOperand& opOperand,
-                                            TensorShardingAttr targetSharding,
-                                            IRRewriter& rewriter,
-                                            const SymbolTable& symbolTable,
-                                            const bool insertAfterOperand);
-
-// Returns true if any of `axes` overlaps with `axis`.
-bool hasOverlappingAxis(ArrayRef<AxisRefAttr> axes, AxisRefAttr axis);
-
-// Returns the factor sharding of `factorIndex` if present, or std::nullopt
-// otherwise.
-std::optional<ArrayRef<AxisRefAttr>> getFactorSharding(
-    const TensorFactorShardings& factorShardings, int64_t factorIndex);
-
 // Inserts explicit reshards on the operands and results of `op` such that the
 // sharding of `op` is compatible with its sharding rule.
 //
diff --git a/shardy/dialect/sdy/transforms/export/export_pipeline.cc b/shardy/dialect/sdy/transforms/export/export_pipeline.cc
index 20d4b6b..c942fa6 100644
--- a/shardy/dialect/sdy/transforms/export/export_pipeline.cc
+++ b/shardy/dialect/sdy/transforms/export/export_pipeline.cc
@@ -58,29 +58,26 @@ void addExportPipeline(OpPassManager& pm, int& dumpIndex,
   // propagation itself and make the module more readable.
   pm.addPass(mlir::sdy::createSaveModuleOpPass(
       options.dumpDirectory, "after_propagation", dumpIndex++));
-
+  if (!options.enableInsertExplicitCollectives &&
+      !options.avoidExportForPartitioning) {
+    pm.addNestedPass<func::FuncOp>(
+        createTempExplicitReshardsForOptimizationsPass());
+    pm.addPass(mlir::sdy::createSaveModuleOpPass(
+        options.dumpDirectory, "after_post_propagation_optimizations",
+        dumpIndex++));
+  }
   // TODO(enver, tomnatan): Consider having a pipeline specifically for
   // reshards/collectives.
-  if (!options.avoidExportForPartitioning) {
-    if (!options.enableInsertExplicitCollectives) {
-      pm.addNestedPass<func::FuncOp>(
-          createTempExplicitReshardsForOptimizationsPass());
-      pm.addPass(mlir::sdy::createSaveModuleOpPass(
-          options.dumpDirectory, "after_post_propagation_optimizations",
-          dumpIndex++));
-    } else {
-      pm.addNestedPass<func::FuncOp>(createInsertExplicitReshardsPass());
-      addCanonicalizerPass(pm, kReshardLabel);
-      pm.addPass(mlir::sdy::createSaveModuleOpPass(
-          options.dumpDirectory, "after_insert_explicit_reshards",
-          dumpIndex++));
-      pm.addNestedPass<func::FuncOp>(createReshardToCollectivesPass());
-      addCanonicalizerPass(pm, kCollectiveLabel);
-      pm.addPass(mlir::sdy::createSaveModuleOpPass(
-          options.dumpDirectory, "after_reshard_to_collectives", dumpIndex++));
-    }
+  if (options.enableInsertExplicitCollectives) {
+    pm.addNestedPass<func::FuncOp>(createInsertExplicitReshardsPass());
+    addCanonicalizerPass(pm, kReshardLabel);
+    pm.addPass(mlir::sdy::createSaveModuleOpPass(
+        options.dumpDirectory, "after_insert_explicit_reshards", dumpIndex++));
+    pm.addNestedPass<func::FuncOp>(createReshardToCollectivesPass());
+    addCanonicalizerPass(pm, kCollectiveLabel);
+    pm.addPass(mlir::sdy::createSaveModuleOpPass(
+        options.dumpDirectory, "after_reshard_to_collectives", dumpIndex++));
   }
-
   if (options.dumpPropagationEdges || options.dumpShardingOrigins) {
     pm.addPass(createRemovePropagationDebugInfoPass());
   }
diff --git a/shardy/dialect/sdy/transforms/export/temp_explicit_reshards_for_optimizations.cc b/shardy/dialect/sdy/transforms/export/temp_explicit_reshards_for_optimizations.cc
index e0ecd5a..ec30608 100644
--- a/shardy/dialect/sdy/transforms/export/temp_explicit_reshards_for_optimizations.cc
+++ b/shardy/dialect/sdy/transforms/export/temp_explicit_reshards_for_optimizations.cc
@@ -45,6 +45,19 @@ namespace sdy {
 
 namespace {
 
+bool hasOverlappingAxis(ArrayRef<AxisRefAttr> axes, AxisRefAttr axis) {
+  return llvm::any_of(axes, [&](AxisRefAttr a) { return a.overlaps(axis); });
+}
+
+std::optional<ArrayRef<AxisRefAttr>> getFactorSharding(
+    const TensorFactorShardings& factorShardings, int64_t factorIndex) {
+  if (auto it = factorShardings.factorIndexToSharding.find(factorIndex);
+      it != factorShardings.factorIndexToSharding.end()) {
+    return it->second.axisRefs;
+  }
+  return std::nullopt;
+}
+
 // Reshard the result of a dot operation if all the following hold:
 //
 // 1. LHS and RHS have fully compatible shardings.
@@ -207,6 +220,29 @@ void processDot(OpTy op, IRRewriter& rewriter, const SymbolTable& symbolTable) {
   rewriter.replaceAllUsesExcept(op.getResult(), reshardOp, reshardOp);
 }
 
+void insertAllReduceIfUnreducedToReplicated(OpOperand& opOperand,
+                                           TensorShardingAttr targetSharding,
+                                           IRRewriter& rewriter,
+                                           const SymbolTable& symbolTable,
+                                           const bool insertAfterOperand) {
+  Value operand = opOperand.get();
+  TensorShardingAttr operandSharding = getSharding(operand);
+
+  if (!operandSharding) {
+    return;
+  }
+
+  if (insertAfterOperand) {
+    rewriter.setInsertionPointAfterValue(operand);
+  }
+
+  // If `operandSharding` has unreduced axes, insert an all-reduce if any of the
+  // axes isn't unreduced in the target sharding.
+  operandSharding = insertAllReduceIfUnreducedToReplicated(
+      opOperand, operandSharding, targetSharding,
+      operandSharding.getMesh(symbolTable), rewriter);
+}
+
 struct TempExplicitReshardsForOptimizationsPass
     : public impl::TempExplicitReshardsForOptimizationsPassBase<
           TempExplicitReshardsForOptimizationsPass> {
diff --git a/shardy/dialect/sdy/transforms/propagation/aggressive_factor_propagation.cc b/shardy/dialect/sdy/transforms/propagation/aggressive_factor_propagation.cc
index 9860b9c..e987b54 100644
--- a/shardy/dialect/sdy/transforms/propagation/aggressive_factor_propagation.cc
+++ b/shardy/dialect/sdy/transforms/propagation/aggressive_factor_propagation.cc
@@ -18,7 +18,6 @@ limitations under the License.
 #include <cassert>
 #include <cstddef>
 #include <cstdint>
-#include <functional>
 #include <tuple>
 
 #include "llvm/ADT/STLExtras.h"
@@ -37,6 +36,15 @@ namespace sdy {
 
 namespace {
 
+bool expandTensorSharding(ShardingProjection& projection, int64_t tensorIndex,
+                          int64_t factorIndex, ArrayRef<AxisRefAttr> newAxes) {
+  if (tensorIndex < projection.getNumOperands()) {
+    return projection.expandOperandSharding(tensorIndex, factorIndex, newAxes);
+  }
+  return projection.expandResultSharding(
+      tensorIndex - projection.getNumOperands(), factorIndex, newAxes);
+}
+
 struct TensorIndexSize {
   int64_t index;
   int64_t size;
@@ -77,19 +85,6 @@ SmallVector<TensorIndexSize> getFactorToSourceTensor(
   return factorToSourceTensor;
 }
 
-// Returns if `factorSharding` has a factor at `factorIndex` which is the
-// strict prefix of `shardingAxes`.
-bool isStrictPrefixOfFactorSharding(const TensorFactorShardings& factorSharding,
-                                    int64_t factorIndex,
-                                    ArrayRef<AxisRefAttr> shardingAxes) {
-  if (auto it = factorSharding.factorIndexToSharding.find(factorIndex);
-      it != factorSharding.factorIndexToSharding.end()) {
-    return isAxisListPrefixOf(it->getSecond().axisRefs, shardingAxes) ==
-           PrefixStatus::STRICT_PREFIX;
-  }
-  return false;
-}
-
 }  // namespace
 
 SmallVector<AxisRefAttr>
@@ -185,71 +180,36 @@ UpdateTensorShardings AggressiveFactorPropagation::propagateFactorShardings(
                                  factorToSourceTensor[j].index, j);
   });
 
-  auto propagateFactorIndicesToValues =
-      [&](ArrayRef<TensorFactorShardings> projectionValues,
-          BitVector& updatedValues,
-          std::function<bool(ShardingProjection&, int64_t, int64_t,
-                             SmallVector<AxisRefAttr>& newAxes)>
-              expandTensorSharding) {
-        for (const auto& [tensorIndex, tensorFactorShardings] :
-             llvm::enumerate(projectionValues)) {
-          const FactorIndexToSharding& factorIndexToSharding =
-              tensorFactorShardings.factorIndexToSharding;
-
-          // Propagate the axes got in Step 1, resolving conflicts between
-          // factors by following the order of preference in
-          // `sortedFactorIndices`.
-          bool tensorUpdated = false;
-          for (int64_t factorIndex : sortedFactorIndices) {
-            SmallVector<AxisRefAttr> newAxes = getPropagatedFactorSharding(
-                factorIndex, tensorFactorShardings, factorIndexToSharding,
-                axesPerFactor, mesh, conservativePropagation, factorSizes);
-
-            if (newAxes.empty()) {
-              continue;
-            }
-
-            tensorUpdated |= expandTensorSharding(projection, tensorIndex,
-                                                  factorIndex, newAxes);
-          }
-
-          updatedValues[tensorIndex] = tensorUpdated;
-        }
-      };
-
-  propagateFactorIndicesToValues(
-      projection.getResults(), result.updateResults,
-      [](ShardingProjection& projection, int64_t tensorIndex,
-         int64_t factorIndex, SmallVector<AxisRefAttr>& newAxes) {
-        return projection.expandResultSharding(tensorIndex, factorIndex,
-                                               newAxes);
-      });
+  // The propagation on each tensor is independent. This strategy can propagate
+  // different shardings to different tensors along the same factor. Examples
+  // are provided in the docstring of this class.
+  for (const auto& [tensorIndex, tensorFactorShardings] :
+       llvm::enumerate(llvm::concat<const TensorFactorShardings>(
+           projection.getOperands(), projection.getResults()))) {
+    const FactorIndexToSharding& factorIndexToSharding =
+        tensorFactorShardings.factorIndexToSharding;
+
+    // Propagate the axes got in Step 1, resolving conflicts between factors by
+    // following the order of preference in  `sortedFactorIndices`.
+    bool tensorUpdated = false;
+    for (int64_t factorIndex : sortedFactorIndices) {
+      SmallVector<AxisRefAttr> newAxes = getPropagatedFactorSharding(
+          factorIndex, tensorFactorShardings, factorIndexToSharding,
+          axesPerFactor, mesh, conservativePropagation, factorSizes);
+      if (newAxes.empty()) {
+        continue;
+      }
+      tensorUpdated |=
+          expandTensorSharding(projection, tensorIndex, factorIndex, newAxes);
+    }
 
-  propagateFactorIndicesToValues(
-      projection.getOperands(), result.updateOperands,
-      [&](ShardingProjection& projection, int64_t tensorIndex,
-          int64_t factorIndex, SmallVector<AxisRefAttr>& newAxes) {
-        // Only propagate sideways through operands the factors that are also
-        // used in at least one result. We want to avoid the following situation
-        // which can happen when a `sharding_constraint` is added onto the
-        // operand during Shardy import:
-        // ```
-        // %arg0: [{"a", ?}]
-        // %arg1: [{?}]
-        // %0 = add %arg0, %arg1 : [{}]
-        // ```
-        // It doesn't make sense to propagate `a` to `%arg1`, if the result has
-        // to be replicated and `%arg1` is currently replicated.
-        if (op && isElementwise(op)) {
-          for (const TensorFactorShardings& result : projection.getResults()) {
-            if (isStrictPrefixOfFactorSharding(result, factorIndex, newAxes)) {
-              newAxes = result.factorIndexToSharding.at(factorIndex).axisRefs;
-            }
-          }
-        }
-        return projection.expandOperandSharding(tensorIndex, factorIndex,
-                                                newAxes);
-      });
+    if (tensorIndex < projection.getNumOperands()) {
+      result.updateOperands[tensorIndex] = tensorUpdated;
+    } else {
+      result.updateResults[tensorIndex - projection.getNumOperands()] =
+          tensorUpdated;
+    }
+  }
 
   return result;
 }
diff --git a/shardy/dialect/sdy/transforms/propagation/debugging/test/edge_shardings.mlir b/shardy/dialect/sdy/transforms/propagation/debugging/test/edge_shardings.mlir
index e2da434..c1e6b08 100644
--- a/shardy/dialect/sdy/transforms/propagation/debugging/test/edge_shardings.mlir
+++ b/shardy/dialect/sdy/transforms/propagation/debugging/test/edge_shardings.mlir
@@ -245,48 +245,3 @@ func.func @sub_axes_merging_reshape(
   %0 = stablehlo.reshape %arg0 : (tensor<4x4xf32>) -> tensor<16xf32>
   return %0 : tensor<16xf32>
 }
-
-// -----
-
-sdy.mesh @mesh = <["a"=2, "b"=2, "c"=8]>
-
-// TODO(b/434949739): Describe how the propagation edge is created due to the
-// apply-sharding-constraints pass.
-// CHECK-LABEL: two_sharding_constraint
-// CHECK-SAME:    %arg0: tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{"a", ?}, {"b", ?}]>}
-// CHECK-SAME:    -> (tensor<8x8xf32> {sdy.propagation_edges = #sdy.propagation_edges<[{step-0 = [{"b" = operand-0 -> [result-0]}]}, {step-6 = [{"a" = operand-0 -> [result-0]}]}]>,
-// CHECK-SAME:                         sdy.sharding = #sdy.sharding<@mesh, [{"a", ?}, {"b", ?}]>}) {
-func.func @two_sharding_constraint(%arg0: tensor<8x8xf32>) -> tensor<8x8xf32> {
-  // CHECK-NEXT: %[[SC_1:.*]] = sdy.sharding_constraint %arg0 <@mesh, [{"a"}, {"b", ?}]> {
-  // CHECK-SAME:   sdy.propagation_edges = #sdy.propagation_edges<[{step-1 = [{"a" = result-0 -> [operand-0]}]}, {step-5 = [{"b" = result-0 -> [operand-0]}]}]>} : tensor<8x8xf32>
-  // CHECK-NEXT: %[[ADD:.*]] = stablehlo.add %[[SC_1]], %[[SC_1]] {
-  // CHECK-SAME:   sdy.propagation_edges = #sdy.propagation_edges<[{step-2 = [{"a" = operand-0 -> [result-0]}]}, {step-4 = [{"b" = result-0 -> [operand-0, operand-1]}]}]>,
-  // CHECK-SAME:   sdy.sharding = #sdy.sharding_per_value<[<@mesh, [{"a", ?}, {"b", ?}]>]>} : tensor<8x8xf32>
-  // CHECK-NEXT: %[[SC_2:.*]] = sdy.sharding_constraint %[[ADD]] <@mesh, [{"a", ?}, {"b"}]> {
-  // CHECK-SAME:   sdy.propagation_edges = #sdy.propagation_edges<[{step-3 = [{"a" = operand-0 -> [result-0]}, {"b" = result-0 -> [operand-0]}]}]>} : tensor<8x8xf32>
-  // CHECK-NEXT: return %[[SC_2]]
-  %0 = sdy.sharding_constraint %arg0 <@mesh, [{"a"}, {?}]> : tensor<8x8xf32>
-  %1 = stablehlo.add %0, %0 : tensor<8x8xf32>
-  %2 = sdy.sharding_constraint %1 <@mesh, [{?}, {"b"}]> : tensor<8x8xf32>
-  return %2 : tensor<8x8xf32>
-}
-
-// -----
-
-sdy.mesh @mesh = <["a"=2, "b"=2, "c"=8]>
-
-// TODO(b/434949739): Describe how the propagation edge is created due to the
-// apply-sharding-constraints pass.
-// CHECK-LABEL: push_sharding_constraints_to_func_results
-// CHECK-SAME:   %arg0: tensor<8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{"a"}]>},
-// CHECK-SAME:   %arg1: tensor<8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{"a"}]>})
-// CHECK-SAME:   -> (tensor<8xf32> {sdy.propagation_edges = #sdy.propagation_edges<[{step-0 = [{"a" = operand-0 -> [result-0]}]}, {step-1 = [{"a" = operand-0 -> [result-0]}]}]>,
-// CHECK-SAME:                      sdy.sharding = #sdy.sharding<@mesh, [{"a", ?}]>},
-// CHECK-SAME:       tensor<8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{"a", ?}]>}) {
-func.func @push_sharding_constraints_to_func_results(
-  %arg0: tensor<8xf32>, %arg1: tensor<8xf32>
-  ) -> (tensor<8xf32>, tensor<8xf32>) {
-  %1 = sdy.sharding_constraint %arg0 <@mesh, [{"a"}]> : tensor<8xf32>
-  %2 = sdy.sharding_constraint %arg1 <@mesh, [{"a"}]> : tensor<8xf32>
-  return %1, %2 : tensor<8xf32>, tensor<8xf32>
-}
diff --git a/shardy/dialect/sdy/transforms/propagation/test/aggressive_propagation.mlir b/shardy/dialect/sdy/transforms/propagation/test/aggressive_propagation.mlir
index e6a3355..7da88e2 100644
--- a/shardy/dialect/sdy/transforms/propagation/test/aggressive_propagation.mlir
+++ b/shardy/dialect/sdy/transforms/propagation/test/aggressive_propagation.mlir
@@ -167,11 +167,11 @@ func.func @multiple_conflicts_across_factors(
 
 // CHECK-LABEL: func @sideways_propagation_if_result_is_closed_empty(
 // CHECK-SAME:      %arg0: tensor<8xf32> {sdy.sharding = #sdy.sharding<@mesh_a_2_b_2, [{"a"}]>},
-// CHECK-SAME:      %arg1: tensor<8xf32>
-// CHECK-SAME:  ) -> tensor<8xf32>
+// CHECK-SAME:      %arg1: tensor<8xf32> {sdy.sharding = #sdy.sharding<@mesh_a_2_b_2, [{"a", ?}]>})
+// CHECK-SAME:  -> tensor<8xf32>
 func.func @sideways_propagation_if_result_is_closed_empty(
     %arg0: tensor<8xf32> {sdy.sharding = #sdy.sharding<@mesh_a_2_b_2, [{"a"}]>},
-    %arg1: tensor<8xf32>)
+    %arg1: tensor<8xf32> {sdy.sharding = #sdy.sharding<@mesh_a_2_b_2, [{?}]>})
     -> tensor<8xf32> {
   // CHECK-NEXT: stablehlo.add %arg0, %arg1 {sdy.sharding = #sdy.sharding_per_value<[<@mesh_a_2_b_2, [{}]>]>}
   %0 = stablehlo.add %arg0, %arg1 {sdy.sharding = #sdy.sharding_per_value<[<@mesh_a_2_b_2, [{}]>]>} : tensor<8xf32>
@@ -193,7 +193,7 @@ func.func @allow_sideways_propagation_if_result_is_open_empty(
 
 // CHECK-LABEL: func @sideways_propagation_if_result_is_closed_sub_axis(
 // CHECK-SAME:      %arg0: tensor<8xf32> {sdy.sharding = #sdy.sharding<@mesh_a_4, [{"a"}]>},
-// CHECK-SAME:      %arg1: tensor<8xf32> {sdy.sharding = #sdy.sharding<@mesh_a_4, [{"a":(1)2, ?}]>})
+// CHECK-SAME:      %arg1: tensor<8xf32> {sdy.sharding = #sdy.sharding<@mesh_a_4, [{"a", ?}]>})
 // CHECK-SAME:  -> (tensor<8xf32> {sdy.sharding = #sdy.sharding<@mesh_a_4, [{"a":(1)2, ?}]>})
 func.func @sideways_propagation_if_result_is_closed_sub_axis(
     %arg0: tensor<8xf32> {sdy.sharding = #sdy.sharding<@mesh_a_4, [{"a"}]>},
@@ -206,7 +206,7 @@ func.func @sideways_propagation_if_result_is_closed_sub_axis(
 
 // CHECK-LABEL: func @allow_partial_sideways_propagation_if_conflicting_with_result(
 // CHECK-SAME:      %arg0: tensor<8xf32> {sdy.sharding = #sdy.sharding<@mesh_a_2_b_2, [{"a", "b"}]>},
-// CHECK-SAME:      %arg1: tensor<8xf32> {sdy.sharding = #sdy.sharding<@mesh_a_2_b_2, [{"a", ?}]>})
+// CHECK-SAME:      %arg1: tensor<8xf32> {sdy.sharding = #sdy.sharding<@mesh_a_2_b_2, [{"a", "b", ?}]>})
 // CHECK-SAME:  -> (tensor<8xf32> {sdy.sharding = #sdy.sharding<@mesh_a_2_b_2, [{"a", ?}]>})
 func.func @allow_partial_sideways_propagation_if_conflicting_with_result(
     %arg0: tensor<8xf32> {sdy.sharding = #sdy.sharding<@mesh_a_2_b_2, [{"a", "b"}]>},
diff --git a/shardy/dialect/sdy/transforms/propagation/test/user_priority_propagation.mlir b/shardy/dialect/sdy/transforms/propagation/test/user_priority_propagation.mlir
index 5558e19..2d97877 100644
--- a/shardy/dialect/sdy/transforms/propagation/test/user_priority_propagation.mlir
+++ b/shardy/dialect/sdy/transforms/propagation/test/user_priority_propagation.mlir
@@ -53,7 +53,7 @@ func.func @arg_lower_priority_than_return_value(
 // CHECK-SAME:      %arg0: tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{"a"}, {"b"}]>},
 // CHECK-SAME:      %arg1: tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{"c", ?}, {"b", ?}]>},
 // CHECK-SAME:      %arg2: tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{"c", ?}, {"b", ?}]>},
-// CHECK-SAME:      %arg3: tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{"c", ?}, {?}]>})
+// CHECK-SAME:      %arg3: tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{"c", ?}, {"b", ?}]>})
 // CHECK-SAME:  -> (tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{"c", ?}, {?}]>}) {
 func.func @arg_lower_priority_than_return_value_with_replicated(
       %arg0: tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{"a"}p1, {"b"}p1]>},
@@ -72,7 +72,7 @@ func.func @arg_lower_priority_than_return_value_with_replicated(
 // CHECK-SAME:      %arg0: tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{"a", ?}, {"b", ?}]>},
 // CHECK-SAME:      %arg1: tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{"a"}, {"b"}]>},
 // CHECK-SAME:      %arg2: tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{"a", ?}, {"b", ?}]>},
-// CHECK-SAME:      %arg3: tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{?}, {"b", ?}]>})
+// CHECK-SAME:      %arg3: tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{"a", ?}, {"b", ?}]>})
 // CHECK-SAME:  -> (tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{"c", ?}, {"b", ?}]>}) {
 func.func @arg_higher_priority_than_return_value(
       %arg0: tensor<8x8xf32>, %arg1: tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{"a"}p0, {"b"}p0]>},
@@ -146,7 +146,7 @@ func.func @dim_with_lower_priority_gets_further_sharded_by_higher(
 // CHECK-LABEL: func @different_priorities_with_closed_empty_dim(
 // CHECK-SAME:      %arg0: tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{"a"}, {"b"}]>},
 // CHECK-SAME:      %arg1: tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{"a", ?}, {"b", ?}]>},
-// CHECK-SAME:      %arg2: tensor<8x8xf32>,
+// CHECK-SAME:      %arg2: tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{"a", ?}, {"b", ?}]>},
 // CHECK-SAME:      %arg3: tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{"c", ?}, {?}]>})
 // CHECK-SAME:  -> (tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{"c", ?}, {?}]>}) {
 func.func @different_priorities_with_closed_empty_dim(
diff --git a/third_party/llvm/generated.patch b/third_party/llvm/generated.patch
index 843d79d..a4953c3 100644
--- a/third_party/llvm/generated.patch
+++ b/third_party/llvm/generated.patch
@@ -1,59 +1,4 @@
 Auto generated patch. Do not edit or delete it, even if empty.
-diff -ruN --strip-trailing-cr a/clang/lib/Format/Format.cpp b/clang/lib/Format/Format.cpp
---- a/clang/lib/Format/Format.cpp
-+++ b/clang/lib/Format/Format.cpp
-@@ -2643,13 +2643,14 @@
-       for (FormatToken *Tok = Line->First; Tok && Tok->Next; Tok = Tok->Next) {
-         if (Tok->isNot(TT_PointerOrReference))
-           continue;
--        // Don't treat space in `void foo() &&` as evidence.
-+        // Don't treat space in `void foo() &&` or `void() &&` as evidence.
-         if (const auto *Prev = Tok->getPreviousNonComment()) {
-           if (Prev->is(tok::r_paren) && Prev->MatchingParen) {
-             if (const auto *Func =
-                     Prev->MatchingParen->getPreviousNonComment()) {
-               if (Func->isOneOf(TT_FunctionDeclarationName, TT_StartOfName,
--                                TT_OverloadedOperator)) {
-+                                TT_OverloadedOperator) ||
-+                  Func->isTypeName(LangOpts)) {
-                 continue;
-               }
-             }
-diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaDeclAttr.cpp b/clang/lib/Sema/SemaDeclAttr.cpp
---- a/clang/lib/Sema/SemaDeclAttr.cpp
-+++ b/clang/lib/Sema/SemaDeclAttr.cpp
-@@ -1970,6 +1970,13 @@
-   if (!FD)
-     return;
- 
-+  // Skip explicit specializations here as they may have
-+  // a user-provided definition that may deliberately differ from the primary
-+  // template. If an explicit specialization truly never returns, the user
-+  // should explicitly mark it with [[noreturn]].
-+  if (FD->getTemplateSpecializationKind() == TSK_ExplicitSpecialization)
-+    return;
-+
-   auto *NonConstFD = const_cast<FunctionDecl *>(FD);
-   DiagnosticsEngine &Diags = S.getDiagnostics();
-   if (Diags.isIgnored(diag::warn_falloff_nonvoid, FD->getLocation()) &&
-diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaDecl.cpp b/clang/lib/Sema/SemaDecl.cpp
---- a/clang/lib/Sema/SemaDecl.cpp
-+++ b/clang/lib/Sema/SemaDecl.cpp
-@@ -3267,6 +3267,14 @@
-     if (isa<UsedAttr>(I) || isa<RetainAttr>(I))
-       continue;
- 
-+    if (isa<InferredNoReturnAttr>(I)) {
-+      if (auto *FD = dyn_cast<FunctionDecl>(New)) {
-+        if (FD->getTemplateSpecializationKind() == TSK_ExplicitSpecialization)
-+          continue; // Don't propagate inferred noreturn attributes to explicit
-+                    // specializations.
-+      }
-+    }
-+
-     if (mergeDeclAttribute(*this, New, I, LocalAMK))
-       foundAny = true;
-   }
 diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaOverload.cpp b/clang/lib/Sema/SemaOverload.cpp
 --- a/clang/lib/Sema/SemaOverload.cpp
 +++ b/clang/lib/Sema/SemaOverload.cpp
@@ -68,30 +13,6 @@ diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaOverload.cpp b/clang/lib/Sema
          !isa<CXXConstructorDecl>(Candidate.Function);
  
      Candidate.ExplicitCallArguments = Args.size();
-diff -ruN --strip-trailing-cr a/clang/test/Driver/offload-target.c b/clang/test/Driver/offload-target.c
---- a/clang/test/Driver/offload-target.c
-+++ b/clang/test/Driver/offload-target.c
-@@ -10,7 +10,7 @@
- // RUN: | FileCheck %s -check-prefix=CUDA
- // CUDA: "nvptx64-nvidia-cuda" - "clang", inputs: ["[[INPUT:.+]]"], output: "[[NV_OBJ:.+]]"
- 
--// RUN: %clang -### --offload-targets=amdgcn-amd-amdhsa,nvptx64-nvidia-cuda -fopenmp \
-+// RUN: %clang -### --offload-targets=amdgcn-amd-amdhsa,nvptx64-nvidia-cuda -fopenmp=libomp \
- // RUN:   -Xarch_amdgcn --offload-arch=gfx90a -Xarch_nvptx64 --offload-arch=sm_89 \
- // RUN:   -nogpulib -nogpuinc %s -ccc-print-bindings 2>&1 \
- // RUN: | FileCheck %s -check-prefix=OPENMP
-diff -ruN --strip-trailing-cr a/clang/test/Interpreter/pretty-print.c b/clang/test/Interpreter/pretty-print.c
---- a/clang/test/Interpreter/pretty-print.c
-+++ b/clang/test/Interpreter/pretty-print.c
-@@ -3,7 +3,7 @@
- // RUN: cat %s | clang-repl -Xcc -xc  | FileCheck %s
- // RUN: cat %s | clang-repl -Xcc -std=c++11 | FileCheck %s
- 
--// UNSUPPORTED: hwasan
-+// UNSUPPORTED: hwasan, msan
- 
- 
- char c = 'a'; c
 diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/cxx2b-deducing-this.cpp b/clang/test/SemaCXX/cxx2b-deducing-this.cpp
 --- a/clang/test/SemaCXX/cxx2b-deducing-this.cpp
 +++ b/clang/test/SemaCXX/cxx2b-deducing-this.cpp
@@ -131,1712 +52,3 @@ diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/cxx2b-deducing-this.cpp b/cla
 +}
 +
 +}
-diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/wreturn-always-throws.cpp b/clang/test/SemaCXX/wreturn-always-throws.cpp
---- a/clang/test/SemaCXX/wreturn-always-throws.cpp
-+++ b/clang/test/SemaCXX/wreturn-always-throws.cpp
-@@ -1,4 +1,4 @@
--// RUN: %clang_cc1 -fsyntax-only -fcxx-exceptions -fexceptions -Wreturn-type -verify %s
-+// RUN: %clang_cc1 -fsyntax-only -fcxx-exceptions -fexceptions -Wreturn-type -Winvalid-noreturn -verify %s
- // expected-no-diagnostics
- 
- namespace std {
-@@ -44,3 +44,22 @@
-   throwErrorTemplate("ERROR");
-   (void)ensureZeroTemplate(42);
- }
-+
-+// Ensure that explicit specialization of a member function does not inherit
-+// the warning from the primary template.
-+
-+template<typename T>
-+struct S {
-+  void f();
-+  void g();
-+};
-+
-+template<typename T>
-+void S<T>::f() { throw 0; } 
-+template<>
-+void S<int>::f() {}
-+
-+template<typename T> 
-+void S<T>::g() {}  
-+template<> 
-+void S<int>::g() { throw 0; }
-diff -ruN --strip-trailing-cr a/clang/unittests/Format/FormatTest.cpp b/clang/unittests/Format/FormatTest.cpp
---- a/clang/unittests/Format/FormatTest.cpp
-+++ b/clang/unittests/Format/FormatTest.cpp
-@@ -12103,6 +12103,8 @@
-   Prefix = "void a() const &;\n"
-            "void b() const &;\n";
-   verifyFormat(Prefix + "int *x;", Prefix + "int* x;", DerivePointerAlignment);
-+
-+  verifyGoogleFormat("MACRO(int*, std::function<void() &&>);");
- }
- 
- TEST_F(FormatTest, PointerAlignmentFallback) {
-diff -ruN --strip-trailing-cr a/clang-tools-extra/clangd/refactor/tweaks/CMakeLists.txt b/clang-tools-extra/clangd/refactor/tweaks/CMakeLists.txt
---- a/clang-tools-extra/clangd/refactor/tweaks/CMakeLists.txt
-+++ b/clang-tools-extra/clangd/refactor/tweaks/CMakeLists.txt
-@@ -14,9 +14,9 @@
- add_clang_library(clangDaemonTweaks OBJECT
-   AddUsing.cpp
-   AnnotateHighlightings.cpp
-+  DumpAST.cpp
-   DefineInline.cpp
-   DefineOutline.cpp
--  DumpAST.cpp
-   ExpandDeducedType.cpp
-   ExpandMacro.cpp
-   ExtractFunction.cpp
-@@ -24,7 +24,6 @@
-   MemberwiseConstructor.cpp
-   ObjCLocalizeStringLiteral.cpp
-   ObjCMemberwiseInitializer.cpp
--  OverridePureVirtuals.cpp
-   PopulateSwitch.cpp
-   RawStringLiteral.cpp
-   RemoveUsingNamespace.cpp
-diff -ruN --strip-trailing-cr a/clang-tools-extra/clangd/refactor/tweaks/OverridePureVirtuals.cpp b/clang-tools-extra/clangd/refactor/tweaks/OverridePureVirtuals.cpp
---- a/clang-tools-extra/clangd/refactor/tweaks/OverridePureVirtuals.cpp
-+++ b/clang-tools-extra/clangd/refactor/tweaks/OverridePureVirtuals.cpp
-@@ -1,374 +0,0 @@
--//===--- OverridePureVirtuals.cpp --------------------------------*- C++-*-===//
--//
--// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
--// See https://llvm.org/LICENSE.txt for license information.
--// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
--//
--//===----------------------------------------------------------------------===//
--//
--// Tweak to automatically generate stubs for pure virtual methods inherited from
--// base classes.
--//
--// Purpose:
--//   - Simplifies making a derived class concrete by automating the creation of
--//     required method overrides from abstract bases.
--//
--// Tweak Summary:
--//
--// 1. Activation Conditions (prepare):
--//    - The tweak activates when the cursor is over a C++ class definition.
--//    - The class must be abstract (it, or its base classes, have unimplemented
--//      pure virtual functions).
--//    - It must also inherit from at least one other abstract class.
--//
--// 2. Identifying Missing Methods:
--//    - The tweak scans the inheritance hierarchy of the current class.
--//    - It identifies all unique pure virtual methods from base classes
--//      that are not yet implemented or overridden.
--//    - These missing methods are then grouped by their original access
--//      specifier (e.g., public, protected).
--//
--// 3. Code Generation and Insertion:
--//    - For each group of missing methods, stubs are inserted.
--//    - If an access specifier section (like `public:`) exists, stubs are
--//      inserted there; otherwise, a new section is created and appended.
--//    - Each generated stub includes the `override` keyword, a `// TODO:`
--//      comment, and a `static_assert(false, ...)` to force a compile-time
--//      error if the method remains unimplemented.
--//    - The base method's signature is adjusted (e.g., `virtual` and `= 0`
--//      are removed for the override).
--//
--// 4. Code Action Provided:
--//    - A single code action titled "Override pure virtual methods" is offered.
--//    - Applying this action results in a single source file modification
--//      containing all the generated method stubs.
--//
--// Example:
--//
--//  class Base {
--//  public:
--//    virtual void publicMethod() = 0;
--//  protected:
--//    virtual auto privateMethod() const -> int = 0;
--//  };
--//
--// Before:
--//                              // cursor here
--//  class Derived : public Base {}^;
--//
--// After:
--//
--// class Derived : public Base {
--//  public:
--//   void publicMethod() override {
--//     // TODO: Implement this pure virtual method.
--//     static_assert(false, "Method `publicMethod` is not implemented.");
--//   }
--//
--//  protected:
--//   auto privateMethod() const -> int override {
--//     // TODO: Implement this pure virtual method.
--//     static_assert(false, "Method `privateMethod` is not implemented.");
--//   }
--// };
--//
--//===----------------------------------------------------------------------===//
--
--#include "refactor/Tweak.h"
--#include "support/Token.h"
--
--#include "clang/AST/ASTContext.h"
--#include "clang/AST/DeclCXX.h"
--#include "clang/AST/Type.h"
--#include "clang/AST/TypeLoc.h"
--#include "clang/Basic/LLVM.h"
--#include "clang/Basic/SourceLocation.h"
--#include "clang/Tooling/Core/Replacement.h"
--#include "llvm/ADT/DenseSet.h"
--#include "llvm/Support/FormatVariadic.h"
--#include <string>
--
--namespace clang {
--namespace clangd {
--namespace {
--
--// This function removes the "virtual" and the "= 0" at the end;
--// e.g.:
--//   "virtual void foo(int var = 0) = 0"  // input.
--//   "void foo(int var = 0)"              // output.
--std::string removePureVirtualSyntax(const std::string &MethodDecl,
--                                    const LangOptions &LangOpts) {
--  assert(!MethodDecl.empty());
--
--  TokenStream TS = lex(MethodDecl, LangOpts);
--
--  std::string DeclString;
--  for (const clangd::Token &Tk : TS.tokens()) {
--    if (Tk.Kind == clang::tok::raw_identifier && Tk.text() == "virtual")
--      continue;
--
--    // If the ending two tokens are "= 0", we break here and we already have the
--    // method's string without the pure virtual syntax.
--    const auto &Next = Tk.next();
--    if (Next.next().Kind == tok::eof && Tk.Kind == clang::tok::equal &&
--        Next.text() == "0")
--      break;
--
--    DeclString += Tk.text();
--    if (Tk.Kind != tok::l_paren && Next.Kind != tok::comma &&
--        Next.Kind != tok::r_paren && Next.Kind != tok::l_paren)
--      DeclString += ' ';
--  }
--  // Trim the last whitespace.
--  if (DeclString.back() == ' ')
--    DeclString.pop_back();
--
--  return DeclString;
--}
--
--class OverridePureVirtuals final : public Tweak {
--public:
--  const char *id() const final; // defined by REGISTER_TWEAK.
--  bool prepare(const Selection &Sel) override;
--  Expected<Effect> apply(const Selection &Sel) override;
--  std::string title() const override { return "Override pure virtual methods"; }
--  llvm::StringLiteral kind() const override {
--    return CodeAction::QUICKFIX_KIND;
--  }
--
--private:
--  // Stores the CXXRecordDecl of the class being modified.
--  const CXXRecordDecl *CurrentDeclDef = nullptr;
--  // Stores pure virtual methods that need overriding, grouped by their original
--  // access specifier.
--  llvm::MapVector<AccessSpecifier, llvm::SmallVector<const CXXMethodDecl *>>
--      MissingMethodsByAccess;
--  // Stores the source locations of existing access specifiers in CurrentDecl.
--  llvm::MapVector<AccessSpecifier, SourceLocation> AccessSpecifierLocations;
--  // Helper function to gather information before applying the tweak.
--  void collectMissingPureVirtuals();
--};
--
--REGISTER_TWEAK(OverridePureVirtuals)
--
--// Function to get all unique pure virtual methods from the entire
--// base class hierarchy of CurrentDeclDef.
--llvm::SmallVector<const clang::CXXMethodDecl *>
--getAllUniquePureVirtualsFromBaseHierarchy(
--    const clang::CXXRecordDecl *CurrentDeclDef) {
--  llvm::SmallVector<const clang::CXXMethodDecl *> AllPureVirtualsInHierarchy;
--  llvm::DenseSet<const clang::CXXMethodDecl *> CanonicalPureVirtualsSeen;
--
--  if (!CurrentDeclDef || !CurrentDeclDef->getDefinition())
--    return AllPureVirtualsInHierarchy;
--
--  const clang::CXXRecordDecl *Def = CurrentDeclDef->getDefinition();
--
--  Def->forallBases([&](const clang::CXXRecordDecl *BaseDefinition) {
--    for (const clang::CXXMethodDecl *Method : BaseDefinition->methods()) {
--      if (Method->isPureVirtual() &&
--          CanonicalPureVirtualsSeen.insert(Method->getCanonicalDecl()).second)
--        AllPureVirtualsInHierarchy.emplace_back(Method);
--    }
--    // Continue iterating through all bases.
--    return true;
--  });
--
--  return AllPureVirtualsInHierarchy;
--}
--
--// Gets canonical declarations of methods already overridden or implemented in
--// class D.
--llvm::SetVector<const CXXMethodDecl *>
--getImplementedOrOverriddenCanonicals(const CXXRecordDecl *D) {
--  llvm::SetVector<const CXXMethodDecl *> ImplementedSet;
--  for (const CXXMethodDecl *M : D->methods()) {
--    // If M provides an implementation for any virtual method it overrides.
--    // A method is an "implementation" if it's virtual and not pure.
--    // Or if it directly overrides a base method.
--    for (const CXXMethodDecl *OverriddenM : M->overridden_methods())
--      ImplementedSet.insert(OverriddenM->getCanonicalDecl());
--  }
--  return ImplementedSet;
--}
--
--// Get the location of every colon of the `AccessSpecifier`.
--llvm::MapVector<AccessSpecifier, SourceLocation>
--getSpecifierLocations(const CXXRecordDecl *D) {
--  llvm::MapVector<AccessSpecifier, SourceLocation> Locs;
--  for (auto *DeclNode : D->decls()) {
--    if (const auto *ASD = llvm::dyn_cast<AccessSpecDecl>(DeclNode))
--      Locs[ASD->getAccess()] = ASD->getColonLoc();
--  }
--  return Locs;
--}
--
--bool hasAbstractBaseAncestor(const clang::CXXRecordDecl *CurrentDecl) {
--  assert(CurrentDecl && CurrentDecl->getDefinition());
--
--  return llvm::any_of(
--      CurrentDecl->getDefinition()->bases(), [](CXXBaseSpecifier BaseSpec) {
--        const auto *D = BaseSpec.getType()->getAsCXXRecordDecl();
--        const auto *Def = D ? D->getDefinition() : nullptr;
--        return Def && Def->isAbstract();
--      });
--}
--
--// The tweak is available if the selection is over an abstract C++ class
--// definition that also inherits from at least one other abstract class.
--bool OverridePureVirtuals::prepare(const Selection &Sel) {
--  const SelectionTree::Node *Node = Sel.ASTSelection.commonAncestor();
--  if (!Node)
--    return false;
--
--  // Make sure we have a definition.
--  CurrentDeclDef = Node->ASTNode.get<CXXRecordDecl>();
--  if (!CurrentDeclDef || !CurrentDeclDef->getDefinition())
--    return false;
--
--  // From now on, we should work with the definition.
--  CurrentDeclDef = CurrentDeclDef->getDefinition();
--
--  // Only offer for abstract classes with abstract bases.
--  return CurrentDeclDef->isAbstract() &&
--         hasAbstractBaseAncestor(CurrentDeclDef);
--}
--
--// Collects all pure virtual methods from base classes that `CurrentDeclDef` has
--// not yet overridden, grouped by their original access specifier.
--//
--// Results are stored in `MissingMethodsByAccess` and `AccessSpecifierLocations`
--// is also populated.
--void OverridePureVirtuals::collectMissingPureVirtuals() {
--  if (!CurrentDeclDef)
--    return;
--
--  AccessSpecifierLocations = getSpecifierLocations(CurrentDeclDef);
--  MissingMethodsByAccess.clear();
--
--  // Get all unique pure virtual methods from the entire base class hierarchy.
--  llvm::SmallVector<const CXXMethodDecl *> AllPureVirtualsInHierarchy =
--      getAllUniquePureVirtualsFromBaseHierarchy(CurrentDeclDef);
--
--  // Get methods already implemented or overridden in CurrentDecl.
--  const auto ImplementedOrOverriddenSet =
--      getImplementedOrOverriddenCanonicals(CurrentDeclDef);
--
--  // Filter AllPureVirtualsInHierarchy to find those not in
--  // ImplementedOrOverriddenSet, which needs to be overriden.
--  for (const CXXMethodDecl *BaseMethod : AllPureVirtualsInHierarchy) {
--    bool AlreadyHandled = ImplementedOrOverriddenSet.contains(BaseMethod);
--    if (!AlreadyHandled)
--      MissingMethodsByAccess[BaseMethod->getAccess()].emplace_back(BaseMethod);
--  }
--}
--
--std::string generateOverrideString(const CXXMethodDecl *Method,
--                                   const LangOptions &LangOpts) {
--  std::string MethodDecl;
--  auto OS = llvm::raw_string_ostream(MethodDecl);
--  Method->print(OS);
--
--  return llvm::formatv(
--             "\n  {0} override {{\n"
--             "    // TODO: Implement this pure virtual method.\n"
--             "    static_assert(false, \"Method `{1}` is not implemented.\");\n"
--             "  }",
--             removePureVirtualSyntax(MethodDecl, LangOpts), Method->getName())
--      .str();
--}
--
--// Free function to generate the string for a group of method overrides.
--std::string generateOverridesStringForGroup(
--    llvm::SmallVector<const CXXMethodDecl *> Methods,
--    const LangOptions &LangOpts) {
--  llvm::SmallVector<std::string> MethodsString;
--  MethodsString.reserve(Methods.size());
--
--  for (const CXXMethodDecl *Method : Methods) {
--    MethodsString.emplace_back(generateOverrideString(Method, LangOpts));
--  }
--
--  return llvm::join(MethodsString, "\n") + '\n';
--}
--
--Expected<Tweak::Effect> OverridePureVirtuals::apply(const Selection &Sel) {
--  // The correctness of this tweak heavily relies on the accurate population of
--  // these members.
--  collectMissingPureVirtuals();
--  // The `prepare` should prevent this. If the prepare identifies an abstract
--  // method, then is must have missing methods.
--  assert(!MissingMethodsByAccess.empty());
--
--  const auto &SM = Sel.AST->getSourceManager();
--  const auto &LangOpts = Sel.AST->getLangOpts();
--
--  tooling::Replacements EditReplacements;
--  // Stores text for new access specifier sections that are not already present
--  // in the class.
--  // Example:
--  //  public:    // ...
--  //  protected: // ...
--  std::string NewSectionsToAppendText;
--
--  for (const auto &[AS, Methods] : MissingMethodsByAccess) {
--    assert(!Methods.empty());
--
--    std::string MethodsGroupString =
--        generateOverridesStringForGroup(Methods, LangOpts);
--
--    auto *ExistingSpecLocIter = AccessSpecifierLocations.find(AS);
--    bool ASExists = ExistingSpecLocIter != AccessSpecifierLocations.end();
--    if (ASExists) {
--      // Access specifier section already exists in the class.
--      // Get location immediately *after* the colon.
--      SourceLocation InsertLoc =
--          ExistingSpecLocIter->second.getLocWithOffset(1);
--
--      // Create a replacement to insert the method declarations.
--      // The replacement is at InsertLoc, has length 0 (insertion), and uses
--      // InsertionText.
--      std::string InsertionText = MethodsGroupString;
--      tooling::Replacement Rep(SM, InsertLoc, 0, InsertionText);
--      if (auto Err = EditReplacements.add(Rep))
--        return llvm::Expected<Tweak::Effect>(std::move(Err));
--    } else {
--      // Access specifier section does not exist in the class.
--      // These methods will be grouped into NewSectionsToAppendText and added
--      // towards the end of the class definition.
--      NewSectionsToAppendText +=
--          getAccessSpelling(AS).str() + ':' + MethodsGroupString;
--    }
--  }
--
--  // After processing all access specifiers, add any newly created sections
--  // (stored in NewSectionsToAppendText) to the end of the class.
--  if (!NewSectionsToAppendText.empty()) {
--    // AppendLoc is the SourceLocation of the closing brace '}' of the class.
--    // The replacement will insert text *before* this closing brace.
--    SourceLocation AppendLoc = CurrentDeclDef->getBraceRange().getEnd();
--    std::string FinalAppendText = std::move(NewSectionsToAppendText);
--
--    if (!CurrentDeclDef->decls_empty() || !EditReplacements.empty()) {
--      FinalAppendText = '\n' + FinalAppendText;
--    }
--
--    // Create a replacement to append the new sections.
--    tooling::Replacement Rep(SM, AppendLoc, 0, FinalAppendText);
--    if (auto Err = EditReplacements.add(Rep))
--      return llvm::Expected<Tweak::Effect>(std::move(Err));
--  }
--
--  if (EditReplacements.empty()) {
--    return llvm::make_error<llvm::StringError>(
--        "No changes to apply (internal error or no methods generated).",
--        llvm::inconvertibleErrorCode());
--  }
--
--  // Return the collected replacements as the effect of this tweak.
--  return Effect::mainFileEdit(SM, EditReplacements);
--}
--
--} // namespace
--} // namespace clangd
--} // namespace clang
-diff -ruN --strip-trailing-cr a/clang-tools-extra/clangd/unittests/CMakeLists.txt b/clang-tools-extra/clangd/unittests/CMakeLists.txt
---- a/clang-tools-extra/clangd/unittests/CMakeLists.txt
-+++ b/clang-tools-extra/clangd/unittests/CMakeLists.txt
-@@ -131,7 +131,6 @@
-   tweaks/MemberwiseConstructorTests.cpp
-   tweaks/ObjCLocalizeStringLiteralTests.cpp
-   tweaks/ObjCMemberwiseInitializerTests.cpp
--  tweaks/OverridePureVirtualsTests.cpp
-   tweaks/PopulateSwitchTests.cpp
-   tweaks/RawStringLiteralTests.cpp
-   tweaks/RemoveUsingNamespaceTests.cpp
-diff -ruN --strip-trailing-cr a/clang-tools-extra/clangd/unittests/tweaks/OverridePureVirtualsTests.cpp b/clang-tools-extra/clangd/unittests/tweaks/OverridePureVirtualsTests.cpp
---- a/clang-tools-extra/clangd/unittests/tweaks/OverridePureVirtualsTests.cpp
-+++ b/clang-tools-extra/clangd/unittests/tweaks/OverridePureVirtualsTests.cpp
-@@ -1,720 +0,0 @@
--//===-- OverridePureVirtualsTests.cpp ---------------------------*- C++ -*-===//
--//
--// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
--// See https://llvm.org/LICENSE.txt for license information.
--// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
--//
--//===----------------------------------------------------------------------===//
--
--#include "TweakTesting.h"
--#include "gtest/gtest.h"
--
--namespace clang {
--namespace clangd {
--namespace {
--
--class OverridePureVirtualsTests : public TweakTest {
--protected:
--  OverridePureVirtualsTests() : TweakTest("OverridePureVirtuals") {}
--};
--
--TEST_F(OverridePureVirtualsTests, MinimalUnavailable) {
--  EXPECT_UNAVAILABLE("class ^C {};");
--}
--
--TEST_F(OverridePureVirtualsTests, MinimalAvailable) {
--  EXPECT_AVAILABLE(R"cpp(
--class B { public: virtual void Foo() = 0; };
--class ^C : public B {};
--)cpp");
--}
--
--TEST_F(OverridePureVirtualsTests, UnavailableWhenOverriden) {
--  EXPECT_UNAVAILABLE(
--      R"cpp(
--class B {
--public:
--  virtual void foo() = 0;
--};
--
--class ^D : public B {
--public:
--  void foo() override;
--};
--)cpp");
--}
--
--TEST_F(OverridePureVirtualsTests, AvailabilityNoOverride) {
--  EXPECT_AVAILABLE(R"cpp(
--class Base {
--public:
--virtual ~Base() = default;
--virtual void F1() = 0;
--virtual void F2() = 0;
--};
--
--class ^Derived : public Base {
--public:
--};
--
--)cpp");
--}
--
--TEST_F(OverridePureVirtualsTests, AvailabilityPartiallyOverridden) {
--  EXPECT_AVAILABLE(R"cpp(
--class Base {
--public:
--virtual ~Base() = default;
--virtual void F1() = 0;
--virtual void F2() = 0;
--};
--
--class ^Derived : public Base {
--public:
--void F1() override;
--};
--)cpp");
--}
--
--TEST_F(OverridePureVirtualsTests, EmptyDerivedClass) {
--  const char *Before = R"cpp(
--class Base {
--public:
--virtual ~Base() = default;
--virtual void F1() = 0;
--virtual void F2(int P1, const int &P2) = 0;
--};
--
--class ^Derived : public Base {};
--)cpp";
--  const auto *Expected = R"cpp(
--class Base {
--public:
--virtual ~Base() = default;
--virtual void F1() = 0;
--virtual void F2(int P1, const int &P2) = 0;
--};
--
--class Derived : public Base {
--public:
--  void F1() override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `F1` is not implemented.");
--  }
--
--  void F2(int P1, const int & P2) override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `F2` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, SingleBaseClassPartiallyImplemented) {
--  auto Applied = apply(
--      R"cpp(
--class Base {
--public:
--virtual ~Base() = default;
--virtual void F1() = 0;
--virtual void F2() = 0;
--};
--
--class ^Derived : public Base {
--public:
--  void F1() override;
--};
--)cpp");
--
--  const auto *Expected = R"cpp(
--class Base {
--public:
--virtual ~Base() = default;
--virtual void F1() = 0;
--virtual void F2() = 0;
--};
--
--class Derived : public Base {
--public:
--  void F2() override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `F2` is not implemented.");
--  }
--
--  void F1() override;
--};
--)cpp";
--  EXPECT_EQ(Applied, Expected) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, MultipleDirectBaseClasses) {
--  const char *Before = R"cpp(
--class Base1 {
--public:
--  virtual void func1() = 0;
--};
--class Base2 {
--protected:
--  virtual bool func2(char c) const = 0;
--};
--
--class ^Derived : public Base1, public Base2 {};
--)cpp";
--  const auto *Expected = R"cpp(
--class Base1 {
--public:
--  virtual void func1() = 0;
--};
--class Base2 {
--protected:
--  virtual bool func2(char c) const = 0;
--};
--
--class Derived : public Base1, public Base2 {
--public:
--  void func1() override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `func1` is not implemented.");
--  }
--protected:
--  bool func2(char c) const override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `func2` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, UnnamedParametersInBase) {
--  const char *Before = R"cpp(
--struct S {};
--class Base {
--public:
--  virtual void func(int, const S&, char*) = 0;
--};
--
--class ^Derived : public Base {};
--)cpp";
--
--  const auto *Expected = R"cpp(
--struct S {};
--class Base {
--public:
--  virtual void func(int, const S&, char*) = 0;
--};
--
--class Derived : public Base {
--public:
--  void func(int, const S &, char *) override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `func` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, DiamondInheritance) {
--  const char *Before = R"cpp(
--class Top {
--public:
--  virtual ~Top() = default;
--  virtual void diamond_func() = 0;
--};
--class Left : virtual public Top {};
--class Right : virtual public Top {};
--class ^Bottom : public Left, public Right {};
--)cpp";
--  const auto *Expected = R"cpp(
--class Top {
--public:
--  virtual ~Top() = default;
--  virtual void diamond_func() = 0;
--};
--class Left : virtual public Top {};
--class Right : virtual public Top {};
--class Bottom : public Left, public Right {
--public:
--  void diamond_func() override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `diamond_func` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, MixedAccessSpecifiers) {
--  const char *Before = R"cpp(
--class Base {
--public:
--  virtual void pub_func() = 0;
--  virtual void pub_func2(char) const = 0;
--protected:
--  virtual int prot_func(int x) const = 0;
--};
--
--class ^Derived : public Base {
--  int member; // Existing member
--public:
--  Derived(int m) : member(m) {}
--};
--)cpp";
--  const auto *Expected = R"cpp(
--class Base {
--public:
--  virtual void pub_func() = 0;
--  virtual void pub_func2(char) const = 0;
--protected:
--  virtual int prot_func(int x) const = 0;
--};
--
--class Derived : public Base {
--  int member; // Existing member
--public:
--  void pub_func() override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `pub_func` is not implemented.");
--  }
--
--  void pub_func2(char) const override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `pub_func2` is not implemented.");
--  }
--
--  Derived(int m) : member(m) {}
--
--protected:
--  int prot_func(int x) const override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `prot_func` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, OutOfOrderMixedAccessSpecifiers) {
--  const char *Before = R"cpp(
--class Base {
--public:
--  virtual void pub_func() = 0;
--  virtual void pub_func2(char) const = 0;
--protected:
--  virtual int prot_func(int x) const = 0;
--};
--
--class ^Derived : public Base {
--  int member; // Existing member
--protected:
--  void foo();
--public:
--  Derived(int m) : member(m) {}
--};
--)cpp";
--  const auto *Expected = R"cpp(
--class Base {
--public:
--  virtual void pub_func() = 0;
--  virtual void pub_func2(char) const = 0;
--protected:
--  virtual int prot_func(int x) const = 0;
--};
--
--class Derived : public Base {
--  int member; // Existing member
--protected:
--  int prot_func(int x) const override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `prot_func` is not implemented.");
--  }
--
--  void foo();
--public:
--  void pub_func() override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `pub_func` is not implemented.");
--  }
--
--  void pub_func2(char) const override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `pub_func2` is not implemented.");
--  }
--
--  Derived(int m) : member(m) {}
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, MultiAccessSpecifiersOverride) {
--  constexpr auto Before = R"cpp(
--class Base {
--public:
--  virtual void foo() = 0;
--protected:
--  virtual void bar() = 0;
--};
--
--class ^Derived : public Base {};
--)cpp";
--
--  constexpr auto Expected = R"cpp(
--class Base {
--public:
--  virtual void foo() = 0;
--protected:
--  virtual void bar() = 0;
--};
--
--class Derived : public Base {
--public:
--  void foo() override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `foo` is not implemented.");
--  }
--protected:
--  void bar() override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `bar` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, AccessSpecifierAlreadyExisting) {
--  const char *Before = R"cpp(
--class Base {
--public:
--  virtual void func1() = 0;
--};
--
--class ^Derived : public Base {
--public:
--};
--)cpp";
--
--  const auto *Expected = R"cpp(
--class Base {
--public:
--  virtual void func1() = 0;
--};
--
--class Derived : public Base {
--public:
--  void func1() override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `func1` is not implemented.");
--  }
--
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, ConstexprSpecifier) {
--  ExtraArgs.push_back("-std=c++20");
--
--  constexpr auto Before = R"cpp(
--class B {
--public:
--  constexpr virtual int getValue() const = 0;
--};
--
--class ^D : public B {};
--)cpp";
--
--  constexpr auto Expected = R"cpp(
--class B {
--public:
--  constexpr virtual int getValue() const = 0;
--};
--
--class D : public B {
--public:
--  constexpr int getValue() const override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `getValue` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, ConstevalSpecifier) {
--  ExtraArgs.push_back("-std=c++20");
--
--  constexpr auto Before = R"cpp(
--class B {
--public:
--  virtual consteval float calculate() = 0;
--};
--
--class ^D : public B {};
--)cpp";
--
--  constexpr auto Expected = R"cpp(
--class B {
--public:
--  virtual consteval float calculate() = 0;
--};
--
--class D : public B {
--public:
--  consteval float calculate() override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `calculate` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, LValueRefQualifier) {
--  constexpr auto Before = R"cpp(
--class B {
--public:
--  virtual void process() & = 0;
--};
--
--class ^D : public B {};
--)cpp";
--
--  constexpr auto Expected = R"cpp(
--class B {
--public:
--  virtual void process() & = 0;
--};
--
--class D : public B {
--public:
--  void process() & override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `process` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, RValueRefQualifier) {
--  constexpr auto Before = R"cpp(
--class B {
--public:
--  virtual bool isValid() && = 0;
--};
--
--class ^D : public B {};
--)cpp";
--
--  constexpr auto Expected = R"cpp(
--class B {
--public:
--  virtual bool isValid() && = 0;
--};
--
--class D : public B {
--public:
--  bool isValid() && override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `isValid` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, SimpleTrailingReturnType) {
--  constexpr auto Before = R"cpp(
--class B {
--public:
--  virtual auto getStatus() -> bool = 0;
--};
--
--class ^D : public B {};
--)cpp";
--
--  constexpr auto Expected = R"cpp(
--class B {
--public:
--  virtual auto getStatus() -> bool = 0;
--};
--
--class D : public B {
--public:
--  auto getStatus() -> bool override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `getStatus` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, ConstexprLValueRefAndTrailingReturn) {
--  ExtraArgs.push_back("-std=c++20");
--
--  constexpr auto Before = R"cpp(
--class B {
--public:
--  constexpr virtual auto getData() & -> const char * = 0;
--};
--
--class ^D : public B {};
--)cpp";
--
--  constexpr auto Expected = R"cpp(
--class B {
--public:
--  constexpr virtual auto getData() & -> const char * = 0;
--};
--
--class D : public B {
--public:
--  constexpr auto getData() & -> const char * override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `getData` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, ConstevalRValueRefAndTrailingReturn) {
--  ExtraArgs.push_back("-std=c++20");
--
--  constexpr auto Before = R"cpp(
--class B {
--public:
--  virtual consteval auto foo() && -> double = 0;
--};
--
--class ^D : public B {};
--)cpp";
--
--  constexpr auto Expected = R"cpp(
--class B {
--public:
--  virtual consteval auto foo() && -> double = 0;
--};
--
--class D : public B {
--public:
--  consteval auto foo() && -> double override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `foo` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, CombinedFeaturesWithTrailingReturnTypes) {
--  ExtraArgs.push_back("-std=c++20");
--
--  constexpr auto Before = R"cpp(
--class B {
--public:
--  virtual auto f1() & -> int = 0;
--  constexpr virtual auto f2() && -> int = 0;
--  virtual consteval auto f3() -> int = 0;
--  virtual auto f4() const & -> char = 0;
--  constexpr virtual auto f5() const && -> bool = 0;
--};
--
--class ^D : public B {};
--)cpp";
--
--  constexpr auto Expected = R"cpp(
--class B {
--public:
--  virtual auto f1() & -> int = 0;
--  constexpr virtual auto f2() && -> int = 0;
--  virtual consteval auto f3() -> int = 0;
--  virtual auto f4() const & -> char = 0;
--  constexpr virtual auto f5() const && -> bool = 0;
--};
--
--class D : public B {
--public:
--  auto f1() & -> int override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `f1` is not implemented.");
--  }
--
--  constexpr auto f2() && -> int override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `f2` is not implemented.");
--  }
--
--  consteval auto f3() -> int override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `f3` is not implemented.");
--  }
--
--  auto f4() const & -> char override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `f4` is not implemented.");
--  }
--
--  constexpr auto f5() const && -> bool override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `f5` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, DefaultParameters) {
--  ExtraArgs.push_back("-std=c++20");
--
--  constexpr auto Before = R"cpp(
--class B {
--public:
--  virtual void foo(int var = 0) = 0;
--};
--
--class ^D : public B {};
--)cpp";
--
--  constexpr auto Expected = R"cpp(
--class B {
--public:
--  virtual void foo(int var = 0) = 0;
--};
--
--class D : public B {
--public:
--  void foo(int var = 0) override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `foo` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--} // namespace
--} // namespace clangd
--} // namespace clang
-diff -ruN --strip-trailing-cr a/libc/src/__support/FPUtil/bfloat16.h b/libc/src/__support/FPUtil/bfloat16.h
---- a/libc/src/__support/FPUtil/bfloat16.h
-+++ b/libc/src/__support/FPUtil/bfloat16.h
-@@ -12,6 +12,7 @@
- #include "src/__support/CPP/bit.h"
- #include "src/__support/CPP/type_traits.h"
- #include "src/__support/FPUtil/cast.h"
-+#include "src/__support/FPUtil/comparison_operations.h"
- #include "src/__support/FPUtil/dyadic_float.h"
- #include "src/__support/macros/config.h"
- #include "src/__support/macros/properties/types.h"
-@@ -57,6 +58,30 @@
-     uint32_t x_bits = static_cast<uint32_t>(bits) << 16U;
-     return cpp::bit_cast<float>(x_bits);
-   }
-+
-+  LIBC_INLINE constexpr bool operator==(BFloat16 other) const {
-+    return fputil::equals(*this, other);
-+  }
-+
-+  LIBC_INLINE constexpr bool operator!=(BFloat16 other) const {
-+    return !fputil::equals(*this, other);
-+  }
-+
-+  LIBC_INLINE constexpr bool operator<(BFloat16 other) const {
-+    return fputil::less_than(*this, other);
-+  }
-+
-+  LIBC_INLINE constexpr bool operator<=(BFloat16 other) const {
-+    return fputil::less_than_or_equals(*this, other);
-+  }
-+
-+  LIBC_INLINE constexpr bool operator>(BFloat16 other) const {
-+    return fputil::greater_than(*this, other);
-+  }
-+
-+  LIBC_INLINE constexpr bool operator>=(BFloat16 other) const {
-+    return fputil::greater_than_or_equals(*this, other);
-+  }
- }; // struct BFloat16
- 
- } // namespace fputil
-diff -ruN --strip-trailing-cr a/libc/src/__support/FPUtil/CMakeLists.txt b/libc/src/__support/FPUtil/CMakeLists.txt
---- a/libc/src/__support/FPUtil/CMakeLists.txt
-+++ b/libc/src/__support/FPUtil/CMakeLists.txt
-@@ -274,6 +274,7 @@
-     bfloat16.h
-   DEPENDS
-     .cast
-+    .comparison_operations
-     .dyadic_float
-     libc.src.__support.CPP.bit
-     libc.src.__support.CPP.type_traits
-diff -ruN --strip-trailing-cr a/lldb/source/Plugins/ObjectFile/Minidump/MinidumpFileBuilder.cpp b/lldb/source/Plugins/ObjectFile/Minidump/MinidumpFileBuilder.cpp
---- a/lldb/source/Plugins/ObjectFile/Minidump/MinidumpFileBuilder.cpp
-+++ b/lldb/source/Plugins/ObjectFile/Minidump/MinidumpFileBuilder.cpp
-@@ -201,7 +201,7 @@
-     return error;
-   };
- 
--  llvm::minidump::SystemInfo sys_info;
-+  llvm::minidump::SystemInfo sys_info{};
-   sys_info.ProcessorArch =
-       static_cast<llvm::support::little_t<ProcessorArchitecture>>(arch);
-   // Global offset to beginning of a csd_string in a data section
-@@ -378,7 +378,7 @@
-     helper_data.AppendData(&signature, sizeof(llvm::support::ulittle32_t));
-     helper_data.AppendData(uuid.begin(), uuid.size());
- 
--    llvm::minidump::Module m;
-+    llvm::minidump::Module m{};
-     m.BaseOfImage = static_cast<llvm::support::ulittle64_t>(
-         mod->GetObjectFile()->GetBaseAddress().GetLoadAddress(&target));
-     m.SizeOfImage = static_cast<llvm::support::ulittle32_t>(mod_size);
-@@ -745,7 +745,7 @@
-   if (error.Fail())
-     return error;
- 
--  lldb_private::minidump::MinidumpMiscInfo misc_info;
-+  lldb_private::minidump::MinidumpMiscInfo misc_info{};
-   misc_info.size = static_cast<llvm::support::ulittle32_t>(
-       sizeof(lldb_private::minidump::MinidumpMiscInfo));
-   // Default set flags1 to 0, in case that we will not be able to
-diff -ruN --strip-trailing-cr a/llvm/test/CodeGen/NVPTX/pr126337.ll b/llvm/test/CodeGen/NVPTX/pr126337.ll
---- a/llvm/test/CodeGen/NVPTX/pr126337.ll
-+++ b/llvm/test/CodeGen/NVPTX/pr126337.ll
-@@ -1,6 +1,6 @@
- ; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
- ; RUN: llc < %s -mtriple=nvptx64 -mcpu=sm_70 | FileCheck %s
--; RUN: %if ptxas %{ llc < %s -mtriple=nvptx64 -mcpu=sm_70 | %ptxas-verify %}
-+; RUN: %if ptxas %{ llc < %s -mtriple=nvptx64 -mcpu=sm_70 | %ptxas -arch=sm_70 -c - %}
- 
- ; This IR should compile without triggering assertions in LICM
- ; when the CopyToReg from %0 in the first BB gets eliminated
-diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/libc/BUILD.bazel b/utils/bazel/llvm-project-overlay/libc/BUILD.bazel
---- a/utils/bazel/llvm-project-overlay/libc/BUILD.bazel
-+++ b/utils/bazel/llvm-project-overlay/libc/BUILD.bazel
-@@ -1002,6 +1002,19 @@
- )
- 
- libc_support_library(
-+    name = "__support_fputil_comparison_operations",
-+    hdrs = [
-+        "src/__support/FPUtil/comparison_operations.h",
-+    ],
-+    deps = [
-+        ":__support_cpp_type_traits",
-+        ":__support_fputil_fenv_impl",
-+        ":__support_fputil_fp_bits",
-+        ":__support_macros_config",
-+    ],
-+)
-+
-+libc_support_library(
-     name = "__support_file_file",
-     srcs = [
-         "include/llvm-libc-types/off_t.h",
-@@ -1085,6 +1098,7 @@
-         ":__support_cpp_bit",
-         ":__support_cpp_type_traits",
-         ":__support_fputil_cast",
-+        ":__support_fputil_comparison_operations",
-         ":__support_fputil_dyadic_float",
-         ":__support_macros_config",
-         ":__support_macros_properties_types",
-@@ -1159,6 +1173,7 @@
-     name = "__support_fputil_rounding_mode",
-     hdrs = ["src/__support/FPUtil/rounding_mode.h"],
-     deps = [
-+        ":__support_cpp_type_traits",
-         ":__support_macros_attributes",
-         ":__support_macros_config",
-         ":hdr_fenv_macros",
-@@ -1919,8 +1934,8 @@
-     srcs = ["src/math/generic/common_constants.cpp"],
-     hdrs = ["src/math/generic/common_constants.h"],
-     deps = [
--        ":__support_math_exp_constants",
-         ":__support_math_acosh_float_constants",
-+        ":__support_math_exp_constants",
-         ":__support_number_pair",
-     ],
- )
-@@ -2003,10 +2018,10 @@
-         ":__support_fputil_fma",
-         ":__support_fputil_multiply_add",
-         ":__support_fputil_nearest_integer",
--        ":__support_math_exp_utils",
--        ":__support_math_exp10f_utils",
--        ":__support_math_acoshf_utils",
-         ":__support_macros_properties_cpu_features",
-+        ":__support_math_acoshf_utils",
-+        ":__support_math_exp10f_utils",
-+        ":__support_math_exp_utils",
-         ":common_constants",
-     ],
- )
-@@ -2058,8 +2073,8 @@
-         ":__support_fputil_cast",
-         ":__support_fputil_fp_bits",
-         ":__support_fputil_nearest_integer",
--        ":__support_math_expf16_utils",
-         ":__support_math_exp10_float16_constants",
-+        ":__support_math_expf16_utils",
-     ],
- )
- 
-@@ -2067,7 +2082,6 @@
-     name = "__support_math_acos",
-     hdrs = ["src/__support/math/acos.h"],
-     deps = [
--        ":__support_math_asin_utils",
-         ":__support_fputil_double_double",
-         ":__support_fputil_dyadic_float",
-         ":__support_fputil_fenv_impl",
-@@ -2076,8 +2090,9 @@
-         ":__support_fputil_polyeval",
-         ":__support_fputil_sqrt",
-         ":__support_macros_optimization",
--        ":__support_macros_properties_types",
-         ":__support_macros_properties_cpu_features",
-+        ":__support_macros_properties_types",
-+        ":__support_math_asin_utils",
-     ],
- )
- 
-@@ -2085,13 +2100,13 @@
-     name = "__support_math_acosf",
-     hdrs = ["src/__support/math/acosf.h"],
-     deps = [
--        ":__support_math_inv_trigf_utils",
-         ":__support_fputil_except_value_utils",
-         ":__support_fputil_fp_bits",
-         ":__support_fputil_multiply_add",
-         ":__support_fputil_polyeval",
-         ":__support_fputil_sqrt",
-         ":__support_macros_optimization",
-+        ":__support_math_inv_trigf_utils",
-     ],
- )
- 
-@@ -2100,6 +2115,7 @@
-     hdrs = ["src/__support/math/acosf16.h"],
-     deps = [
-         ":__support_fputil_cast",
-+        ":__support_fputil_except_value_utils",
-         ":__support_fputil_fma",
-         ":__support_fputil_multiply_add",
-         ":__support_fputil_nearest_integer",
-@@ -2121,10 +2137,10 @@
-     name = "__support_math_acoshf_utils",
-     hdrs = ["src/__support/math/acoshf_utils.h"],
-     deps = [
--        ":__support_math_acosh_float_constants",
-         ":__support_fputil_fp_bits",
-         ":__support_fputil_multiply_add",
-         ":__support_fputil_polyeval",
-+        ":__support_math_acosh_float_constants",
-     ],
- )
- 
-@@ -2132,12 +2148,12 @@
-     name = "__support_math_acoshf",
-     hdrs = ["src/__support/math/acoshf.h"],
-     deps = [
--        ":__support_math_acoshf_utils",
-         ":__support_fputil_fenv_impl",
-         ":__support_fputil_fp_bits",
-         ":__support_fputil_multiply_add",
-         ":__support_fputil_sqrt",
-         ":__support_macros_optimization",
-+        ":__support_math_acoshf_utils",
-     ],
- )
- 
-@@ -2145,7 +2161,6 @@
-     name = "__support_math_acoshf16",
-     hdrs = ["src/__support/math/acoshf16.h"],
-     deps = [
--        ":__support_math_acoshf_utils",
-         ":__support_fputil_cast",
-         ":__support_fputil_except_value_utils",
-         ":__support_fputil_fenv_impl",
-@@ -2154,6 +2169,7 @@
-         ":__support_fputil_polyeval",
-         ":__support_fputil_sqrt",
-         ":__support_macros_optimization",
-+        ":__support_math_acoshf_utils",
-     ],
- )
- 
-@@ -2161,12 +2177,12 @@
-     name = "__support_math_asin_utils",
-     hdrs = ["src/__support/math/asin_utils.h"],
-     deps = [
--        ":__support_integer_literals",
-         ":__support_fputil_double_double",
-         ":__support_fputil_dyadic_float",
-         ":__support_fputil_multiply_add",
-         ":__support_fputil_nearest_integer",
-         ":__support_fputil_polyeval",
-+        ":__support_integer_literals",
-         ":__support_macros_optimization",
-     ],
- )
-@@ -2175,6 +2191,8 @@
-     name = "__support_math_erff",
-     hdrs = ["src/__support/math/erff.h"],
-     deps = [
-+        ":__support_fputil_except_value_utils",
-+        ":__support_fputil_fp_bits",
-         ":__support_fputil_multiply_add",
-         ":__support_fputil_polyeval",
-         ":__support_macros_optimization",
-@@ -2215,7 +2233,7 @@
-         ":__support_fputil_nearest_integer",
-         ":__support_fputil_polyeval",
-         ":__support_macros_attributes",
--        ":llvm_libc_macros_float16_macros"
-+        ":llvm_libc_macros_float16_macros",
-     ],
- )
- 
-@@ -2224,7 +2242,6 @@
-     hdrs = ["src/__support/math/expf16.h"],
-     deps = [
-         ":__support_common",
--        ":__support_libc_errno",
-         ":__support_cpp_array",
-         ":__support_fputil_cast",
-         ":__support_fputil_except_value_utils",
-@@ -2234,9 +2251,10 @@
-         ":__support_fputil_nearest_integer",
-         ":__support_fputil_polyeval",
-         ":__support_fputil_rounding_mode",
-+        ":__support_libc_errno",
-         ":__support_macros_optimization",
-         ":__support_math_expf16_utils",
--        ":llvm_libc_macros_float16_macros"
-+        ":llvm_libc_macros_float16_macros",
-     ],
- )
- 
-@@ -2244,8 +2262,8 @@
-     name = "__support_math_frexpf128",
-     hdrs = ["src/__support/math/frexpf128.h"],
-     deps = [
--        ":__support_macros_properties_types",
-         ":__support_fputil_manipulation_functions",
-+        ":__support_macros_properties_types",
-     ],
- )
- 
-@@ -2253,9 +2271,9 @@
-     name = "__support_math_inv_trigf_utils",
-     hdrs = ["src/__support/math/inv_trigf_utils.h"],
-     deps = [
-+        ":__support_common",
-         ":__support_fputil_multiply_add",
-         ":__support_fputil_polyeval",
--        ":__support_common",
-     ],
- )
- 
-@@ -2263,10 +2281,10 @@
-     name = "__support_math_frexpf16",
-     hdrs = ["src/__support/math/frexpf16.h"],
-     deps = [
-+        ":__support_fputil_manipulation_functions",
-         ":__support_macros_config",
-         ":__support_macros_properties_types",
--        ":__support_fputil_manipulation_functions",
--        ":llvm_libc_macros_float16_macros"
-+        ":llvm_libc_macros_float16_macros",
-     ],
- )
- 
-@@ -2284,7 +2302,7 @@
-     deps = [
-         ":__support_fputil_manipulation_functions",
-         ":__support_macros_properties_types",
--        ":llvm_libc_types_float128"
-+        ":llvm_libc_types_float128",
-     ],
- )
- 
-@@ -2292,9 +2310,9 @@
-     name = "__support_math_ldexpf16",
-     hdrs = ["src/__support/math/ldexpf16.h"],
-     deps = [
--        ":__support_macros_properties_types",
-         ":__support_fputil_manipulation_functions",
--        ":llvm_libc_macros_float16_macros"
-+        ":__support_macros_properties_types",
-+        ":llvm_libc_macros_float16_macros",
-     ],
- )
- 
-@@ -2318,8 +2336,8 @@
-     name = "__support_math_exp_utils",
-     hdrs = ["src/__support/math/exp_utils.h"],
-     deps = [
--        ":__support_cpp_optional",
-         ":__support_cpp_bit",
-+        ":__support_cpp_optional",
-         ":__support_fputil_fp_bits",
-     ],
- )
-@@ -2328,10 +2346,9 @@
-     name = "__support_math_exp",
-     hdrs = ["src/__support/math/exp.h"],
-     deps = [
--        ":__support_math_exp_constants",
--        ":__support_math_exp_utils",
-         ":__support_cpp_bit",
-         ":__support_cpp_optional",
-+        ":__support_fputil_double_double",
-         ":__support_fputil_dyadic_float",
-         ":__support_fputil_fenv_impl",
-         ":__support_fputil_fp_bits",
-@@ -2340,9 +2357,10 @@
-         ":__support_fputil_polyeval",
-         ":__support_fputil_rounding_mode",
-         ":__support_fputil_triple_double",
--        ":__support_fputil_double_double",
-         ":__support_integer_literals",
-         ":__support_macros_optimization",
-+        ":__support_math_exp_constants",
-+        ":__support_math_exp_utils",
-     ],
- )
- 
-@@ -2350,8 +2368,6 @@
-     name = "__support_math_exp10",
-     hdrs = ["src/__support/math/exp10.h"],
-     deps = [
--        ":__support_math_exp_constants",
--        ":__support_math_exp_utils",
-         ":__support_fputil_double_double",
-         ":__support_fputil_dyadic_float",
-         ":__support_fputil_multiply_add",
-@@ -2361,6 +2377,8 @@
-         ":__support_fputil_triple_double",
-         ":__support_integer_literals",
-         ":__support_macros_optimization",
-+        ":__support_math_exp_constants",
-+        ":__support_math_exp_utils",
-     ],
- )
- 
-@@ -2368,12 +2386,12 @@
-     name = "__support_math_exp10f_utils",
-     hdrs = ["src/__support/math/exp10f_utils.h"],
-     deps = [
-+        ":__support_common",
-         ":__support_fputil_basic_operations",
-         ":__support_fputil_fenv_impl",
-         ":__support_fputil_multiply_add",
-         ":__support_fputil_nearest_integer",
-         ":__support_fputil_polyeval",
--        ":__support_common",
-         ":__support_math_exp_utils",
-     ],
- )
-@@ -2382,12 +2400,12 @@
-     name = "__support_math_exp10f",
-     hdrs = ["src/__support/math/exp10f.h"],
-     deps = [
--        ":__support_math_exp10f_utils",
-         ":__support_fputil_fenv_impl",
-         ":__support_fputil_fp_bits",
-         ":__support_fputil_multiply_add",
-         ":__support_fputil_rounding_mode",
-         ":__support_macros_optimization",
-+        ":__support_math_exp10f_utils",
-     ],
- )
- 
-@@ -2403,9 +2421,9 @@
-     name = "__support_math_exp10f16_utils",
-     hdrs = ["src/__support/math/exp10f16_utils.h"],
-     deps = [
-+        ":__support_fputil_fp_bits",
-         ":__support_math_exp10_float16_constants",
-         ":__support_math_expf16_utils",
--        ":__support_fputil_fp_bits",
-     ],
- )
- 
-@@ -2413,13 +2431,13 @@
-     name = "__support_math_exp10f16",
-     hdrs = ["src/__support/math/exp10f16.h"],
-     deps = [
--        ":__support_math_exp10f16_utils",
--        ":__support_fputil_fp_bits",
-         ":__support_fputil_cast",
--        ":__support_fputil_rounding_mode",
-         ":__support_fputil_except_value_utils",
-+        ":__support_fputil_fp_bits",
-+        ":__support_fputil_rounding_mode",
-         ":__support_macros_optimization",
-         ":__support_macros_properties_cpu_features",
-+        ":__support_math_exp10f16_utils",
-     ],
- )
- 
-@@ -2991,7 +3009,7 @@
- libc_math_function(
-     name = "erff",
-     additional_deps = [
--        ":__support_math_erff"
-+        ":__support_math_erff",
-     ],
- )
- 
-@@ -3462,13 +3480,13 @@
-     name = "frexpf128",
-     additional_deps = [
-         ":__support_math_frexpf128",
--    ]
-+    ],
- )
- 
- libc_math_function(
-     name = "frexpf16",
-     additional_deps = [
--        ":__support_math_frexpf16"
-+        ":__support_math_frexpf16",
-     ],
- )
- 
-@@ -3563,7 +3581,7 @@
-     name = "ldexpf",
-     additional_deps = [
-         ":__support_math_ldexpf",
--    ]
-+    ],
- )
- 
- libc_math_function(name = "ldexpl")
-diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/libc/test/src/__support/FPUtil/BUILD.bazel b/utils/bazel/llvm-project-overlay/libc/test/src/__support/FPUtil/BUILD.bazel
---- a/utils/bazel/llvm-project-overlay/libc/test/src/__support/FPUtil/BUILD.bazel
-+++ b/utils/bazel/llvm-project-overlay/libc/test/src/__support/FPUtil/BUILD.bazel
-@@ -58,3 +58,15 @@
-         "//libc/utils/MPFRWrapper:mpfr_wrapper",
-     ],
- )
-+
-+libc_test(
-+    name = "comparison_operations_test",
-+    srcs = ["comparison_operations_test.cpp"],
-+    deps = [
-+        "//libc:__support_fputil_bfloat16",
-+        "//libc:__support_fputil_comparison_operations",
-+        "//libc:__support_fputil_rounding_mode",
-+        "//libc:__support_macros_properties_types",
-+        "//libc/test/UnitTest:fp_test_helpers",
-+    ],
-+)
-diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/libc/utils/MPFRWrapper/BUILD.bazel b/utils/bazel/llvm-project-overlay/libc/utils/MPFRWrapper/BUILD.bazel
---- a/utils/bazel/llvm-project-overlay/libc/utils/MPFRWrapper/BUILD.bazel
-+++ b/utils/bazel/llvm-project-overlay/libc/utils/MPFRWrapper/BUILD.bazel
-@@ -44,6 +44,7 @@
-         "//libc:__support_cpp_type_traits",
-         "//libc:__support_fputil_bfloat16",
-         "//libc:__support_fputil_cast",
-+        "//libc:__support_fputil_comparison_operations",
-         "//libc:__support_fputil_fp_bits",
-         "//libc:__support_macros_config",
-         "//libc:__support_macros_properties_types",
diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl
index 189d649..aa7fc32 100644
--- a/third_party/llvm/workspace.bzl
+++ b/third_party/llvm/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive")
 
 def repo(name):
     """Imports LLVM."""
-    LLVM_COMMIT = "22b0835390516c2150c040521885c473f3a1e87e"
-    LLVM_SHA256 = "963953aedf9f6e5fdc16cdb3a64d93d80ab6159078c307216f4f49ab7be81d2b"
+    LLVM_COMMIT = "652048ad2578c715d8d65d90fd3fe5d5d2bd42e7"
+    LLVM_SHA256 = "7398adc86335c401bc018583f03c87987cdae19988036819eb3c2b7ebe74b449"
 
     tf_http_archive(
         name = name,
