diff --git a/third_party/llvm/generated.patch b/third_party/llvm/generated.patch
index 7f5123e..b8e64c3 100644
--- a/third_party/llvm/generated.patch
+++ b/third_party/llvm/generated.patch
@@ -1,254 +1,812 @@
 Auto generated patch. Do not edit or delete it, even if empty.
-diff -ruN --strip-trailing-cr a/llvm/include/llvm/Analysis/LoopInfo.h b/llvm/include/llvm/Analysis/LoopInfo.h
---- a/llvm/include/llvm/Analysis/LoopInfo.h
-+++ b/llvm/include/llvm/Analysis/LoopInfo.h
-@@ -59,11 +59,12 @@
-   };
- 
-   /// Return true if the specified value is loop invariant.
--  bool isLoopInvariant(const Value *V) const;
-+  bool isLoopInvariant(const Value *V, bool HasCoroSuspendInst = false) const;
- 
-   /// Return true if all the operands of the specified instruction are loop
-   /// invariant.
--  bool hasLoopInvariantOperands(const Instruction *I) const;
-+  bool hasLoopInvariantOperands(const Instruction *I,
-+                                bool HasCoroSuspendInst = false) const;
- 
-   /// If the given value is an instruction inside of the loop and it can be
-   /// hoisted, do so to make it trivially loop-invariant.
-diff -ruN --strip-trailing-cr a/llvm/include/llvm/Transforms/Utils/LoopUtils.h b/llvm/include/llvm/Transforms/Utils/LoopUtils.h
---- a/llvm/include/llvm/Transforms/Utils/LoopUtils.h
-+++ b/llvm/include/llvm/Transforms/Utils/LoopUtils.h
-@@ -185,7 +185,8 @@
-                           TargetLibraryInfo *, Loop *, MemorySSAUpdater &,
-                           ScalarEvolution *, ICFLoopSafetyInfo *,
-                           SinkAndHoistLICMFlags &, OptimizationRemarkEmitter *,
--                          bool, bool AllowSpeculation);
-+                          bool, bool AllowSpeculation,
-+                          bool HasCoroSuspendInst = false);
- 
- /// Return true if the induction variable \p IV in a Loop whose latch is
- /// \p LatchBlock would become dead if the exit test \p Cond were removed.
-diff -ruN --strip-trailing-cr a/llvm/lib/Analysis/LoopInfo.cpp b/llvm/lib/Analysis/LoopInfo.cpp
---- a/llvm/lib/Analysis/LoopInfo.cpp
-+++ b/llvm/lib/Analysis/LoopInfo.cpp
-@@ -58,14 +58,26 @@
- // Loop implementation
- //
- 
--bool Loop::isLoopInvariant(const Value *V) const {
--  if (const Instruction *I = dyn_cast<Instruction>(V))
--    return !contains(I);
-+bool Loop::isLoopInvariant(const Value *V, bool HasCoroSuspendInst) const {
-+  if (const Instruction *I = dyn_cast<Instruction>(V)) {
-+    // FIXME: this is semantically inconsistent. We're tracking a proper fix in
-+    // issue #149604.
-+    // If V is a pointer to stack object and L contains a coro.suspend function
-+    // call, then V may not be loop invariant because the ramp function and
-+    // resume function have different stack frames.
-+    if (HasCoroSuspendInst && isa<AllocaInst>(I))
-+      return false;
-+    else
-+      return !contains(I);
+diff -ruN --strip-trailing-cr a/clang/include/clang/AST/TemplateName.h b/clang/include/clang/AST/TemplateName.h
+--- a/clang/include/clang/AST/TemplateName.h
++++ b/clang/include/clang/AST/TemplateName.h
+@@ -335,17 +335,17 @@
+   /// structure, if any.
+   QualifiedTemplateName *getAsQualifiedTemplateName() const;
+ 
+-  /// Retrieve the underlying qualified template name,
+-  /// looking through underlying nodes.
+-  QualifiedTemplateName *getAsAdjustedQualifiedTemplateName() const;
+-
+   /// Retrieve the underlying dependent template name
+   /// structure, if any.
+   DependentTemplateName *getAsDependentTemplateName() const;
+ 
+-  // Retrieve the qualifier stored in either a underlying DependentTemplateName
+-  // or QualifiedTemplateName.
+-  NestedNameSpecifier getQualifier() const;
++  // Retrieve the qualifier and template keyword stored in either a underlying
++  // DependentTemplateName or QualifiedTemplateName.
++  std::tuple<NestedNameSpecifier, bool> getQualifierAndTemplateKeyword() const;
++
++  NestedNameSpecifier getQualifier() const {
++    return std::get<0>(getQualifierAndTemplateKeyword());
 +  }
-   return true; // All non-instructions are loop invariant
+ 
+   /// Retrieve the using shadow declaration through which the underlying
+   /// template declaration is introduced, if any.
+diff -ruN --strip-trailing-cr a/clang/include/clang/AST/TypeLoc.h b/clang/include/clang/AST/TypeLoc.h
+--- a/clang/include/clang/AST/TypeLoc.h
++++ b/clang/include/clang/AST/TypeLoc.h
+@@ -1872,11 +1872,10 @@
+     if (!getLocalData()->QualifierData)
+       return NestedNameSpecifierLoc();
+ 
+-    auto *QTN =
+-        getTypePtr()->getTemplateName().getAsAdjustedQualifiedTemplateName();
+-    assert(QTN && "missing qualification");
+-    return NestedNameSpecifierLoc(QTN->getQualifier(),
+-                                  getLocalData()->QualifierData);
++    NestedNameSpecifier Qualifier =
++        getTypePtr()->getTemplateName().getQualifier();
++    assert(Qualifier && "missing qualification");
++    return NestedNameSpecifierLoc(Qualifier, getLocalData()->QualifierData);
+   }
+ 
+   SourceLocation getTemplateKeywordLoc() const {
+@@ -2503,10 +2502,9 @@
+     void *Data = getLocalData()->QualifierData;
+     if (!Data)
+       return NestedNameSpecifierLoc();
+-    NestedNameSpecifier Qualifier = getTypePtr()
+-                                        ->getTemplateName()
+-                                        .getAsAdjustedQualifiedTemplateName()
+-                                        ->getQualifier();
++    NestedNameSpecifier Qualifier =
++        getTypePtr()->getTemplateName().getQualifier();
++    assert(Qualifier && "missing qualification");
+     return NestedNameSpecifierLoc(Qualifier, Data);
+   }
+ 
+@@ -2521,10 +2519,7 @@
+     }
+ 
+     assert(QualifierLoc.getNestedNameSpecifier() ==
+-               getTypePtr()
+-                   ->getTemplateName()
+-                   .getAsAdjustedQualifiedTemplateName()
+-                   ->getQualifier() &&
++               getTypePtr()->getTemplateName().getQualifier() &&
+            "Inconsistent nested-name-specifier pointer");
+     getLocalData()->QualifierData = QualifierLoc.getOpaqueData();
+   }
+diff -ruN --strip-trailing-cr a/clang/lib/AST/ASTContext.cpp b/clang/lib/AST/ASTContext.cpp
+--- a/clang/lib/AST/ASTContext.cpp
++++ b/clang/lib/AST/ASTContext.cpp
+@@ -5484,18 +5484,15 @@
+   return T;
  }
  
--bool Loop::hasLoopInvariantOperands(const Instruction *I) const {
--  return all_of(I->operands(), [this](Value *V) { return isLoopInvariant(V); });
-+bool Loop::hasLoopInvariantOperands(const Instruction *I,
-+                                    bool HasCoroSuspendInst) const {
-+  return all_of(I->operands(), [&](Value *V) {
-+    return isLoopInvariant(V, HasCoroSuspendInst);
-+  });
+-static bool getNonInjectedClassName(const TagDecl *&TD) {
++static const TagDecl *getNonInjectedClassName(const TagDecl *TD) {
+   if (const auto *RD = dyn_cast<CXXRecordDecl>(TD);
+-      RD && RD->isInjectedClassName()) {
+-    TD = cast<TagDecl>(RD->getDeclContext());
+-    return true;
+-  }
+-  return false;
++      RD && RD->isInjectedClassName())
++    return cast<TagDecl>(RD->getDeclContext());
++  return TD;
  }
  
- bool Loop::makeLoopInvariant(Value *V, bool &Changed, Instruction *InsertPt,
-diff -ruN --strip-trailing-cr a/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp b/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
---- a/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
-+++ b/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
-@@ -680,6 +680,8 @@
-   // No support for these operations with v2f32.
-   setOperationAction(ISD::INSERT_VECTOR_ELT, MVT::v2f32, Expand);
-   setOperationAction(ISD::VECTOR_SHUFFLE, MVT::v2f32, Expand);
-+  // Need custom lowering in case the index is dynamic.
-+  setOperationAction(ISD::EXTRACT_VECTOR_ELT, MVT::v2f32, Custom);
- 
-   // Custom conversions to/from v2i8.
-   setOperationAction(ISD::BITCAST, MVT::v2i8, Custom);
-diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/Scalar/LICM.cpp b/llvm/lib/Transforms/Scalar/LICM.cpp
---- a/llvm/lib/Transforms/Scalar/LICM.cpp
-+++ b/llvm/lib/Transforms/Scalar/LICM.cpp
-@@ -472,7 +472,7 @@
-   if (Preheader)
-     Changed |= hoistRegion(DT->getNode(L->getHeader()), AA, LI, DT, AC, TLI, L,
-                            MSSAU, SE, &SafetyInfo, Flags, ORE, LoopNestMode,
--                           LicmAllowSpeculation);
-+                           LicmAllowSpeculation, HasCoroSuspendInst);
- 
-   // Now that all loop invariants have been removed from the loop, promote any
-   // memory references to scalars that we can.
-@@ -881,7 +881,7 @@
-                        ICFLoopSafetyInfo *SafetyInfo,
-                        SinkAndHoistLICMFlags &Flags,
-                        OptimizationRemarkEmitter *ORE, bool LoopNestMode,
--                       bool AllowSpeculation) {
-+                       bool AllowSpeculation, bool HasCoroSuspendInst) {
-   // Verify inputs.
-   assert(N != nullptr && AA != nullptr && LI != nullptr && DT != nullptr &&
-          CurLoop != nullptr && SafetyInfo != nullptr &&
-@@ -914,11 +914,11 @@
-       // TODO: It may be safe to hoist if we are hoisting to a conditional block
-       // and we have accurately duplicated the control flow from the loop header
-       // to that block.
--      if (CurLoop->hasLoopInvariantOperands(&I) &&
-+      if (CurLoop->hasLoopInvariantOperands(&I, HasCoroSuspendInst) &&
-           canSinkOrHoistInst(I, AA, DT, CurLoop, MSSAU, true, Flags, ORE) &&
--          isSafeToExecuteUnconditionally(
--              I, DT, TLI, CurLoop, SafetyInfo, ORE,
--              Preheader->getTerminator(), AC, AllowSpeculation)) {
-+          isSafeToExecuteUnconditionally(I, DT, TLI, CurLoop, SafetyInfo, ORE,
-+                                         Preheader->getTerminator(), AC,
-+                                         AllowSpeculation)) {
-         hoist(I, DT, CurLoop, CFH.getOrCreateHoistedBlock(BB), SafetyInfo,
-               MSSAU, SE, ORE);
-         HoistedInstructions.push_back(&I);
-@@ -964,7 +964,7 @@
-                SafetyInfo->doesNotWriteMemoryBefore(I, CurLoop);
-       };
-       if ((IsInvariantStart(I) || isGuard(&I)) &&
--          CurLoop->hasLoopInvariantOperands(&I) &&
-+          CurLoop->hasLoopInvariantOperands(&I, HasCoroSuspendInst) &&
-           MustExecuteWithoutWritesBefore(I)) {
-         hoist(I, DT, CurLoop, CFH.getOrCreateHoistedBlock(BB), SafetyInfo,
-               MSSAU, SE, ORE);
-diff -ruN --strip-trailing-cr a/llvm/test/CodeGen/NVPTX/f32x2-instructions.ll b/llvm/test/CodeGen/NVPTX/f32x2-instructions.ll
---- a/llvm/test/CodeGen/NVPTX/f32x2-instructions.ll
-+++ b/llvm/test/CodeGen/NVPTX/f32x2-instructions.ll
-@@ -79,13 +79,24 @@
-   ret float %e
+ CanQualType ASTContext::getCanonicalTagType(const TagDecl *TD) const {
+-  ::getNonInjectedClassName(TD);
+-  TD = TD->getCanonicalDecl();
++  TD = ::getNonInjectedClassName(TD)->getCanonicalDecl();
+   if (TD->TypeForDecl)
+     return TD->TypeForDecl->getCanonicalTypeUnqualified();
+ 
+@@ -5511,40 +5508,42 @@
+ QualType ASTContext::getTagType(ElaboratedTypeKeyword Keyword,
+                                 NestedNameSpecifier Qualifier,
+                                 const TagDecl *TD, bool OwnsTag) const {
++
++  const TagDecl *NonInjectedTD = ::getNonInjectedClassName(TD);
++  bool IsInjected = TD != NonInjectedTD;
++
+   ElaboratedTypeKeyword PreferredKeyword =
+-      getLangOpts().CPlusPlus
+-          ? ElaboratedTypeKeyword::None
+-          : KeywordHelpers::getKeywordForTagTypeKind(TD->getTagKind());
++      getLangOpts().CPlusPlus ? ElaboratedTypeKeyword::None
++                              : KeywordHelpers::getKeywordForTagTypeKind(
++                                    NonInjectedTD->getTagKind());
+ 
+   if (Keyword == PreferredKeyword && !Qualifier && !OwnsTag) {
+     if (const Type *T = TD->TypeForDecl; T && !T->isCanonicalUnqualified())
+       return QualType(T, 0);
+ 
+-    bool IsInjected = ::getNonInjectedClassName(TD);
+-    const Type *CanonicalType = getCanonicalTagType(TD).getTypePtr();
++    const Type *CanonicalType = getCanonicalTagType(NonInjectedTD).getTypePtr();
+     const Type *T =
+         getTagTypeInternal(Keyword,
+-                           /*Qualifier=*/std::nullopt, TD,
++                           /*Qualifier=*/std::nullopt, NonInjectedTD,
+                            /*OwnsTag=*/false, IsInjected, CanonicalType,
+                            /*WithFoldingSetNode=*/false);
+     TD->TypeForDecl = T;
+     return QualType(T, 0);
+   }
+ 
+-  bool IsInjected = ::getNonInjectedClassName(TD);
+-
+   llvm::FoldingSetNodeID ID;
+-  TagTypeFoldingSetPlaceholder::Profile(ID, Keyword, Qualifier, TD, OwnsTag,
+-                                        IsInjected);
++  TagTypeFoldingSetPlaceholder::Profile(ID, Keyword, Qualifier, NonInjectedTD,
++                                        OwnsTag, IsInjected);
+ 
+   void *InsertPos = nullptr;
+   if (TagTypeFoldingSetPlaceholder *T =
+           TagTypes.FindNodeOrInsertPos(ID, InsertPos))
+     return QualType(T->getTagType(), 0);
+ 
+-  const Type *CanonicalType = getCanonicalTagType(TD).getTypePtr();
+-  TagType *T = getTagTypeInternal(Keyword, Qualifier, TD, OwnsTag, IsInjected,
+-                                  CanonicalType, /*WithFoldingSetNode=*/true);
++  const Type *CanonicalType = getCanonicalTagType(NonInjectedTD).getTypePtr();
++  TagType *T =
++      getTagTypeInternal(Keyword, Qualifier, NonInjectedTD, OwnsTag, IsInjected,
++                         CanonicalType, /*WithFoldingSetNode=*/true);
+   TagTypes.InsertNode(TagTypeFoldingSetPlaceholder::fromTagType(T), InsertPos);
+   return QualType(T, 0);
  }
+@@ -10457,6 +10456,12 @@
+   assert(Template.getKind() == TemplateName::Template ||
+          Template.getKind() == TemplateName::UsingTemplate);
+ 
++  if (Template.getAsTemplateDecl()->getKind() == Decl::TemplateTemplateParm) {
++    assert(!Qualifier && "unexpected qualified template template parameter");
++    assert(TemplateKeyword == false);
++    return Template;
++  }
++
+   // FIXME: Canonicalization?
+   llvm::FoldingSetNodeID ID;
+   QualifiedTemplateName::Profile(ID, Qualifier, TemplateKeyword, Template);
+diff -ruN --strip-trailing-cr a/clang/lib/AST/TemplateName.cpp b/clang/lib/AST/TemplateName.cpp
+--- a/clang/lib/AST/TemplateName.cpp
++++ b/clang/lib/AST/TemplateName.cpp
+@@ -289,28 +289,23 @@
+   return dyn_cast_if_present<QualifiedTemplateName *>(Storage);
+ }
+ 
+-QualifiedTemplateName *
+-TemplateName::getAsAdjustedQualifiedTemplateName() const {
+-  for (std::optional<TemplateName> Cur = *this; Cur;
+-       Cur = Cur->desugar(/*IgnoreDeduced=*/true))
+-    if (QualifiedTemplateName *N = Cur->getAsQualifiedTemplateName())
+-      return N;
+-  return nullptr;
+-}
+-
+ DependentTemplateName *TemplateName::getAsDependentTemplateName() const {
+   return Storage.dyn_cast<DependentTemplateName *>();
+ }
+ 
+-NestedNameSpecifier TemplateName::getQualifier() const {
++std::tuple<NestedNameSpecifier, bool>
++TemplateName::getQualifierAndTemplateKeyword() const {
+   for (std::optional<TemplateName> Cur = *this; Cur;
+        Cur = Cur->desugar(/*IgnoreDeduced=*/true)) {
+     if (DependentTemplateName *N = Cur->getAsDependentTemplateName())
+-      return N->getQualifier();
++      return {N->getQualifier(), N->hasTemplateKeyword()};
+     if (QualifiedTemplateName *N = Cur->getAsQualifiedTemplateName())
+-      return N->getQualifier();
++      return {N->getQualifier(), N->hasTemplateKeyword()};
++    if (Cur->getAsSubstTemplateTemplateParm() ||
++        Cur->getAsSubstTemplateTemplateParmPack())
++      break;
+   }
+-  return std::nullopt;
++  return {std::nullopt, false};
+ }
+ 
+ UsingShadowDecl *TemplateName::getAsUsingShadowDecl() const {
+@@ -448,8 +443,14 @@
+       Template = cast<TemplateDecl>(Template->getCanonicalDecl());
+     if (handleAnonymousTTP(Template, OS))
+       return;
+-    if (Qual == Qualified::None || Policy.SuppressScope) {
+-      OS << *Template;
++    if (Qual == Qualified::None || isa<TemplateTemplateParmDecl>(Template) ||
++        Policy.SuppressScope) {
++      if (IdentifierInfo *II = Template->getIdentifier();
++          Policy.CleanUglifiedParameters && II &&
++          isa<TemplateTemplateParmDecl>(Template))
++        OS << II->deuglifiedName();
++      else
++        OS << *Template;
+     } else {
+       PrintingPolicy NestedNamePolicy = Policy;
+       NestedNamePolicy.SuppressUnwrittenScope = true;
+@@ -474,12 +475,7 @@
+     if (handleAnonymousTTP(UTD, OS))
+       return;
+ 
+-    if (IdentifierInfo *II = UTD->getIdentifier();
+-        Policy.CleanUglifiedParameters && II &&
+-        isa<TemplateTemplateParmDecl>(UTD))
+-      OS << II->deuglifiedName();
+-    else
+-      OS << *UTD;
++    OS << *UTD;
+   } else if (DependentTemplateName *DTN = getAsDependentTemplateName()) {
+     DTN->print(OS, Policy);
+   } else if (SubstTemplateTemplateParmStorage *subst =
+diff -ruN --strip-trailing-cr a/clang/lib/AST/Type.cpp b/clang/lib/AST/Type.cpp
+--- a/clang/lib/AST/Type.cpp
++++ b/clang/lib/AST/Type.cpp
+@@ -1963,12 +1963,10 @@
+   switch (getTypeClass()) {
+   case Type::DependentName:
+     return cast<DependentNameType>(this)->getQualifier();
+-  case Type::TemplateSpecialization: {
+-    QualifiedTemplateName *S = cast<TemplateSpecializationType>(this)
+-                                   ->getTemplateName()
+-                                   .getAsAdjustedQualifiedTemplateName();
+-    return S ? S->getQualifier() : std::nullopt;
+-  }
++  case Type::TemplateSpecialization:
++    return cast<TemplateSpecializationType>(this)
++        ->getTemplateName()
++        .getQualifier();
+   case Type::DependentTemplateSpecialization:
+     return cast<DependentTemplateSpecializationType>(this)
+         ->getDependentTemplateName()
+diff -ruN --strip-trailing-cr a/clang/lib/AST/TypeLoc.cpp b/clang/lib/AST/TypeLoc.cpp
+--- a/clang/lib/AST/TypeLoc.cpp
++++ b/clang/lib/AST/TypeLoc.cpp
+@@ -750,8 +750,9 @@
+ 
+ void TemplateSpecializationTypeLoc::initializeLocal(ASTContext &Context,
+                                                     SourceLocation Loc) {
+-  QualifiedTemplateName *Name =
+-      getTypePtr()->getTemplateName().getAsAdjustedQualifiedTemplateName();
++
++  auto [Qualifier, HasTemplateKeyword] =
++      getTypePtr()->getTemplateName().getQualifierAndTemplateKeyword();
+ 
+   SourceLocation ElaboratedKeywordLoc =
+       getTypePtr()->getKeyword() != ElaboratedTypeKeyword::None
+@@ -759,8 +760,7 @@
+           : SourceLocation();
+ 
+   NestedNameSpecifierLoc QualifierLoc;
+-  if (NestedNameSpecifier Qualifier =
+-          Name ? Name->getQualifier() : std::nullopt) {
++  if (Qualifier) {
+     NestedNameSpecifierLocBuilder Builder;
+     Builder.MakeTrivial(Context, Qualifier, Loc);
+     QualifierLoc = Builder.getWithLocInContext(Context);
+@@ -768,9 +768,7 @@
+ 
+   TemplateArgumentListInfo TAL(Loc, Loc);
+   set(ElaboratedKeywordLoc, QualifierLoc,
+-      /*TemplateKeywordLoc=*/Name && Name->hasTemplateKeyword()
+-          ? Loc
+-          : SourceLocation(),
++      /*TemplateKeywordLoc=*/HasTemplateKeyword ? Loc : SourceLocation(),
+       /*NameLoc=*/Loc, /*LAngleLoc=*/Loc, /*RAngleLoc=*/Loc);
+   initializeArgLocs(Context, getTypePtr()->template_arguments(), getArgInfos(),
+                     Loc);
+diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaLookup.cpp b/clang/lib/Sema/SemaLookup.cpp
+--- a/clang/lib/Sema/SemaLookup.cpp
++++ b/clang/lib/Sema/SemaLookup.cpp
+@@ -4581,7 +4581,7 @@
+         TemplateName Name =
+             cast<TemplateSpecializationType>(T)->getTemplateName();
+         if (const QualifiedTemplateName *QTN =
+-                Name.getAsAdjustedQualifiedTemplateName()) {
++                Name.getAsQualifiedTemplateName()) {
+           getNestedNameSpecifierIdentifiers(QTN->getQualifier(), Identifiers);
+           Name = QTN->getUnderlyingTemplate();
+         }
+diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaTemplateInstantiate.cpp b/clang/lib/Sema/SemaTemplateInstantiate.cpp
+--- a/clang/lib/Sema/SemaTemplateInstantiate.cpp
++++ b/clang/lib/Sema/SemaTemplateInstantiate.cpp
+@@ -2124,9 +2124,11 @@
+     NestedNameSpecifierLoc &QualifierLoc, SourceLocation TemplateKWLoc,
+     TemplateName Name, SourceLocation NameLoc, QualType ObjectType,
+     NamedDecl *FirstQualifierInScope, bool AllowInjectedClassName) {
+-  if (TemplateTemplateParmDecl *TTP
+-       = dyn_cast_or_null<TemplateTemplateParmDecl>(Name.getAsTemplateDecl())) {
+-    if (TTP->getDepth() < TemplateArgs.getNumLevels()) {
++  if (Name.getKind() == TemplateName::Template) {
++    assert(!QualifierLoc && "Unexpected qualifier");
++    if (auto *TTP =
++            dyn_cast<TemplateTemplateParmDecl>(Name.getAsTemplateDecl());
++        TTP && TTP->getDepth() < TemplateArgs.getNumLevels()) {
+       // If the corresponding template argument is NULL or non-existent, it's
+       // because we are performing instantiation from explicitly-specified
+       // template arguments in a function template, but there were some
+@@ -2169,13 +2171,6 @@
+ 
+       TemplateName Template = Arg.getAsTemplate();
+       assert(!Template.isNull() && "Null template template argument");
+-
+-      if (NestedNameSpecifier Qualifier = Template.getQualifier()) {
+-        NestedNameSpecifierLocBuilder Builder;
+-        Builder.MakeTrivial(SemaRef.Context, Qualifier, NameLoc);
+-        QualifierLoc = Builder.getWithLocInContext(SemaRef.Context);
+-      }
+-
+       return getSema().Context.getSubstTemplateTemplateParm(
+           Template, AssociatedDecl, TTP->getIndex(), PackIndex, Final);
+     }
+diff -ruN --strip-trailing-cr a/clang/lib/Sema/TreeTransform.h b/clang/lib/Sema/TreeTransform.h
+--- a/clang/lib/Sema/TreeTransform.h
++++ b/clang/lib/Sema/TreeTransform.h
+@@ -744,11 +744,6 @@
+ 
+   StmtResult TransformSEHHandler(Stmt *Handler);
  
--; NOTE: disabled as -O3 miscompiles this into pointer arithmetic on
--; test_extract_i_param_0 where the symbol's address is not taken first (that
--; is, moved to a temporary)
--; define float @test_extract_i(<2 x float> %a, i64 %idx) #0 {
--;   %e = extractelement <2 x float> %a, i64 %idx
--;   ret float %e
--; }
-+define float @test_extract_i(<2 x float> %a, i64 %idx) #0 {
-+; CHECK-LABEL: test_extract_i(
-+; CHECK:       {
-+; CHECK-NEXT:    .reg .pred %p<2>;
-+; CHECK-NEXT:    .reg .b32 %r<4>;
-+; CHECK-NEXT:    .reg .b64 %rd<3>;
-+; CHECK-EMPTY:
-+; CHECK-NEXT:  // %bb.0:
-+; CHECK-NEXT:    ld.param.b64 %rd2, [test_extract_i_param_1];
-+; CHECK-NEXT:    ld.param.b64 %rd1, [test_extract_i_param_0];
-+; CHECK-NEXT:    setp.eq.b64 %p1, %rd2, 0;
-+; CHECK-NEXT:    mov.b64 {%r1, %r2}, %rd1;
-+; CHECK-NEXT:    selp.f32 %r3, %r1, %r2, %p1;
-+; CHECK-NEXT:    st.param.b32 [func_retval0], %r3;
-+; CHECK-NEXT:    ret;
-+  %e = extractelement <2 x float> %a, i64 %idx
-+  ret float %e
-+}
- 
- define <2 x float> @test_fadd(<2 x float> %a, <2 x float> %b) #0 {
- ; CHECK-NOF32X2-LABEL: test_fadd(
-diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LICM/licm-coroutine.ll b/llvm/test/Transforms/LICM/licm-coroutine.ll
---- a/llvm/test/Transforms/LICM/licm-coroutine.ll
-+++ b/llvm/test/Transforms/LICM/licm-coroutine.ll
-@@ -0,0 +1,78 @@
-+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
-+; RUN: opt < %s -passes=licm -S | FileCheck %s
+-  QualType TransformTemplateSpecializationType(TypeLocBuilder &TLB,
+-                                               TemplateSpecializationTypeLoc TL,
+-                                               TemplateName Template,
+-                                               CXXScopeSpec &SS);
+-
+   QualType TransformDependentTemplateSpecializationType(
+       TypeLocBuilder &TLB, DependentTemplateSpecializationTypeLoc TL,
+       QualType ObjectType, NamedDecl *UnqualLookup,
+@@ -1315,9 +1310,8 @@
+   ///
+   /// By default, builds the new template name directly. Subclasses may override
+   /// this routine to provide different behavior.
+-  TemplateName RebuildTemplateName(CXXScopeSpec &SS,
+-                                   bool TemplateKW,
+-                                   TemplateDecl *Template);
++  TemplateName RebuildTemplateName(CXXScopeSpec &SS, bool TemplateKW,
++                                   TemplateName Name);
+ 
+   /// Build a new template name given a nested name specifier and the
+   /// name that is referred to as a template.
+@@ -4822,9 +4816,7 @@
+     TemplateName Name, SourceLocation NameLoc, QualType ObjectType,
+     NamedDecl *FirstQualifierInScope, bool AllowInjectedClassName) {
+   if (QualifiedTemplateName *QTN = Name.getAsQualifiedTemplateName()) {
+-    // FIXME: Preserve UsingTemplateName.
+-    TemplateDecl *Template = QTN->getUnderlyingTemplate().getAsTemplateDecl();
+-    assert(Template && "qualified template name must refer to a template");
++    TemplateName UnderlyingName = QTN->getUnderlyingTemplate();
+ 
+     if (QualifierLoc) {
+       QualifierLoc = getDerived().TransformNestedNameSpecifierLoc(
+@@ -4833,20 +4825,22 @@
+         return TemplateName();
+     }
+ 
+-    TemplateDecl *TransTemplate
+-      = cast_or_null<TemplateDecl>(getDerived().TransformDecl(NameLoc,
+-                                                              Template));
+-    if (!TransTemplate)
++    NestedNameSpecifierLoc UnderlyingQualifier;
++    TemplateName NewUnderlyingName = getDerived().TransformTemplateName(
++        UnderlyingQualifier, TemplateKWLoc, UnderlyingName, NameLoc, ObjectType,
++        FirstQualifierInScope, AllowInjectedClassName);
++    if (NewUnderlyingName.isNull())
+       return TemplateName();
++    assert(!UnderlyingQualifier && "unexpected qualifier");
+ 
+     if (!getDerived().AlwaysRebuild() &&
+         QualifierLoc.getNestedNameSpecifier() == QTN->getQualifier() &&
+-        TransTemplate == Template)
++        NewUnderlyingName == UnderlyingName)
+       return Name;
+     CXXScopeSpec SS;
+     SS.Adopt(QualifierLoc);
+     return getDerived().RebuildTemplateName(SS, QTN->hasTemplateKeyword(),
+-                                            TransTemplate);
++                                            NewUnderlyingName);
+   }
+ 
+   if (DependentTemplateName *DTN = Name.getAsDependentTemplateName()) {
+@@ -4874,9 +4868,19 @@
+ 
+   if (SubstTemplateTemplateParmStorage *S =
+           Name.getAsSubstTemplateTemplateParm()) {
++    assert(!QualifierLoc && "Unexpected qualified SubstTemplateTemplateParm");
 +
-+; %fca.0 and %fca.1 should not be hoisted out of the loop because the ramp
-+; function and resume function have different stack frames, so %pointer1 and
-+; %pointer2 have different values before and after @llvm.coro.suspend.
++    NestedNameSpecifierLoc ReplacementQualifierLoc;
++    TemplateName ReplacementName = S->getReplacement();
++    if (NestedNameSpecifier Qualifier = ReplacementName.getQualifier()) {
++      NestedNameSpecifierLocBuilder Builder;
++      Builder.MakeTrivial(SemaRef.Context, Qualifier, NameLoc);
++      ReplacementQualifierLoc = Builder.getWithLocInContext(SemaRef.Context);
++    }
 +
-+define ptr @f(i32 %n) presplitcoroutine {
-+; CHECK-LABEL: define ptr @f(
-+; CHECK-SAME: i32 [[N:%.*]]) #[[ATTR0:[0-9]+]] {
-+; CHECK-NEXT:  [[ENTRY:.*]]:
-+; CHECK-NEXT:    [[POINTER1:%.*]] = alloca ptr, align 8
-+; CHECK-NEXT:    [[POINTER2:%.*]] = alloca ptr, align 8
-+; CHECK-NEXT:    [[ID:%.*]] = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null)
-+; CHECK-NEXT:    [[SIZE:%.*]] = call i32 @llvm.coro.size.i32()
-+; CHECK-NEXT:    [[ALLOC:%.*]] = call ptr @malloc(i32 [[SIZE]])
-+; CHECK-NEXT:    [[HDL:%.*]] = call noalias ptr @llvm.coro.begin(token [[ID]], ptr [[ALLOC]])
-+; CHECK-NEXT:    br label %[[LOOP:.*]]
-+; CHECK:       [[LOOP]]:
-+; CHECK-NEXT:    [[N_VAL:%.*]] = phi i32 [ [[N]], %[[ENTRY]] ], [ [[INC:%.*]], %[[RESUME:.*]] ]
-+; CHECK-NEXT:    [[INC]] = add nsw i32 [[N_VAL]], 1
-+; CHECK-NEXT:    call void @print(i32 [[N_VAL]])
-+; CHECK-NEXT:    [[TMP0:%.*]] = call i8 @llvm.coro.suspend(token none, i1 false)
-+; CHECK-NEXT:    switch i8 [[TMP0]], label %[[SUSPEND_LOOPEXIT:.*]] [
-+; CHECK-NEXT:      i8 0, label %[[RESUME]]
-+; CHECK-NEXT:      i8 1, label %[[CLEANUP:.*]]
-+; CHECK-NEXT:    ]
-+; CHECK:       [[RESUME]]:
-+; CHECK-NEXT:    [[FCA_0:%.*]] = insertvalue [2 x ptr] poison, ptr [[POINTER1]], 0
-+; CHECK-NEXT:    [[FCA_1:%.*]] = insertvalue [2 x ptr] [[FCA_0]], ptr [[POINTER2]], 1
-+; CHECK-NEXT:    call void @foo([2 x ptr] [[FCA_1]])
-+; CHECK-NEXT:    br label %[[LOOP]]
-+; CHECK:       [[CLEANUP]]:
-+; CHECK-NEXT:    [[MEM:%.*]] = call ptr @llvm.coro.free(token [[ID]], ptr [[HDL]])
-+; CHECK-NEXT:    call void @free(ptr [[MEM]])
-+; CHECK-NEXT:    br label %[[SUSPEND:.*]]
-+; CHECK:       [[SUSPEND_LOOPEXIT]]:
-+; CHECK-NEXT:    br label %[[SUSPEND]]
-+; CHECK:       [[SUSPEND]]:
-+; CHECK-NEXT:    [[UNUSED:%.*]] = call i1 @llvm.coro.end(ptr [[HDL]], i1 false, token none)
-+; CHECK-NEXT:    ret ptr [[HDL]]
-+;
-+entry:
-+  %pointer1 = alloca ptr
-+  %pointer2 = alloca ptr
-+  %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null)
-+  %size = call i32 @llvm.coro.size.i32()
-+  %alloc = call ptr @malloc(i32 %size)
-+  %hdl = call noalias ptr @llvm.coro.begin(token %id, ptr %alloc)
-+  br label %loop
+     TemplateName NewName = getDerived().TransformTemplateName(
+-        QualifierLoc, TemplateKWLoc, S->getReplacement(), NameLoc, ObjectType,
+-        FirstQualifierInScope, AllowInjectedClassName);
++        ReplacementQualifierLoc, TemplateKWLoc, ReplacementName, NameLoc,
++        ObjectType, FirstQualifierInScope, AllowInjectedClassName);
+     if (NewName.isNull())
+       return TemplateName();
+     Decl *AssociatedDecl =
+@@ -4892,21 +4896,17 @@
+   assert(!Name.getAsDeducedTemplateName() &&
+          "DeducedTemplateName should not escape partial ordering");
+ 
+-  if (TemplateDecl *Template = Name.getAsTemplateDecl()) {
+-    assert(!QualifierLoc && "missed a Qualified Template");
+-    TemplateDecl *TransTemplate
+-      = cast_or_null<TemplateDecl>(getDerived().TransformDecl(NameLoc,
+-                                                              Template));
+-    if (!TransTemplate)
+-      return TemplateName();
+-
+-    CXXScopeSpec SS;
+-    return getDerived().RebuildTemplateName(SS, /*TemplateKeyword=*/false,
+-                                            TransTemplate);
++  // FIXME: Preserve UsingTemplateName.
++  if (auto *Template = Name.getAsTemplateDecl()) {
++    assert(!QualifierLoc && "Unexpected qualifier");
++    return TemplateName(cast_or_null<TemplateDecl>(
++        getDerived().TransformDecl(NameLoc, Template)));
+   }
+ 
+   if (SubstTemplateTemplateParmPackStorage *SubstPack
+       = Name.getAsSubstTemplateTemplateParmPack()) {
++    assert(!QualifierLoc &&
++           "Unexpected qualified SubstTemplateTemplateParmPack");
+     return getDerived().RebuildTemplateName(
+         SubstPack->getArgumentPack(), SubstPack->getAssociatedDecl(),
+         SubstPack->getIndex(), SubstPack->getFinal());
+@@ -5539,21 +5539,10 @@
+         TLB, TL.castAs<DependentNameTypeLoc>(), /*DeducedTSTContext=*/false,
+         ObjectType, UnqualLookup);
+   }
+-  case TypeLoc::Typedef:
+-  case TypeLoc::TemplateSpecialization:
+-  case TypeLoc::SubstTemplateTypeParm:
+-  case TypeLoc::SubstTemplateTypeParmPack:
+-  case TypeLoc::PackIndexing:
+-  case TypeLoc::Enum:
+-  case TypeLoc::Record:
+-  case TypeLoc::InjectedClassName:
+-  case TypeLoc::TemplateTypeParm:
+-  case TypeLoc::Decltype:
+-  case TypeLoc::UnresolvedUsing:
+-  case TypeLoc::Using:
+-    return getDerived().TransformType(TLB, TL);
+   default:
+-    llvm_unreachable("unexpected type class");
++    // Any dependent canonical type can appear here, through type alias
++    // templates.
++    return getDerived().TransformType(TLB, TL);
+   }
+ }
+ 
+@@ -17515,13 +17504,12 @@
+   return SemaRef.BuildBitIntType(IsUnsigned, NumBitsExpr, Loc);
+ }
+ 
+-template<typename Derived>
+-TemplateName
+-TreeTransform<Derived>::RebuildTemplateName(CXXScopeSpec &SS,
+-                                            bool TemplateKW,
+-                                            TemplateDecl *Template) {
++template <typename Derived>
++TemplateName TreeTransform<Derived>::RebuildTemplateName(CXXScopeSpec &SS,
++                                                         bool TemplateKW,
++                                                         TemplateName Name) {
+   return SemaRef.Context.getQualifiedTemplateName(SS.getScopeRep(), TemplateKW,
+-                                                  TemplateName(Template));
++                                                  Name);
+ }
+ 
+ template <typename Derived>
+diff -ruN --strip-trailing-cr a/clang/test/AST/ast-dump-decl.cpp b/clang/test/AST/ast-dump-decl.cpp
+--- a/clang/test/AST/ast-dump-decl.cpp
++++ b/clang/test/AST/ast-dump-decl.cpp
+@@ -973,5 +973,20 @@
+   // CHECK-NEXT: `-VarDecl 0x{{.+}} <col:25, col:48> col:37 call_init 'const T' constexpr callinit{{$}}
+   // CHECK-NEXT:  `-ParenListExpr 0x{{.+}} <col:46, col:48> 'NULL TYPE'{{$}}
+   // CHECK-NEXT:   `-IntegerLiteral 0x{{.+}} <col:47> 'int' 0{{$}}
+-
+ }
 +
-+loop:
-+  %n.val = phi i32 [ %n, %entry ], [ %inc, %resume ]
-+  %inc = add nsw i32 %n.val, 1
-+  call void @print(i32 %n.val)
-+  %0 = call i8 @llvm.coro.suspend(token none, i1 false)
-+  switch i8 %0, label %suspend [i8 0, label %resume
-+  i8 1, label %cleanup]
++namespace TestInjectedClassName {
++  struct A {
++    using T1 = A;
++    using T2 = A;
++  };
++  // CHECK-LABEL: Dumping TestInjectedClassName:
++  // CHECK:       CXXRecordDecl [[TestInjectedClassName_RD:0x[^ ]+]] {{.*}} struct A definition
++  // CHECK:       CXXRecordDecl {{.*}} implicit referenced struct A
++  // CHECK-NEXT:  |-TypeAliasDecl {{.*}} T1 'A'
++  // CHECK-NEXT:  | `-RecordType [[TestInjectedClassName_RT:0x[^ ]+]] 'A' injected
++  // CHECK-NEXT:  |   `-CXXRecord [[TestInjectedClassName_RD]] 'A'
++  // CHECK-NEXT:  `-TypeAliasDecl {{.*}} T2 'A'
++  // CHECK-NEXT:    `-RecordType [[TestInjectedClassName_RT]] 'A' injected
++  // CHECK-NEXT:      `-CXXRecord [[TestInjectedClassName_RD]] 'A'
++} // namespace InjectedClassName
+diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/cxx20-ctad-type-alias.cpp b/clang/test/SemaCXX/cxx20-ctad-type-alias.cpp
+--- a/clang/test/SemaCXX/cxx20-ctad-type-alias.cpp
++++ b/clang/test/SemaCXX/cxx20-ctad-type-alias.cpp
+@@ -110,10 +110,10 @@
+ 
+ template <typename X, int Y>
+ using Bar = Foo<X, sizeof(X)>; // expected-note {{candidate template ignored: couldn't infer template argument 'X'}} \
+-                               // expected-note {{implicit deduction guide declared as 'template <typename X> requires __is_deducible(test9::Bar, Foo<X, sizeof(X)>) Bar(Foo<X, sizeof(X)>) -> Foo<X, sizeof(X)>'}} \
+-                               // expected-note {{implicit deduction guide declared as 'template <typename X> requires __is_deducible(test9::Bar, Foo<X, sizeof(X)>) Bar(const X (&)[sizeof(X)]) -> Foo<X, sizeof(X)>'}} \
++                               // expected-note {{implicit deduction guide declared as 'template <typename X> requires __is_deducible(test9::Bar, test9::Foo<X, sizeof(X)>) Bar(test9::Foo<X, sizeof(X)>) -> test9::Foo<X, sizeof(X)>'}} \
++                               // expected-note {{implicit deduction guide declared as 'template <typename X> requires __is_deducible(test9::Bar, test9::Foo<X, sizeof(X)>) Bar(const X (&)[sizeof(X)]) -> test9::Foo<X, sizeof(X)>'}} \
+                                // expected-note {{candidate template ignored: constraints not satisfied [with X = int]}} \
+-                               // expected-note {{cannot deduce template arguments for 'Bar' from 'Foo<int, 4UL>'}}
++                               // expected-note {{cannot deduce template arguments for 'test9::Bar' from 'test9::Foo<int, 4UL>'}}
+ 
+ 
+ Bar s = {{1}}; // expected-error {{no viable constructor or deduction guide }}
+@@ -138,13 +138,13 @@
+ struct A {};
+ template<class T> struct Foo { T c; };
+ template<class X, class Y=A>
+-using AFoo = Foo<Y>; // expected-note {{candidate template ignored: could not match 'Foo<Y>' against 'int'}} \
+-                    // expected-note {{implicit deduction guide declared as 'template <class Y = A> requires __is_deducible(test11::AFoo, Foo<Y>) AFoo(Foo<Y>) -> Foo<Y>'}} \
++using AFoo = Foo<Y>; // expected-note {{candidate template ignored: could not match 'test11::Foo<Y>' against 'int'}} \
++                    // expected-note {{implicit deduction guide declared as 'template <class Y = A> requires __is_deducible(test11::AFoo, test11::Foo<Y>) AFoo(test11::Foo<Y>) -> test11::Foo<Y>'}} \
+                     // expected-note {{candidate template ignored: constraints not satisfied [with Y = int]}} \
+-                    // expected-note {{cannot deduce template arguments for 'AFoo' from 'Foo<int>'}} \
+-                    // expected-note {{implicit deduction guide declared as 'template <class Y = A> requires __is_deducible(test11::AFoo, Foo<Y>) AFoo(Y) -> Foo<Y>'}} \
++                    // expected-note {{cannot deduce template arguments for 'test11::AFoo' from 'test11::Foo<int>'}} \
++                    // expected-note {{implicit deduction guide declared as 'template <class Y = A> requires __is_deducible(test11::AFoo, test11::Foo<Y>) AFoo(Y) -> test11::Foo<Y>'}} \
+                     // expected-note {{candidate function template not viable: requires 0 arguments, but 1 was provided}} \
+-                    // expected-note {{implicit deduction guide declared as 'template <class Y = A> requires __is_deducible(test11::AFoo, Foo<Y>) AFoo() -> Foo<Y>'}}
++                    // expected-note {{implicit deduction guide declared as 'template <class Y = A> requires __is_deducible(test11::AFoo, test11::Foo<Y>) AFoo() -> test11::Foo<Y>'}}
+ 
+ AFoo s = {1}; // expected-error {{no viable constructor or deduction guide for deduction of template arguments of 'AFoo'}}
+ } // namespace test11
+@@ -197,8 +197,8 @@
+ template <int K>
+ using Bar = Foo<double, K>; // expected-note {{constraints not satisfied for class template 'Foo'}}
+ // expected-note@-1 {{candidate template ignored: could not match}} expected-note@-1 {{candidate template ignored: constraints not satisfied}}
+-// expected-note@-2 {{implicit deduction guide declared as 'template <int K> requires __is_deducible(test14::Bar, Foo<double, K>) Bar(Foo<double, K>) -> Foo<double, K>'}}
+-// expected-note@-3 {{implicit deduction guide declared as 'template <int K> requires __is_deducible(test14::Bar, Foo<double, K>) Bar(const double (&)[K]) -> Foo<double, K>'}}
++// expected-note@-2 {{implicit deduction guide declared as 'template <int K> requires __is_deducible(test14::Bar, test14::Foo<double, K>) Bar(test14::Foo<double, K>) -> test14::Foo<double, K>'}}
++// expected-note@-3 {{implicit deduction guide declared as 'template <int K> requires __is_deducible(test14::Bar, test14::Foo<double, K>) Bar(const double (&)[K]) -> test14::Foo<double, K>'}}
+ double abc[3];
+ Bar s2 = {abc}; // expected-error {{no viable constructor or deduction guide for deduction }}
+ } // namespace test14
+@@ -212,9 +212,9 @@
+ using BFoo = AFoo<W>; // expected-note {{candidate template ignored: constraints not satisfied [with W = int]}} \
+                       // expected-note@-1 {{because 'int' does not satisfy 'False'}} \
+                       // expected-note@#test15_False {{because 'false' evaluated to false}} \
+-                      // expected-note {{implicit deduction guide declared as 'template <False<> W> requires __is_deducible(AFoo, Foo<W *>) && __is_deducible(test15::BFoo, Foo<W *>) BFoo(W *) -> Foo<W *>}} \
+-                      // expected-note {{candidate template ignored: could not match 'Foo<W *>' against 'int *'}} \
+-                      // expected-note {{template <False<> W> requires __is_deducible(AFoo, Foo<W *>) && __is_deducible(test15::BFoo, Foo<W *>) BFoo(Foo<W *>) -> Foo<W *>}}
++                      // expected-note {{implicit deduction guide declared as 'template <False<> W> requires __is_deducible(test15::AFoo, test15::Foo<W *>) && __is_deducible(test15::BFoo, test15::Foo<W *>) BFoo(W *) -> test15::Foo<W *>}} \
++                      // expected-note {{candidate template ignored: could not match 'test15::Foo<W *>' against 'int *'}} \
++                      // expected-note {{template <False<> W> requires __is_deducible(test15::AFoo, test15::Foo<W *>) && __is_deducible(test15::BFoo, test15::Foo<W *>) BFoo(test15::Foo<W *>) -> test15::Foo<W *>}}
+ int i = 0;
+ AFoo a1(&i); // OK, deduce Foo<int *>
+ 
+@@ -276,12 +276,12 @@
+ Foo(T) -> Foo<int>;
+ 
+ template <typename U>
+-using Bar = Foo<U>; // expected-note {{could not match 'Foo<U>' against 'int'}} \
+-                    // expected-note {{implicit deduction guide declared as 'template <typename U> requires __is_deducible(test18::Bar, Foo<U>) Bar(Foo<U>) -> Foo<U>'}} \
++using Bar = Foo<U>; // expected-note {{could not match 'test18::Foo<U>' against 'int'}} \
++                    // expected-note {{implicit deduction guide declared as 'template <typename U> requires __is_deducible(test18::Bar, test18::Foo<U>) Bar(test18::Foo<U>) -> test18::Foo<U>'}} \
+                     // expected-note {{candidate template ignored: constraints not satisfied}} \
+                     // expected-note {{implicit deduction guide declared as 'template <typename T> requires False<T> && __is_deducible(test18::Bar, Foo<int>) Bar(T) -> Foo<int>'}} \
+                     // expected-note {{candidate function template not viable}} \
+-                    // expected-note {{implicit deduction guide declared as 'template <typename U> requires __is_deducible(test18::Bar, Foo<U>) Bar() -> Foo<U>'}}
++                    // expected-note {{implicit deduction guide declared as 'template <typename U> requires __is_deducible(test18::Bar, test18::Foo<U>) Bar() -> test18::Foo<U>'}}
+ 
+ Bar s = {1}; // expected-error {{no viable constructor or deduction guide for deduction of template arguments}}
+ } // namespace test18
+@@ -309,8 +309,8 @@
+ // Verify that template template type parameter TTP is referenced/used in the
+ // template arguments of the RHS.
+ template <template<typename> typename TTP>
+-using Bar = Foo<K<TTP>>; // expected-note {{candidate template ignored: could not match 'Foo<K<TTP>>' against 'int'}} \
+-                        // expected-note {{implicit deduction guide declared as 'template <template <typename> typename TTP> requires __is_deducible(test20::Bar, Foo<K<TTP>>) Bar(Foo<K<TTP>>) -> Foo<K<TTP>>'}}
++using Bar = Foo<K<TTP>>; // expected-note {{candidate template ignored: could not match 'test20::Foo<K<TTP>>' against 'int'}} \
++                        // expected-note {{implicit deduction guide declared as 'template <template <typename> typename TTP> requires __is_deducible(test20::Bar, test20::Foo<K<TTP>>) Bar(test20::Foo<K<TTP>>) -> test20::Foo<K<TTP>>'}}
+ 
+ template <class T>
+ class Container {};
+@@ -463,7 +463,7 @@
+ BB b{0, 1};
+ // expected-error@-1 {{no viable}}
+ // expected-note@#test25_BB 2{{not viable}}
+-// expected-note@#test25_BB {{template <typename ...US, typename V> requires __is_same(V, int) && __is_deducible(AA, A<int, US...>) && __is_deducible(test25::BB, A<int, US...>) BB(V) -> A<int, US...>}}
++// expected-note@#test25_BB {{template <typename ...US, typename V> requires __is_same(V, int) && __is_deducible(test25::AA, test25::A<int, US...>) && __is_deducible(test25::BB, test25::A<int, US...>) BB(V) -> test25::A<int, US...>}}
+ // expected-note@#test25_BB {{implicit deduction guide}}
+ 
+ }
+diff -ruN --strip-trailing-cr a/clang/test/SemaTemplate/deduction-guide.cpp b/clang/test/SemaTemplate/deduction-guide.cpp
+--- a/clang/test/SemaTemplate/deduction-guide.cpp
++++ b/clang/test/SemaTemplate/deduction-guide.cpp
+@@ -331,7 +331,7 @@
+ // CHECK-NEXT:  |-InjectedClassNameType {{.+}} 'TTP::B<T>' dependent{{$}}
+ // CHECK-NEXT:  | `-CXXRecord {{.+}} 'B'{{$}}
+ // CHECK-NEXT:  `-TemplateSpecializationType {{.+}} 'TT<T>' dependent{{$}}
+-// CHECK-NEXT:    |-name: 'TT':'template-parameter-0-1' qualified
++// CHECK-NEXT:    |-name: 'TT':'template-parameter-0-1'
+ // CHECK-NEXT:    | `-TemplateTemplateParmDecl {{.+}} depth 0 index 1
+ // CHECK-NEXT:    `-TemplateArgument type 'T':'type-parameter-0-0'{{$}}
+ // CHECK-NEXT:      `-TemplateTypeParmType {{.+}} 'T' dependent depth 0 index 0{{$}}
+@@ -673,8 +673,8 @@
+ // CHECK-NEXT: | |-DeducedTemplateSpecializationType {{.*}} 'GH122134::Test' dependent
+ // CHECK-NEXT: | | `-name: 'GH122134::Test'
+ // CHECK-NEXT: | |   `-TypeAliasTemplateDecl {{.*}} Test
+-// CHECK-NEXT: | `-TemplateSpecializationType {{.*}} 'Struct<int, N>' dependent
+-// CHECK-NEXT: |   |-name: 'Struct':'GH122134::Struct' qualified
++// CHECK-NEXT: | `-TemplateSpecializationType {{.*}} 'GH122134::Struct<int, N>' dependent
++// CHECK-NEXT: |   |-name: 'GH122134::Struct'
+ // CHECK-NEXT: |   | `-ClassTemplateDecl {{.*}} Struct
+ // CHECK-NEXT: |   |-TemplateArgument type 'int'
+ // CHECK-NEXT: |   | `-SubstTemplateTypeParmType {{.*}} 'int' sugar class depth 0 index 0 T
+@@ -684,7 +684,7 @@
+ // CHECK-NEXT: |     `-SubstNonTypeTemplateParmExpr {{.*}} 'int'
+ // CHECK-NEXT: |       |-NonTypeTemplateParmDecl {{.*}} 'int' depth 0 index 1
+ // CHECK-NEXT: |       `-DeclRefExpr {{.*}} 'int' NonTypeTemplateParm {{.*}} 'N' 'int'
+-// CHECK-NEXT: |-CXXDeductionGuideDecl {{.*}} implicit <deduction guide for Test> 'auto (auto:1) -> Struct<int, N>'
++// CHECK-NEXT: |-CXXDeductionGuideDecl {{.*}} implicit <deduction guide for Test> 'auto (auto:1) -> GH122134::Struct<int, N>'
+ // CHECK-NEXT: | `-ParmVarDecl {{.*}} 'auto:1'
+ 
+ } // namespace GH122134
+@@ -792,16 +792,16 @@
+ // CHECK-NEXT:  | |-DeducedTemplateSpecializationType {{.+}} 'GH133132::AA' dependent
+ // CHECK-NEXT:  | | `-name: 'GH133132::AA'
+ // CHECK-NEXT:  | |   `-TypeAliasTemplateDecl {{.+}} AA
+-// CHECK-NEXT:  | `-TemplateSpecializationType {{.+}} 'A<U>' dependent
+-// CHECK-NEXT:  |   |-name: 'A':'GH133132::A' qualified
++// CHECK-NEXT:  | `-TemplateSpecializationType {{.+}} 'GH133132::A<U>' dependent
++// CHECK-NEXT:  |   |-name: 'GH133132::A'
+ // CHECK-NEXT:  |   | `-ClassTemplateDecl {{.+}} A
+ // CHECK-NEXT:  |   `-TemplateArgument type 'U':'type-parameter-0-1'
+ // CHECK-NEXT:  |     `-SubstTemplateTypeParmType {{.+}} 'U' sugar dependent class depth 0 index 0 _Ty
+ // CHECK-NEXT:  |       |-FunctionTemplate {{.+}} '<deduction guide for A>'
+ // CHECK-NEXT:  |       `-TemplateTypeParmType {{.+}} 'U' dependent depth 0 index 1
+ // CHECK-NEXT:  |         `-TemplateTypeParm {{.+}} 'U'
+-// CHECK-NEXT:  |-CXXDeductionGuideDecl {{.+}} implicit <deduction guide for AA> 'auto () -> A<U>'
+-// CHECK-NEXT:  `-CXXDeductionGuideDecl {{.+}} implicit used <deduction guide for AA> 'auto () -> A<int>' implicit_instantiation
++// CHECK-NEXT:  |-CXXDeductionGuideDecl {{.+}} implicit <deduction guide for AA> 'auto () -> GH133132::A<U>'
++// CHECK-NEXT:  `-CXXDeductionGuideDecl {{.+}} implicit used <deduction guide for AA> 'auto () -> GH133132::A<int>' implicit_instantiation
+ // CHECK-NEXT:    |-TemplateArgument type 'int'
+ // CHECK-NEXT:    | `-BuiltinType {{.+}} 'int'
+ // CHECK-NEXT:    `-TemplateArgument type 'int'
+@@ -823,22 +823,22 @@
+ // CHECK-NEXT:  |   `-ClassTemplateDecl {{.+}} A
+ // CHECK-NEXT:  |-TemplateTemplateParmDecl {{.+}} depth 0 index 1 _Y
+ // CHECK-NEXT:  | |-TemplateTypeParmDecl {{.+}} class depth 0 index 0
+-// CHECK-NEXT:  | `-TemplateArgument {{.+}} template '_X':'template-parameter-0-0' qualified
++// CHECK-NEXT:  | `-TemplateArgument {{.+}} template '_X':'template-parameter-0-0'
+ // CHECK-NEXT:  |   `-TemplateTemplateParmDecl {{.+}} depth 0 index 0 _X
+ // CHECK-NEXT:  |-TypeTraitExpr {{.+}} 'bool' __is_deducible
+ // CHECK-NEXT:  | |-DeducedTemplateSpecializationType {{.+}} 'GH133132::BB' dependent
+ // CHECK-NEXT:  | | `-name: 'GH133132::BB'
+ // CHECK-NEXT:  | |   `-TypeAliasTemplateDecl {{.+}} BB
+-// CHECK-NEXT:  | `-TemplateSpecializationType {{.+}} 'B<_Y>' dependent
+-// CHECK-NEXT:  |   |-name: 'B':'GH133132::B' qualified
++// CHECK-NEXT:  | `-TemplateSpecializationType {{.+}} 'GH133132::B<_Y>' dependent
++// CHECK-NEXT:  |   |-name: 'GH133132::B'
+ // CHECK-NEXT:  |   | `-ClassTemplateDecl {{.+}} B
+ // CHECK-NEXT:  |   `-TemplateArgument template '_Y':'template-parameter-0-1' subst index 0
+ // CHECK-NEXT:  |     |-parameter: TemplateTemplateParmDecl {{.+}} depth 0 index 0 _X
+ // CHECK-NEXT:  |     |-associated FunctionTemplate {{.+}} '<deduction guide for B>'
+-// CHECK-NEXT:  |     `-replacement: '_Y':'template-parameter-0-1' qualified
++// CHECK-NEXT:  |     `-replacement: '_Y':'template-parameter-0-1'
+ // CHECK-NEXT:  |       `-TemplateTemplateParmDecl {{.+}} depth 0 index 1 _Y
+-// CHECK-NEXT:  |-CXXDeductionGuideDecl {{.+}} implicit <deduction guide for BB> 'auto () -> B<_Y>'
+-// CHECK-NEXT:  `-CXXDeductionGuideDecl {{.+}} implicit used <deduction guide for BB> 'auto () -> B<GH133132::A>' implicit_instantiation
++// CHECK-NEXT:  |-CXXDeductionGuideDecl {{.+}} implicit <deduction guide for BB> 'auto () -> GH133132::B<_Y>'
++// CHECK-NEXT:  `-CXXDeductionGuideDecl {{.+}} implicit used <deduction guide for BB> 'auto () -> GH133132::B<GH133132::A>' implicit_instantiation
+ // CHECK-NEXT:    |-TemplateArgument template 'GH133132::A'
+ // CHECK-NEXT:    | `-ClassTemplateDecl {{.+}} A
+ // CHECK-NEXT:    `-TemplateArgument template 'GH133132::A'
+@@ -866,16 +866,16 @@
+ // CHECK-NEXT:  | |-DeducedTemplateSpecializationType {{.+}} 'GH133132::CC' dependent
+ // CHECK-NEXT:  | | `-name: 'GH133132::CC'
+ // CHECK-NEXT:  | |   `-TypeAliasTemplateDecl {{.+}} CC
+-// CHECK-NEXT:  | `-TemplateSpecializationType {{.+}} 'A<U>' dependent
+-// CHECK-NEXT:  |   |-name: 'A':'GH133132::A' qualified
++// CHECK-NEXT:  | `-TemplateSpecializationType {{.+}} 'GH133132::A<U>' dependent
++// CHECK-NEXT:  |   |-name: 'GH133132::A'
+ // CHECK-NEXT:  |   | `-ClassTemplateDecl {{.+}} A
+ // CHECK-NEXT:  |   `-TemplateArgument type 'U':'type-parameter-0-1'
+ // CHECK-NEXT:  |     `-SubstTemplateTypeParmType {{.+}} 'U' sugar dependent class depth 0 index 0 _Ty
+ // CHECK-NEXT:  |       |-FunctionTemplate {{.+}} '<deduction guide for A>'
+ // CHECK-NEXT:  |       `-TemplateTypeParmType {{.+}} 'U' dependent depth 0 index 1
+ // CHECK-NEXT:  |         `-TemplateTypeParm {{.+}} 'U'
+-// CHECK-NEXT:  |-CXXDeductionGuideDecl {{.+}} implicit <deduction guide for CC> 'auto () -> A<U>'
+-// CHECK-NEXT:  `-CXXDeductionGuideDecl {{.+}} implicit used <deduction guide for CC> 'auto () -> A<GH133132::A<int>>' implicit_instantiation
++// CHECK-NEXT:  |-CXXDeductionGuideDecl {{.+}} implicit <deduction guide for CC> 'auto () -> GH133132::A<U>'
++// CHECK-NEXT:  `-CXXDeductionGuideDecl {{.+}} implicit used <deduction guide for CC> 'auto () -> GH133132::A<GH133132::A<int>>' implicit_instantiation
+ // CHECK-NEXT:    |-TemplateArgument integral '42'
+ // CHECK-NEXT:    `-TemplateArgument type 'GH133132::A<int>'
+ // CHECK-NEXT:      `-RecordType {{.+}} 'GH133132::A<int>'
+@@ -949,8 +949,8 @@
+ // CHECK-NEXT:   | |-DeducedTemplateSpecializationType {{.+}} 'GH141425::Alias' dependent
+ // CHECK-NEXT:   | | `-name: 'GH141425::Alias'
+ // CHECK-NEXT:   | |   `-TypeAliasTemplateDecl {{.+}} Alias
+-// CHECK-NEXT:   | `-TemplateSpecializationType {{.+}} 'Container<T...>' dependent
+-// CHECK-NEXT:   |   |-name: 'Container':'GH141425::Container' qualified
++// CHECK-NEXT:   | `-TemplateSpecializationType {{.+}} 'GH141425::Container<T...>' dependent
++// CHECK-NEXT:   |   |-name: 'GH141425::Container'
+ // CHECK-NEXT:   |   | `-ClassTemplateDecl {{.+}} Container
+ // CHECK-NEXT:   |   `-TemplateArgument type 'T...':'type-parameter-0-0...'
+ // CHECK-NEXT:   |     `-PackExpansionType {{.+}} 'T...' dependent
+@@ -958,7 +958,7 @@
+ // CHECK-NEXT:   |         |-FunctionTemplate {{.+}} '<deduction guide for Container>'
+ // CHECK-NEXT:   |         `-TemplateTypeParmType {{.+}} 'T' dependent contains_unexpanded_pack depth 0 index 0 pack
+ // CHECK-NEXT:   |           `-TemplateTypeParm {{.+}} 'T'
+-// CHECK-NEXT:   |-CXXDeductionGuideDecl {{.+}} implicit <deduction guide for Alias> 'auto (T...) -> Container<T...>'
++// CHECK-NEXT:   |-CXXDeductionGuideDecl {{.+}} implicit <deduction guide for Alias> 'auto (T...) -> GH141425::Container<T...>'
+ // CHECK-NEXT:   | `-ParmVarDecl {{.+}} 'T...' pack
+ 
+ }
+diff -ruN --strip-trailing-cr a/clang/test/SemaTemplate/nested-name-spec-template.cpp b/clang/test/SemaTemplate/nested-name-spec-template.cpp
+--- a/clang/test/SemaTemplate/nested-name-spec-template.cpp
++++ b/clang/test/SemaTemplate/nested-name-spec-template.cpp
+@@ -1,5 +1,5 @@
+ // RUN: %clang_cc1 -fsyntax-only -verify %s -Wno-c++20-extensions
+-// RUN: %clang_cc1 -fsyntax-only -verify -std=c++98 %s
++// RUN: %clang_cc1 -fsyntax-only -verify -Wno-c++11-extensions -std=c++98 %s
+ // RUN: %clang_cc1 -fsyntax-only -verify -std=c++11 %s
+ 
+ namespace N {
+@@ -24,14 +24,7 @@
+ 
+   M::Promote<int>::type *ret_intptr3(int* ip) { return ip; }
+   M::template Promote<int>::type *ret_intptr4(int* ip) { return ip; }
+-#if __cplusplus <= 199711L
+-  // expected-warning@-2 {{'template' keyword outside of a template}}
+-#endif
+-
+   M::template Promote<int> pi;
+-#if __cplusplus <= 199711L
+-  // expected-warning@-2 {{'template' keyword outside of a template}}
+-#endif
+ }
+ 
+ N::M::Promote<int>::type *ret_intptr5(int* ip) { return ip; }
+@@ -181,3 +174,39 @@
+   template void f<B>();
+ } // namespace SubstTemplateTypeParmPackType
+ #endif
 +
-+resume:
-+  %fca.0 = insertvalue [2 x ptr] poison, ptr %pointer1, 0
-+  %fca.1 = insertvalue [2 x ptr] %fca.0, ptr %pointer2, 1
-+  call void @foo([2 x ptr] %fca.1)
-+  br label %loop
++namespace DependentUnaryTransform {
++  template <class T> using decay_t = __decay(T);
++  template <class, class> struct A;
++  template <class T> struct A<T, typename decay_t<T>::X>;
++} // namespace DependentUnaryTransform
 +
-+cleanup:
-+  %mem = call ptr @llvm.coro.free(token %id, ptr %hdl)
-+  call void @free(ptr %mem)
-+  br label %suspend
-+suspend:
-+  %unused = call i1 @llvm.coro.end(ptr %hdl, i1 false, token none)
-+  ret ptr %hdl
-+}
++namespace DependentSizedArray {
++  template <int V> using Z = int[V];
++  template <class, class> struct A;
++  template <class T> struct A<T, typename Z<T(0)>::X>;
++} // namespace DependentUnaryTransform
 +
-+declare void @free(ptr)
-+declare ptr @malloc(i32)
-+declare void @print(i32)
-+declare void @foo([2 x ptr])
-diff -ruN --strip-trailing-cr a/mlir/test/Dialect/Linalg/linalg-morph-category-ops.mlir b/mlir/test/Dialect/Linalg/linalg-morph-category-ops.mlir
---- a/mlir/test/Dialect/Linalg/linalg-morph-category-ops.mlir
-+++ b/mlir/test/Dialect/Linalg/linalg-morph-category-ops.mlir
-@@ -2,7 +2,7 @@
- // RUN: mlir-opt %s -linalg-morph-ops=named-to-category | FileCheck %s  --check-prefix=NAMED_TO_CATEGORY
- 
- // RUN: mlir-opt %s -linalg-morph-ops=named-to-category |  \
--// RUN:   mlir-opt %s -linalg-morph-ops=category-to-generic | FileCheck %s  --check-prefix=CATEGORY_TO_GENERIC
-+// RUN:   mlir-opt -linalg-morph-ops=category-to-generic | FileCheck %s  --check-prefix=CATEGORY_TO_GENERIC
- 
- func.func @exp(%A : tensor<16x8xf32>, %B : tensor<16x8xf32>) ->  tensor<16x8xf32> {
-   %exp = linalg.exp ins(%A : tensor<16x8xf32>) outs(%B :  tensor<16x8xf32>) -> tensor<16x8xf32>
++namespace GH155281 {
++  template <bool> struct enable_if;
++  template <class _Tp, _Tp> struct integral_constant;
++  template <typename> struct conjunction;
++  template <typename T> using value_type_t = T;
++  template <class Check> using require_t = typename enable_if<Check::value>::type;
++  template <template <class> class, template <class> class,
++            template <class> class, class... Check>
++  using container_type_check_base =
++      integral_constant<bool, conjunction<Check...>::value>;
++  template <typename> struct is_std_vector;
++  template <template <class> class TypeCheck, class... Check>
++  using require_std_vector_vt =
++      require_t<container_type_check_base<is_std_vector, value_type_t, TypeCheck,
++                                          Check...> >;
++  template <typename, typename> class vector_seq_view;
++  namespace internal {
++  template <typename> using is_matrix_or_std_vector = int;
++  }
++  template <typename T>
++  class vector_seq_view<
++      T, require_std_vector_vt<internal::is_matrix_or_std_vector, T> >;
++} // namespace GH155281
diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl
index e54cc0d..f8e156d 100644
--- a/third_party/llvm/workspace.bzl
+++ b/third_party/llvm/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive")
 
 def repo(name):
     """Imports LLVM."""
-    LLVM_COMMIT = "fc44a4fcd3c54be927c15ddd9211aca1501633e7"
-    LLVM_SHA256 = "d228aebe5583c69c4e48fd7a8e149e3d22ee6dafaeae94009467143d32d9bfc4"
+    LLVM_COMMIT = "a579278312f8c95d0a68e8af7d98f14240bf6e7f"
+    LLVM_SHA256 = "3a1819ab470cfab8ae576e71ae991b3b85621c7bb84e240039d93df5455d3abe"
 
     tf_http_archive(
         name = name,
