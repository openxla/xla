diff --git a/shardy/tools/BUILD b/shardy/tools/BUILD
index a51ddd0..5cfc1ec 100644
--- a/shardy/tools/BUILD
+++ b/shardy/tools/BUILD
@@ -51,5 +51,6 @@ cc_binary(
         "@llvm-project//mlir:IR",
         "@llvm-project//mlir:MlirOptLib",
         "@llvm-project//mlir:QuantOps",
+        "@llvm-project//mlir:RegisterAllPasses",
     ],
 )
diff --git a/third_party/llvm/generated.patch b/third_party/llvm/generated.patch
index d7acb4c..0c4690e 100644
--- a/third_party/llvm/generated.patch
+++ b/third_party/llvm/generated.patch
@@ -1,743 +1,1414 @@
 Auto generated patch. Do not edit or delete it, even if empty.
-diff -ruN --strip-trailing-cr a/clang/lib/Sema/AnalysisBasedWarnings.cpp b/clang/lib/Sema/AnalysisBasedWarnings.cpp
---- a/clang/lib/Sema/AnalysisBasedWarnings.cpp
-+++ b/clang/lib/Sema/AnalysisBasedWarnings.cpp
-@@ -503,8 +503,12 @@
- 
-   TransferFunctions TF(VD);
-   BackwardDataflowWorklist Worklist(*AC.getCFG(), AC);
-+  llvm::DenseSet<const CFGBlock *> Visited;
-   Worklist.enqueueBlock(&VarBlk);
-   while (const CFGBlock *B = Worklist.dequeue()) {
-+    if (Visited.contains(B))
-+      continue;
-+    Visited.insert(B);
-     // First check the current block.
-     for (CFGBlock::const_reverse_iterator ri = B->rbegin(), re = B->rend();
-          ri != re; ++ri) {
-diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/noreturn-weverything.c b/clang/test/SemaCXX/noreturn-weverything.c
---- a/clang/test/SemaCXX/noreturn-weverything.c
-+++ b/clang/test/SemaCXX/noreturn-weverything.c
-@@ -0,0 +1,15 @@
-+// RUN: %clang_cc1 -fsyntax-only %s -Weverything
+diff -ruN --strip-trailing-cr a/libcxx/include/__tree b/libcxx/include/__tree
+--- a/libcxx/include/__tree
++++ b/libcxx/include/__tree
+@@ -1445,8 +1445,8 @@
+ 
+   *__root_ptr()       = static_cast<__node_base_pointer>(__copy_construct_tree(__t.__root()));
+   __root()->__parent_ = __end_node();
+-  __begin_node_ = static_cast<__end_node_pointer>(std::__tree_min(static_cast<__node_base_pointer>(__end_node())));
+-  __size_       = __t.size();
++  __begin_node_       = static_cast<__end_node_pointer>(std::__tree_min(__end_node()->__left_));
++  __size_             = __t.size();
+ }
+ 
+ template <class _Tp, class _Compare, class _Allocator>
+diff -ruN --strip-trailing-cr a/lldb/include/lldb/Host/JSONTransport.h b/lldb/include/lldb/Host/JSONTransport.h
+--- a/lldb/include/lldb/Host/JSONTransport.h
++++ b/lldb/include/lldb/Host/JSONTransport.h
+@@ -13,16 +13,13 @@
+ #ifndef LLDB_HOST_JSONTRANSPORT_H
+ #define LLDB_HOST_JSONTRANSPORT_H
+ 
+-#include "lldb/Host/MainLoopBase.h"
+ #include "lldb/lldb-forward.h"
+-#include "llvm/ADT/FunctionExtras.h"
+ #include "llvm/ADT/StringRef.h"
+ #include "llvm/Support/Error.h"
+ #include "llvm/Support/FormatVariadic.h"
+ #include "llvm/Support/JSON.h"
+-#include <string>
++#include <chrono>
+ #include <system_error>
+-#include <vector>
+ 
+ namespace lldb_private {
+ 
+@@ -31,33 +28,27 @@
+   static char ID;
+ 
+   TransportEOFError() = default;
+-  void log(llvm::raw_ostream &OS) const override { OS << "transport EOF"; }
 +
-+void free(void *);
-+typedef void (*set_free_func)(void *);
-+struct Method {
-+  int nparams;
-+  int *param;
-+};
-+void selelem_free_method(struct Method* method, void* data) {
-+    set_free_func free_func = 0;
-+    for (int i = 0; i < method->nparams; ++i)
-+        free(&method->param[i]);
-+    if (data && free_func)
-+        free_func(data);
-+}
-diff -ruN --strip-trailing-cr a/llvm/include/llvm/MC/MCObjectStreamer.h b/llvm/include/llvm/MC/MCObjectStreamer.h
---- a/llvm/include/llvm/MC/MCObjectStreamer.h
-+++ b/llvm/include/llvm/MC/MCObjectStreamer.h
-@@ -52,10 +52,6 @@
-   DenseMap<const MCSymbol *, SmallVector<PendingAssignment, 1>>
-       pendingAssignments;
- 
--  SmallVector<std::unique_ptr<char[]>, 0> FragStorage;
--  // Available bytes in the current block for trailing data or new fragments.
--  size_t FragSpace = 0;
--
-   void emitInstToData(const MCInst &Inst, const MCSubtargetInfo &);
-   void emitCFIStartProcImpl(MCDwarfFrameInfo &Frame) override;
-   void emitCFIEndProcImpl(MCDwarfFrameInfo &Frame) override;
-@@ -88,18 +84,11 @@
-   // Add a fragment with a variable-size tail and start a new empty fragment.
-   void insert(MCFragment *F);
- 
--  char *getCurFragEnd() const {
--    return reinterpret_cast<char *>(CurFrag + 1) + CurFrag->getFixedSize();
--  }
--  MCFragment *allocFragSpace(size_t Headroom);
-   // Add a new fragment to the current section without a variable-size tail.
-   void newFragment();
- 
--  void ensureHeadroom(size_t Headroom);
-   void appendContents(ArrayRef<char> Contents);
-   void appendContents(size_t Num, char Elt);
--  // Add a fixup to the current fragment. Call ensureHeadroom beforehand to
--  // ensure the fixup and appended content apply to the same fragment.
-   void addFixup(const MCExpr *Value, MCFixupKind Kind);
- 
-   void emitLabel(MCSymbol *Symbol, SMLoc Loc = SMLoc()) override;
-diff -ruN --strip-trailing-cr a/llvm/include/llvm/MC/MCSection.h b/llvm/include/llvm/MC/MCSection.h
---- a/llvm/include/llvm/MC/MCSection.h
-+++ b/llvm/include/llvm/MC/MCSection.h
-@@ -93,7 +93,8 @@
-   // Track content and fixups for the fixed-size part as fragments are
-   // appended to the section. The content remains immutable, except when
-   // modified by applyFixup.
--  uint32_t FixedSize = 0;
-+  uint32_t ContentStart = 0;
-+  uint32_t ContentEnd = 0;
-   uint32_t FixupStart = 0;
-   uint32_t FixupEnd = 0;
- 
-@@ -187,6 +188,18 @@
-   //== Content-related functions manage parent's storage using ContentStart and
-   // ContentSize.
- 
-+  // Get a SmallVector reference. The caller should call doneAppending to update
-+  // `ContentEnd`.
-+  SmallVectorImpl<char> &getContentsForAppending();
-+  void doneAppending();
-+  void appendContents(ArrayRef<char> Contents) {
-+    getContentsForAppending().append(Contents.begin(), Contents.end());
-+    doneAppending();
++  void log(llvm::raw_ostream &OS) const override {
++    OS << "transport end of file reached";
 +  }
-+  void appendContents(size_t Num, char Elt) {
-+    getContentsForAppending().append(Num, Elt);
-+    doneAppending();
-+  }
-   MutableArrayRef<char> getContents();
-   ArrayRef<char> getContents() const;
- 
-@@ -195,10 +208,10 @@
-   MutableArrayRef<char> getVarContents();
-   ArrayRef<char> getVarContents() const;
- 
--  size_t getFixedSize() const { return FixedSize; }
-+  size_t getFixedSize() const { return ContentEnd - ContentStart; }
-   size_t getVarSize() const { return VarContentEnd - VarContentStart; }
-   size_t getSize() const {
--    return FixedSize + (VarContentEnd - VarContentStart);
-+    return ContentEnd - ContentStart + (VarContentEnd - VarContentStart);
+   std::error_code convertToErrorCode() const override {
+-    return std::make_error_code(std::errc::io_error);
++    return llvm::inconvertibleErrorCode();
    }
+ };
  
-   //== Fixup-related functions manage parent's storage using FixupStart and
-@@ -621,11 +634,28 @@
-   bool isBssSection() const { return IsBss; }
+-class TransportUnhandledContentsError
+-    : public llvm::ErrorInfo<TransportUnhandledContentsError> {
++class TransportTimeoutError : public llvm::ErrorInfo<TransportTimeoutError> {
+ public:
+   static char ID;
+ 
+-  explicit TransportUnhandledContentsError(std::string unhandled_contents)
+-      : m_unhandled_contents(unhandled_contents) {}
++  TransportTimeoutError() = default;
+ 
+   void log(llvm::raw_ostream &OS) const override {
+-    OS << "transport EOF with unhandled contents " << m_unhandled_contents;
++    OS << "transport operation timed out";
+   }
+   std::error_code convertToErrorCode() const override {
+-    return std::make_error_code(std::errc::bad_message);
++    return std::make_error_code(std::errc::timed_out);
+   }
+-
+-  const std::string &getUnhandledContents() const {
+-    return m_unhandled_contents;
+-  }
+-
+-private:
+-  std::string m_unhandled_contents;
  };
  
-+inline SmallVectorImpl<char> &MCFragment::getContentsForAppending() {
-+  SmallVectorImpl<char> &S = getParent()->ContentStorage;
-+  if (LLVM_UNLIKELY(ContentEnd != S.size())) {
-+    // Move the elements to the end. Reserve space to avoid invalidating
-+    // S.begin()+I for `append`.
-+    auto Size = ContentEnd - ContentStart;
-+    auto I = std::exchange(ContentStart, S.size());
-+    S.reserve(S.size() + Size);
-+    S.append(S.begin() + I, S.begin() + I + Size);
-+  }
-+  return S;
-+}
-+inline void MCFragment::doneAppending() {
-+  ContentEnd = getParent()->ContentStorage.size();
-+}
- inline MutableArrayRef<char> MCFragment::getContents() {
--  return {reinterpret_cast<char *>(this + 1), FixedSize};
-+  return MutableArrayRef(getParent()->ContentStorage)
-+      .slice(ContentStart, ContentEnd - ContentStart);
- }
- inline ArrayRef<char> MCFragment::getContents() const {
--  return {reinterpret_cast<const char *>(this + 1), FixedSize};
-+  return ArrayRef(getParent()->ContentStorage)
-+      .slice(ContentStart, ContentEnd - ContentStart);
- }
+ class TransportInvalidError : public llvm::ErrorInfo<TransportInvalidError> {
+@@ -77,11 +68,6 @@
+ /// A transport class that uses JSON for communication.
+ class JSONTransport {
+ public:
+-  using ReadHandleUP = MainLoopBase::ReadHandleUP;
+-  template <typename T>
+-  using Callback =
+-      llvm::unique_function<void(MainLoopBase &, const llvm::Expected<T>)>;
+-
+   JSONTransport(lldb::IOObjectSP input, lldb::IOObjectSP output);
+   virtual ~JSONTransport() = default;
  
- inline MutableArrayRef<char> MCFragment::getVarContents() {
-diff -ruN --strip-trailing-cr a/llvm/lib/MC/MCObjectStreamer.cpp b/llvm/lib/MC/MCObjectStreamer.cpp
---- a/llvm/lib/MC/MCObjectStreamer.cpp
-+++ b/llvm/lib/MC/MCObjectStreamer.cpp
-@@ -46,83 +46,27 @@
-   return nullptr;
- }
+@@ -97,69 +83,24 @@
+     return WriteImpl(message);
+   }
  
--constexpr size_t FragBlockSize = 16384;
--// Ensure the new fragment can at least store a few bytes.
--constexpr size_t NewFragHeadroom = 8;
+-  /// Registers the transport with the MainLoop.
++  /// Reads the next message from the input stream.
+   template <typename T>
+-  llvm::Expected<ReadHandleUP> RegisterReadObject(MainLoopBase &loop,
+-                                                  Callback<T> callback) {
+-    Status error;
+-    ReadHandleUP handle = loop.RegisterReadObject(
+-        m_input,
+-        [&](MainLoopBase &loop) {
+-          char buffer[kReadBufferSize];
+-          size_t len = sizeof(buffer);
+-          if (llvm::Error error = m_input->Read(buffer, len).takeError()) {
+-            callback(loop, std::move(error));
+-            return;
+-          }
 -
--static_assert(NewFragHeadroom >= alignof(MCFragment));
--static_assert(FragBlockSize >= sizeof(MCFragment) + NewFragHeadroom);
+-          if (len)
+-            m_buffer.append(std::string(buffer, len));
 -
--MCFragment *MCObjectStreamer::allocFragSpace(size_t Headroom) {
--  auto Size = std::max(FragBlockSize, sizeof(MCFragment) + Headroom);
--  FragSpace = Size - sizeof(MCFragment);
--  auto Chunk = std::unique_ptr<char[]>(new char[Size]);
--  auto *F = reinterpret_cast<MCFragment *>(Chunk.get());
--  FragStorage.push_back(std::move(Chunk));
--  return F;
--}
+-          // If the buffer has contents, try parsing any pending messages.
+-          if (!m_buffer.empty()) {
+-            llvm::Expected<std::vector<std::string>> messages = Parse();
+-            if (llvm::Error error = messages.takeError()) {
+-              callback(loop, std::move(error));
+-              return;
+-            }
 -
- void MCObjectStreamer::newFragment() {
--  MCFragment *F;
--  if (LLVM_LIKELY(sizeof(MCFragment) + NewFragHeadroom <= FragSpace)) {
--    auto End = reinterpret_cast<size_t>(getCurFragEnd());
--    F = reinterpret_cast<MCFragment *>(
--        alignToPowerOf2(End, alignof(MCFragment)));
--    FragSpace -= size_t(F) - End + sizeof(MCFragment);
--  } else {
--    F = allocFragSpace(0);
+-            for (const auto &message : *messages)
+-              if constexpr (std::is_same<T, std::string>::value)
+-                callback(loop, message);
+-              else
+-                callback(loop, llvm::json::parse<T>(message));
+-          }
+-
+-          // On EOF, notify the callback after the remaining messages were
+-          // handled.
+-          if (len == 0) {
+-            if (m_buffer.empty())
+-              callback(loop, llvm::make_error<TransportEOFError>());
+-            else
+-              callback(loop, llvm::make_error<TransportUnhandledContentsError>(
+-                                 m_buffer));
+-          }
+-        },
+-        error);
+-    if (error.Fail())
+-      return error.takeError();
+-    return handle;
++  llvm::Expected<T> Read(const std::chrono::microseconds &timeout) {
++    llvm::Expected<std::string> message = ReadImpl(timeout);
++    if (!message)
++      return message.takeError();
++    return llvm::json::parse<T>(/*JSON=*/*message);
+   }
+ 
+ protected:
+-  template <typename... Ts> inline auto Logv(const char *Fmt, Ts &&...Vals) {
+-    Log(llvm::formatv(Fmt, std::forward<Ts>(Vals)...).str());
 -  }
--  new (F) MCFragment();
--  addFragment(F);
--}
+   virtual void Log(llvm::StringRef message);
+ 
+   virtual llvm::Error WriteImpl(const std::string &message) = 0;
+-  virtual llvm::Expected<std::vector<std::string>> Parse() = 0;
++  virtual llvm::Expected<std::string>
++  ReadImpl(const std::chrono::microseconds &timeout) = 0;
+ 
+   lldb::IOObjectSP m_input;
+   lldb::IOObjectSP m_output;
+-  std::string m_buffer;
+-
+-  static constexpr size_t kReadBufferSize = 1024;
+ };
+ 
+ /// A transport class for JSON with a HTTP header.
+@@ -170,13 +111,14 @@
+   virtual ~HTTPDelimitedJSONTransport() = default;
+ 
+ protected:
+-  llvm::Error WriteImpl(const std::string &message) override;
+-  llvm::Expected<std::vector<std::string>> Parse() override;
 -
--void MCObjectStreamer::ensureHeadroom(size_t Headroom) {
--  if (Headroom <= FragSpace)
--    return;
--  auto *F = allocFragSpace(Headroom);
--  new (F) MCFragment();
--  addFragment(F);
-+  addFragment(getContext().allocFragment<MCFragment>());
+-  static constexpr llvm::StringLiteral kHeaderContentLength = "Content-Length";
+-  static constexpr llvm::StringLiteral kHeaderFieldSeparator = ":";
+-  static constexpr llvm::StringLiteral kHeaderSeparator = "\r\n";
+-  static constexpr llvm::StringLiteral kEndOfHeader = "\r\n\r\n";
++  virtual llvm::Error WriteImpl(const std::string &message) override;
++  virtual llvm::Expected<std::string>
++  ReadImpl(const std::chrono::microseconds &timeout) override;
++
++  // FIXME: Support any header.
++  static constexpr llvm::StringLiteral kHeaderContentLength =
++      "Content-Length: ";
++  static constexpr llvm::StringLiteral kHeaderSeparator = "\r\n\r\n";
+ };
+ 
+ /// A transport class for JSON RPC.
+@@ -187,8 +129,9 @@
+   virtual ~JSONRPCTransport() = default;
+ 
+ protected:
+-  llvm::Error WriteImpl(const std::string &message) override;
+-  llvm::Expected<std::vector<std::string>> Parse() override;
++  virtual llvm::Error WriteImpl(const std::string &message) override;
++  virtual llvm::Expected<std::string>
++  ReadImpl(const std::chrono::microseconds &timeout) override;
+ 
+   static constexpr llvm::StringLiteral kMessageSeparator = "\n";
+ };
+diff -ruN --strip-trailing-cr a/lldb/source/Host/common/JSONTransport.cpp b/lldb/source/Host/common/JSONTransport.cpp
+--- a/lldb/source/Host/common/JSONTransport.cpp
++++ b/lldb/source/Host/common/JSONTransport.cpp
+@@ -7,14 +7,17 @@
+ //===----------------------------------------------------------------------===//
+ 
+ #include "lldb/Host/JSONTransport.h"
++#include "lldb/Utility/IOObject.h"
+ #include "lldb/Utility/LLDBLog.h"
+ #include "lldb/Utility/Log.h"
++#include "lldb/Utility/SelectHelper.h"
+ #include "lldb/Utility/Status.h"
+ #include "lldb/lldb-forward.h"
+ #include "llvm/ADT/StringExtras.h"
+ #include "llvm/ADT/StringRef.h"
+ #include "llvm/Support/Error.h"
+ #include "llvm/Support/raw_ostream.h"
++#include <optional>
+ #include <string>
+ #include <utility>
+ 
+@@ -22,6 +25,64 @@
+ using namespace lldb;
+ using namespace lldb_private;
+ 
++/// ReadFull attempts to read the specified number of bytes. If EOF is
++/// encountered, an empty string is returned.
++static Expected<std::string>
++ReadFull(IOObject &descriptor, size_t length,
++         std::optional<std::chrono::microseconds> timeout = std::nullopt) {
++  if (!descriptor.IsValid())
++    return llvm::make_error<TransportInvalidError>();
++
++  bool timeout_supported = true;
++  // FIXME: SelectHelper does not work with NativeFile on Win32.
++#if _WIN32
++  timeout_supported = descriptor.GetFdType() == IOObject::eFDTypeSocket;
++#endif
++
++  if (timeout && timeout_supported) {
++    SelectHelper sh;
++    sh.SetTimeout(*timeout);
++    sh.FDSetRead(
++        reinterpret_cast<lldb::socket_t>(descriptor.GetWaitableHandle()));
++    Status status = sh.Select();
++    if (status.Fail()) {
++      // Convert timeouts into a specific error.
++      if (status.GetType() == lldb::eErrorTypePOSIX &&
++          status.GetError() == ETIMEDOUT)
++        return make_error<TransportTimeoutError>();
++      return status.takeError();
++    }
++  }
++
++  std::string data;
++  data.resize(length);
++  Status status = descriptor.Read(data.data(), length);
++  if (status.Fail())
++    return status.takeError();
++
++  // Read returns '' on EOF.
++  if (length == 0)
++    return make_error<TransportEOFError>();
++
++  // Return the actual number of bytes read.
++  return data.substr(0, length);
++}
++
++static Expected<std::string>
++ReadUntil(IOObject &descriptor, StringRef delimiter,
++          std::optional<std::chrono::microseconds> timeout = std::nullopt) {
++  std::string buffer;
++  buffer.reserve(delimiter.size() + 1);
++  while (!llvm::StringRef(buffer).ends_with(delimiter)) {
++    Expected<std::string> next =
++        ReadFull(descriptor, buffer.empty() ? delimiter.size() : 1, timeout);
++    if (auto Err = next.takeError())
++      return std::move(Err);
++    buffer += *next;
++  }
++  return buffer.substr(0, buffer.size() - delimiter.size());
++}
++
+ JSONTransport::JSONTransport(IOObjectSP input, IOObjectSP output)
+     : m_input(std::move(input)), m_output(std::move(output)) {}
+ 
+@@ -29,80 +90,80 @@
+   LLDB_LOG(GetLog(LLDBLog::Host), "{0}", message);
  }
  
--void MCObjectStreamer::insert(MCFragment *Frag) {
--  assert(Frag->getKind() != MCFragment::FT_Data &&
-+void MCObjectStreamer::insert(MCFragment *F) {
-+  assert(F->getKind() != MCFragment::FT_Data &&
-          "F should have a variable-size tail");
--  // Frag is not connected to FragSpace. Before modifying CurFrag with
--  // addFragment(Frag), allocate an empty fragment to maintain FragSpace
--  // connectivity, potentially reusing CurFrag's associated space.
--  MCFragment *F;
--  if (LLVM_LIKELY(sizeof(MCFragment) + NewFragHeadroom <= FragSpace)) {
--    auto End = reinterpret_cast<size_t>(getCurFragEnd());
--    F = reinterpret_cast<MCFragment *>(
--        alignToPowerOf2(End, alignof(MCFragment)));
--    FragSpace -= size_t(F) - End + sizeof(MCFragment);
--  } else {
--    F = allocFragSpace(0);
--  }
--  new (F) MCFragment();
+-// Parses messages based on
+-// https://microsoft.github.io/debug-adapter-protocol/overview#base-protocol
+-Expected<std::vector<std::string>> HTTPDelimitedJSONTransport::Parse() {
+-  std::vector<std::string> messages;
+-  StringRef buffer = m_buffer;
+-  while (buffer.contains(kEndOfHeader)) {
+-    auto [headers, rest] = buffer.split(kEndOfHeader);
+-    size_t content_length = 0;
+-    // HTTP Headers are formatted like `<field-name> ':' [<field-value>]`.
+-    for (const auto &header : llvm::split(headers, kHeaderSeparator)) {
+-      auto [key, value] = header.split(kHeaderFieldSeparator);
+-      // 'Content-Length' is the only meaningful key at the moment. Others are
+-      // ignored.
+-      if (!key.equals_insensitive(kHeaderContentLength))
+-        continue;
+-
+-      value = value.trim();
+-      if (!llvm::to_integer(value, content_length, 10))
+-        return createStringError(std::errc::invalid_argument,
+-                                 "invalid content length: %s",
+-                                 value.str().c_str());
+-    }
++Expected<std::string>
++HTTPDelimitedJSONTransport::ReadImpl(const std::chrono::microseconds &timeout) {
++  if (!m_input || !m_input->IsValid())
++    return llvm::make_error<TransportInvalidError>();
+ 
+-    // Check if we have enough data.
+-    if (content_length > rest.size())
+-      break;
 -
--  addFragment(Frag);
-   addFragment(F);
-+  newFragment();
+-    StringRef body = rest.take_front(content_length);
+-    buffer = rest.drop_front(content_length);
+-    messages.emplace_back(body.str());
+-    Logv("--> {0}", body);
+-  }
++  IOObject *input = m_input.get();
++  Expected<std::string> message_header =
++      ReadFull(*input, kHeaderContentLength.size(), timeout);
++  if (!message_header)
++    return message_header.takeError();
++  if (*message_header != kHeaderContentLength)
++    return createStringError(formatv("expected '{0}' and got '{1}'",
++                                     kHeaderContentLength, *message_header)
++                                 .str());
++
++  Expected<std::string> raw_length = ReadUntil(*input, kHeaderSeparator);
++  if (!raw_length)
++    return handleErrors(raw_length.takeError(),
++                        [&](const TransportEOFError &E) -> llvm::Error {
++                          return createStringError(
++                              "unexpected EOF while reading header separator");
++                        });
++
++  size_t length;
++  if (!to_integer(*raw_length, length))
++    return createStringError(
++        formatv("invalid content length {0}", *raw_length).str());
++
++  Expected<std::string> raw_json = ReadFull(*input, length);
++  if (!raw_json)
++    return handleErrors(
++        raw_json.takeError(), [&](const TransportEOFError &E) -> llvm::Error {
++          return createStringError("unexpected EOF while reading JSON");
++        });
+ 
+-  // Store the remainder of the buffer for the next read callback.
+-  m_buffer = buffer.str();
++  Log(llvm::formatv("--> {0}", *raw_json).str());
+ 
+-  return std::move(messages);
++  return raw_json;
  }
  
- void MCObjectStreamer::appendContents(ArrayRef<char> Contents) {
--  ensureHeadroom(Contents.size());
--  assert(FragSpace >= Contents.size());
--  llvm::copy(Contents, getCurFragEnd());
--  CurFrag->FixedSize += Contents.size();
--  FragSpace -= Contents.size();
-+  CurFrag->appendContents(Contents);
+ Error HTTPDelimitedJSONTransport::WriteImpl(const std::string &message) {
+   if (!m_output || !m_output->IsValid())
+     return llvm::make_error<TransportInvalidError>();
+ 
+-  Logv("<-- {0}", message);
++  Log(llvm::formatv("<-- {0}", message).str());
+ 
+   std::string Output;
+   raw_string_ostream OS(Output);
+-  OS << kHeaderContentLength << kHeaderFieldSeparator << ' ' << message.length()
+-     << kHeaderSeparator << kHeaderSeparator << message;
++  OS << kHeaderContentLength << message.length() << kHeaderSeparator << message;
+   size_t num_bytes = Output.size();
+   return m_output->Write(Output.data(), num_bytes).takeError();
  }
  
- void MCObjectStreamer::appendContents(size_t Num, char Elt) {
--  ensureHeadroom(Num);
--  MutableArrayRef<char> Data(getCurFragEnd(), Num);
--  llvm::fill(Data, Elt);
--  CurFrag->FixedSize += Num;
--  FragSpace -= Num;
-+  CurFrag->appendContents(Num, Elt);
+-Expected<std::vector<std::string>> JSONRPCTransport::Parse() {
+-  std::vector<std::string> messages;
+-  StringRef buf = m_buffer;
+-  while (buf.contains(kMessageSeparator)) {
+-    auto [raw_json, rest] = buf.split(kMessageSeparator);
+-    buf = rest;
+-    messages.emplace_back(raw_json.str());
+-    Logv("--> {0}", raw_json);
+-  }
++Expected<std::string>
++JSONRPCTransport::ReadImpl(const std::chrono::microseconds &timeout) {
++  if (!m_input || !m_input->IsValid())
++    return make_error<TransportInvalidError>();
++
++  IOObject *input = m_input.get();
++  Expected<std::string> raw_json =
++      ReadUntil(*input, kMessageSeparator, timeout);
++  if (!raw_json)
++    return raw_json.takeError();
+ 
+-  // Store the remainder of the buffer for the next read callback.
+-  m_buffer = buf.str();
++  Log(llvm::formatv("--> {0}", *raw_json).str());
+ 
+-  return messages;
++  return *raw_json;
  }
  
- void MCObjectStreamer::addFixup(const MCExpr *Value, MCFixupKind Kind) {
--  CurFrag->addFixup(MCFixup::create(getCurFragSize(), Value, Kind));
-+  CurFrag->addFixup(MCFixup::create(CurFrag->getFixedSize(), Value, Kind));
+ Error JSONRPCTransport::WriteImpl(const std::string &message) {
+   if (!m_output || !m_output->IsValid())
+     return llvm::make_error<TransportInvalidError>();
+ 
+-  Logv("<-- {0}", message);
++  Log(llvm::formatv("<-- {0}", message).str());
+ 
+   std::string Output;
+   llvm::raw_string_ostream OS(Output);
+@@ -112,5 +173,5 @@
  }
  
- // As a compile-time optimization, avoid allocating and evaluating an MCExpr
-@@ -171,8 +115,6 @@
-   }
-   EmitEHFrame = true;
-   EmitDebugFrame = false;
--  FragStorage.clear();
--  FragSpace = 0;
-   MCStreamer::reset();
+ char TransportEOFError::ID;
+-char TransportUnhandledContentsError::ID;
++char TransportTimeoutError::ID;
+ char TransportInvalidError::ID;
+diff -ruN --strip-trailing-cr a/lldb/test/API/tools/lldb-dap/io/TestDAP_io.py b/lldb/test/API/tools/lldb-dap/io/TestDAP_io.py
+--- a/lldb/test/API/tools/lldb-dap/io/TestDAP_io.py
++++ b/lldb/test/API/tools/lldb-dap/io/TestDAP_io.py
+@@ -8,9 +8,6 @@
+ import lldbdap_testcase
+ import dap_server
+ 
+-EXIT_FAILURE = 1
+-EXIT_SUCCESS = 0
+-
+ 
+ class TestDAP_io(lldbdap_testcase.DAPTestCaseBase):
+     def launch(self):
+@@ -44,44 +41,40 @@
+         """
+         process = self.launch()
+         process.stdin.close()
+-        self.assertEqual(process.wait(timeout=5.0), EXIT_SUCCESS)
++        self.assertEqual(process.wait(timeout=5.0), 0)
+ 
+     def test_invalid_header(self):
+         """
+-        lldb-dap returns a failure exit code when the input stream is closed
+-        with a malformed request header.
++        lldb-dap handles invalid message headers.
+         """
+         process = self.launch()
+-        process.stdin.write(b"not the correct message header")
++        process.stdin.write(b"not the corret message header")
+         process.stdin.close()
+-        self.assertEqual(process.wait(timeout=5.0), EXIT_FAILURE)
++        self.assertEqual(process.wait(timeout=5.0), 1)
+ 
+     def test_partial_header(self):
+         """
+-        lldb-dap returns a failure exit code when the input stream is closed
+-        with an incomplete message header is in the message buffer.
++        lldb-dap handles parital message headers.
+         """
+         process = self.launch()
+         process.stdin.write(b"Content-Length: ")
+         process.stdin.close()
+-        self.assertEqual(process.wait(timeout=5.0), EXIT_FAILURE)
++        self.assertEqual(process.wait(timeout=5.0), 1)
+ 
+     def test_incorrect_content_length(self):
+         """
+-        lldb-dap returns a failure exit code when reading malformed content
+-        length headers.
++        lldb-dap handles malformed content length headers.
+         """
+         process = self.launch()
+         process.stdin.write(b"Content-Length: abc")
+         process.stdin.close()
+-        self.assertEqual(process.wait(timeout=5.0), EXIT_FAILURE)
++        self.assertEqual(process.wait(timeout=5.0), 1)
+ 
+     def test_partial_content_length(self):
+         """
+-        lldb-dap returns a failure exit code when the input stream is closed
+-        with a partial message in the message buffer.
++        lldb-dap handles partial messages.
+         """
+         process = self.launch()
+         process.stdin.write(b"Content-Length: 10\r\n\r\n{")
+         process.stdin.close()
+-        self.assertEqual(process.wait(timeout=5.0), EXIT_FAILURE)
++        self.assertEqual(process.wait(timeout=5.0), 1)
+diff -ruN --strip-trailing-cr a/lldb/tools/lldb-dap/DAP.cpp b/lldb/tools/lldb-dap/DAP.cpp
+--- a/lldb/tools/lldb-dap/DAP.cpp
++++ b/lldb/tools/lldb-dap/DAP.cpp
+@@ -23,14 +23,13 @@
+ #include "Transport.h"
+ #include "lldb/API/SBBreakpoint.h"
+ #include "lldb/API/SBCommandInterpreter.h"
++#include "lldb/API/SBCommandReturnObject.h"
+ #include "lldb/API/SBEvent.h"
+ #include "lldb/API/SBLanguageRuntime.h"
+ #include "lldb/API/SBListener.h"
+ #include "lldb/API/SBProcess.h"
+ #include "lldb/API/SBStream.h"
+-#include "lldb/Host/JSONTransport.h"
+-#include "lldb/Host/MainLoop.h"
+-#include "lldb/Host/MainLoopBase.h"
++#include "lldb/Utility/IOObject.h"
+ #include "lldb/Utility/Status.h"
+ #include "lldb/lldb-defines.h"
+ #include "lldb/lldb-enumerations.h"
+@@ -53,7 +52,7 @@
+ #include <cstdarg>
+ #include <cstdint>
+ #include <cstdio>
+-#include <functional>
++#include <fstream>
+ #include <future>
+ #include <memory>
+ #include <mutex>
+@@ -920,8 +919,6 @@
+   SendTerminatedEvent();
+ 
+   disconnecting = true;
+-  m_loop.AddPendingCallback(
+-      [](MainLoopBase &loop) { loop.RequestTermination(); });
+ 
+   return ToError(error);
  }
+@@ -952,74 +949,75 @@
+   return args;
+ }
+ 
+-Status DAP::TransportHandler() {
+-  llvm::set_thread_name(transport.GetClientName() + ".transport_handler");
+-
+-  auto cleanup = llvm::make_scope_exit([&]() {
+-    // Ensure we're marked as disconnecting when the reader exits.
+-    disconnecting = true;
+-    m_queue_cv.notify_all();
+-  });
++llvm::Error DAP::Loop() {
++  // Can't use \a std::future<llvm::Error> because it doesn't compile on
++  // Windows.
++  std::future<lldb::SBError> queue_reader =
++      std::async(std::launch::async, [&]() -> lldb::SBError {
++        llvm::set_thread_name(transport.GetClientName() + ".transport_handler");
++        auto cleanup = llvm::make_scope_exit([&]() {
++          // Ensure we're marked as disconnecting when the reader exits.
++          disconnecting = true;
++          m_queue_cv.notify_all();
++        });
  
-@@ -201,6 +143,7 @@
- void MCObjectStreamer::emitValueImpl(const MCExpr *Value, unsigned Size,
-                                      SMLoc Loc) {
-   MCStreamer::emitValueImpl(Value, Size, Loc);
-+  MCFragment *DF = getCurrentFragment();
+-  Status status;
+-  auto handle = transport.RegisterReadObject<protocol::Message>(
+-      m_loop,
+-      [&](MainLoopBase &loop, llvm::Expected<protocol::Message> message) {
+-        if (message.errorIsA<TransportEOFError>()) {
+-          llvm::consumeError(message.takeError());
+-          loop.RequestTermination();
+-          return;
+-        }
++        while (!disconnecting) {
++          llvm::Expected<Message> next =
++              transport.Read<protocol::Message>(std::chrono::seconds(1));
++          if (next.errorIsA<TransportEOFError>()) {
++            consumeError(next.takeError());
++            break;
++          }
  
-   MCDwarfLineEntry::make(this, getCurrentSectionOnly());
+-        if (llvm::Error err = message.takeError()) {
+-          status = Status::FromError(std::move(err));
+-          loop.RequestTermination();
+-          return;
+-        }
++          // If the read timed out, continue to check if we should disconnect.
++          if (next.errorIsA<TransportTimeoutError>()) {
++            consumeError(next.takeError());
++            continue;
++          }
  
-@@ -215,9 +158,9 @@
-     emitIntValue(AbsValue, Size);
-     return;
+-        if (const protocol::Request *req =
+-                std::get_if<protocol::Request>(&*message);
+-            req && req->arguments == "disconnect")
+-          disconnecting = true;
++          if (llvm::Error err = next.takeError()) {
++            lldb::SBError errWrapper;
++            errWrapper.SetErrorString(llvm::toString(std::move(err)).c_str());
++            return errWrapper;
++          }
+ 
+-        const std::optional<CancelArguments> cancel_args =
+-            getArgumentsIfRequest<CancelArguments>(*message, "cancel");
+-        if (cancel_args) {
+-          {
+-            std::lock_guard<std::mutex> guard(m_cancelled_requests_mutex);
+-            if (cancel_args->requestId)
+-              m_cancelled_requests.insert(*cancel_args->requestId);
++          if (const protocol::Request *req =
++                  std::get_if<protocol::Request>(&*next);
++              req && req->command == "disconnect")
++            disconnecting = true;
++
++          const std::optional<CancelArguments> cancel_args =
++              getArgumentsIfRequest<CancelArguments>(*next, "cancel");
++          if (cancel_args) {
++            {
++              std::lock_guard<std::mutex> guard(m_cancelled_requests_mutex);
++              if (cancel_args->requestId)
++                m_cancelled_requests.insert(*cancel_args->requestId);
++            }
++
++            // If a cancel is requested for the active request, make a best
++            // effort attempt to interrupt.
++            std::lock_guard<std::mutex> guard(m_active_request_mutex);
++            if (m_active_request &&
++                cancel_args->requestId == m_active_request->seq) {
++              DAP_LOG(
++                  log,
++                  "({0}) interrupting inflight request (command={1} seq={2})",
++                  transport.GetClientName(), m_active_request->command,
++                  m_active_request->seq);
++              debugger.RequestInterrupt();
++            }
+           }
+ 
+-          // If a cancel is requested for the active request, make a best
+-          // effort attempt to interrupt.
+-          std::lock_guard<std::mutex> guard(m_active_request_mutex);
+-          if (m_active_request &&
+-              cancel_args->requestId == m_active_request->seq) {
+-            DAP_LOG(log,
+-                    "({0}) interrupting inflight request (command={1} seq={2})",
+-                    transport.GetClientName(), m_active_request->command,
+-                    m_active_request->seq);
+-            debugger.RequestInterrupt();
++          {
++            std::lock_guard<std::mutex> guard(m_queue_mutex);
++            m_queue.push_back(std::move(*next));
+           }
++          m_queue_cv.notify_one();
+         }
+ 
+-        std::lock_guard<std::mutex> guard(m_queue_mutex);
+-        m_queue.push_back(std::move(*message));
+-        m_queue_cv.notify_one();
++        return lldb::SBError();
+       });
+-  if (auto err = handle.takeError())
+-    return Status::FromError(std::move(err));
+-  if (llvm::Error err = m_loop.Run().takeError())
+-    return Status::FromError(std::move(err));
+-  return status;
+-}
+-
+-llvm::Error DAP::Loop() {
+-  // Can't use \a std::future<llvm::Error> because it doesn't compile on
+-  // Windows.
+-  std::future<Status> queue_reader =
+-      std::async(std::launch::async, &DAP::TransportHandler, this);
+ 
+   auto cleanup = llvm::make_scope_exit([&]() {
+     out.Stop();
+@@ -1045,7 +1043,7 @@
+                                      "unhandled packet");
    }
--  ensureHeadroom(Size);
--  addFixup(Value, MCFixup::getDataKindForSize(Size));
--  appendContents(Size, 0);
-+  DF->addFixup(MCFixup::create(DF->getContents().size(), Value,
-+                               MCFixup::getDataKindForSize(Size)));
-+  DF->appendContents(Size, 0);
+ 
+-  return queue_reader.get().takeError();
++  return ToError(queue_reader.get());
  }
  
- MCSymbol *MCObjectStreamer::emitCFILabel() {
-@@ -251,7 +194,7 @@
-   // section.
-   MCFragment *F = CurFrag;
-   Symbol->setFragment(F);
--  Symbol->setOffset(F->getFixedSize());
-+  Symbol->setOffset(F->getContents().size());
+ lldb::SBError DAP::WaitForProcessToStop(std::chrono::seconds seconds) {
+diff -ruN --strip-trailing-cr a/lldb/tools/lldb-dap/DAP.h b/lldb/tools/lldb-dap/DAP.h
+--- a/lldb/tools/lldb-dap/DAP.h
++++ b/lldb/tools/lldb-dap/DAP.h
+@@ -31,8 +31,6 @@
+ #include "lldb/API/SBMutex.h"
+ #include "lldb/API/SBTarget.h"
+ #include "lldb/API/SBThread.h"
+-#include "lldb/Host/MainLoop.h"
+-#include "lldb/Utility/Status.h"
+ #include "lldb/lldb-types.h"
+ #include "llvm/ADT/DenseMap.h"
+ #include "llvm/ADT/DenseSet.h"
+@@ -426,8 +424,6 @@
+       const std::optional<std::vector<protocol::SourceBreakpoint>> &breakpoints,
+       SourceBreakpointMap &existing_breakpoints);
+ 
+-  lldb_private::Status TransportHandler();
+-
+   /// Registration of request handler.
+   /// @{
+   void RegisterRequests();
+@@ -455,9 +451,6 @@
+   std::mutex m_queue_mutex;
+   std::condition_variable m_queue_cv;
+ 
+-  // Loop for managing reading from the client.
+-  lldb_private::MainLoop m_loop;
+-
+   std::mutex m_cancelled_requests_mutex;
+   llvm::SmallSet<int64_t, 4> m_cancelled_requests;
+ 
+diff -ruN --strip-trailing-cr a/lldb/tools/lldb-dap/Transport.h b/lldb/tools/lldb-dap/Transport.h
+--- a/lldb/tools/lldb-dap/Transport.h
++++ b/lldb/tools/lldb-dap/Transport.h
+@@ -29,7 +29,7 @@
+             lldb::IOObjectSP input, lldb::IOObjectSP output);
+   virtual ~Transport() = default;
  
-   emitPendingAssignments(Symbol);
+-  void Log(llvm::StringRef message) override;
++  virtual void Log(llvm::StringRef message) override;
+ 
+   /// Returns the name of this transport client, for example `stdin/stdout` or
+   /// `client_1`.
+diff -ruN --strip-trailing-cr a/lldb/unittests/DAP/DAPTest.cpp b/lldb/unittests/DAP/DAPTest.cpp
+--- a/lldb/unittests/DAP/DAPTest.cpp
++++ b/lldb/unittests/DAP/DAPTest.cpp
+@@ -9,8 +9,10 @@
+ #include "DAP.h"
+ #include "Protocol/ProtocolBase.h"
+ #include "TestBase.h"
++#include "Transport.h"
+ #include "llvm/Testing/Support/Error.h"
+ #include "gtest/gtest.h"
++#include <chrono>
+ #include <memory>
+ #include <optional>
+ 
+@@ -30,9 +32,8 @@
+       /*transport=*/*to_dap,
+   };
+   dap.Send(Event{/*event=*/"my-event", /*body=*/std::nullopt});
+-  RunOnce<protocol::Message>([&](llvm::Expected<protocol::Message> message) {
+-    ASSERT_THAT_EXPECTED(
+-        message, HasValue(testing::VariantWith<Event>(testing::FieldsAre(
+-                     /*event=*/"my-event", /*body=*/std::nullopt))));
+-  });
++  ASSERT_THAT_EXPECTED(
++      from_dap->Read<protocol::Message>(std::chrono::milliseconds(1)),
++      HasValue(testing::VariantWith<Event>(testing::FieldsAre(
++          /*event=*/"my-event", /*body=*/std::nullopt))));
  }
-@@ -317,21 +260,6 @@
-     F0 = CurFrag;
-   }
+diff -ruN --strip-trailing-cr a/lldb/unittests/DAP/TestBase.cpp b/lldb/unittests/DAP/TestBase.cpp
+--- a/lldb/unittests/DAP/TestBase.cpp
++++ b/lldb/unittests/DAP/TestBase.cpp
+@@ -12,11 +12,9 @@
+ #include "lldb/API/SBDefines.h"
+ #include "lldb/API/SBStructuredData.h"
+ #include "lldb/Host/File.h"
+-#include "lldb/Host/MainLoop.h"
+ #include "lldb/Host/Pipe.h"
+ #include "lldb/lldb-forward.h"
+ #include "llvm/ADT/StringRef.h"
+-#include "llvm/Support/Error.h"
+ #include "llvm/Testing/Support/Error.h"
+ #include "gtest/gtest.h"
+ #include <memory>
+@@ -27,8 +25,6 @@
+ using namespace lldb_dap::protocol;
+ using namespace lldb_dap_tests;
+ using lldb_private::File;
+-using lldb_private::MainLoop;
+-using lldb_private::MainLoopBase;
+ using lldb_private::NativeFile;
+ using lldb_private::Pipe;
  
--  // To maintain connectivity between CurFrag and FragSpace when CurFrag is
--  // modified, allocate an empty fragment and append it to the fragment list.
--  // (Subsections[I].second.Tail is not connected to FragSpace.)
--  MCFragment *F;
--  if (LLVM_LIKELY(sizeof(MCFragment) + NewFragHeadroom <= FragSpace)) {
--    auto End = reinterpret_cast<size_t>(getCurFragEnd());
--    F = reinterpret_cast<MCFragment *>(
--        alignToPowerOf2(End, alignof(MCFragment)));
--    FragSpace -= size_t(F) - End + sizeof(MCFragment);
--  } else {
--    F = allocFragSpace(0);
+@@ -122,18 +118,14 @@
+ std::vector<Message> DAPTestBase::DrainOutput() {
+   std::vector<Message> msgs;
+   output.CloseWriteFileDescriptor();
+-  auto handle = from_dap->RegisterReadObject<protocol::Message>(
+-      loop, [&](MainLoopBase &loop, Expected<protocol::Message> next) {
+-        if (llvm::Error error = next.takeError()) {
+-          loop.RequestTermination();
+-          consumeError(std::move(error));
+-          return;
+-        }
+-
+-        msgs.push_back(*next);
+-      });
+-
+-  consumeError(handle.takeError());
+-  consumeError(loop.Run().takeError());
++  while (true) {
++    Expected<Message> next =
++        from_dap->Read<protocol::Message>(std::chrono::milliseconds(1));
++    if (!next) {
++      consumeError(next.takeError());
++      break;
++    }
++    msgs.push_back(*next);
++  }
+   return msgs;
+ }
+diff -ruN --strip-trailing-cr a/lldb/unittests/DAP/TestBase.h b/lldb/unittests/DAP/TestBase.h
+--- a/lldb/unittests/DAP/TestBase.h
++++ b/lldb/unittests/DAP/TestBase.h
+@@ -10,7 +10,6 @@
+ #include "Protocol/ProtocolBase.h"
+ #include "TestingSupport/Host/PipeTestUtilities.h"
+ #include "Transport.h"
+-#include "lldb/Host/MainLoop.h"
+ #include "llvm/ADT/StringRef.h"
+ #include "gmock/gmock.h"
+ #include "gtest/gtest.h"
+@@ -23,27 +22,8 @@
+ protected:
+   std::unique_ptr<lldb_dap::Transport> to_dap;
+   std::unique_ptr<lldb_dap::Transport> from_dap;
+-  lldb_private::MainLoop loop;
+ 
+   void SetUp() override;
+-
+-  template <typename P>
+-  void RunOnce(std::function<void(llvm::Expected<P>)> callback,
+-               std::chrono::milliseconds timeout = std::chrono::seconds(1)) {
+-    auto handle = from_dap->RegisterReadObject<P>(
+-        loop, [&](lldb_private::MainLoopBase &loop, llvm::Expected<P> message) {
+-          callback(std::move(message));
+-          loop.RequestTermination();
+-        });
+-    loop.AddCallback(
+-        [&](lldb_private::MainLoopBase &loop) {
+-          loop.RequestTermination();
+-          FAIL() << "timeout waiting for read callback";
+-        },
+-        timeout);
+-    ASSERT_THAT_EXPECTED(handle, llvm::Succeeded());
+-    ASSERT_THAT_ERROR(loop.Run().takeError(), llvm::Succeeded());
 -  }
--  new (F) MCFragment();
--  F->setParent(Section);
--
-   auto &Subsections = Section->Subsections;
-   size_t I = 0, E = Subsections.size();
-   while (I != E && Subsections[I].first < Subsection)
-@@ -339,16 +267,13 @@
-   // If the subsection number is not in the sorted Subsections list, create a
-   // new fragment list.
-   if (I == E || Subsections[I].first != Subsection) {
-+    auto *F = getContext().allocFragment<MCFragment>();
-+    F->setParent(Section);
-     Subsections.insert(Subsections.begin() + I,
-                        {Subsection, MCSection::FragList{F, F}});
--    Section->CurFragList = &Subsections[I].second;
--    CurFrag = F;
--  } else {
--    Section->CurFragList = &Subsections[I].second;
--    CurFrag = Subsections[I].second.Tail;
--    // Ensure CurFrag is associated with FragSpace.
--    addFragment(F);
+ };
+ 
+ /// Matches an "output" event.
+diff -ruN --strip-trailing-cr a/lldb/unittests/Host/JSONTransportTest.cpp b/lldb/unittests/Host/JSONTransportTest.cpp
+--- a/lldb/unittests/Host/JSONTransportTest.cpp
++++ b/lldb/unittests/Host/JSONTransportTest.cpp
+@@ -9,15 +9,6 @@
+ #include "lldb/Host/JSONTransport.h"
+ #include "TestingSupport/Host/PipeTestUtilities.h"
+ #include "lldb/Host/File.h"
+-#include "lldb/Host/MainLoop.h"
+-#include "lldb/Host/MainLoopBase.h"
+-#include "llvm/ADT/FunctionExtras.h"
+-#include "llvm/Support/Error.h"
+-#include "llvm/Testing/Support/Error.h"
+-#include "gtest/gtest.h"
+-#include <chrono>
+-#include <future>
+-#include <thread>
+ 
+ using namespace llvm;
+ using namespace lldb_private;
+@@ -26,7 +17,6 @@
+ template <typename T> class JSONTransportTest : public PipePairTest {
+ protected:
+   std::unique_ptr<JSONTransport> transport;
+-  MainLoop loop;
+ 
+   void SetUp() override {
+     PipePairTest::SetUp();
+@@ -38,41 +28,6 @@
+                                      File::eOpenOptionWriteOnly,
+                                      NativeFile::Unowned));
    }
-+  Section->CurFragList = &Subsections[I].second;
-+  CurFrag = Section->CurFragList->Tail;
- 
-   // Define the section symbol at subsection 0's initial fragment if required.
-   if (!NewSec)
-@@ -419,15 +344,11 @@
-   MCFragment *F = getCurrentFragment();
- 
-   // Append the instruction to the data fragment.
--  size_t CodeOffset = getCurFragSize();
--  SmallString<16> Content;
-+  size_t CodeOffset = F->getContents().size();
-   SmallVector<MCFixup, 1> Fixups;
--  getAssembler().getEmitter().encodeInstruction(Inst, Content, Fixups, STI);
--  appendContents(Content);
--  if (CurFrag != F) {
--    F = CurFrag;
--    CodeOffset = 0;
+-
+-  template <typename P>
+-  Expected<P>
+-  RunOnce(std::chrono::milliseconds timeout = std::chrono::seconds(1)) {
+-    std::promise<Expected<P>> promised_message;
+-    std::future<Expected<P>> future_message = promised_message.get_future();
+-    RunUntil<P>(
+-        [&](Expected<P> message) -> bool {
+-          promised_message.set_value(std::move(message));
+-          return /*keep_going*/ false;
+-        },
+-        timeout);
+-    return future_message.get();
+-  }
+-
+-  /// RunUntil runs the event loop until the callback returns `false` or a
+-  /// timeout has occured.
+-  template <typename P>
+-  void RunUntil(unique_function<bool(Expected<P>)> callback,
+-                std::chrono::milliseconds timeout = std::chrono::seconds(1)) {
+-    auto handle = transport->RegisterReadObject<P>(
+-        loop, [&](MainLoopBase &loop, Expected<P> message) {
+-          bool keep_going = callback(std::move(message));
+-          if (!keep_going)
+-            loop.RequestTermination();
+-        });
+-    loop.AddCallback(
+-        [&](MainLoopBase &loop) {
+-          loop.RequestTermination();
+-          callback(createStringError("timeout"));
+-        },
+-        timeout);
+-    EXPECT_THAT_EXPECTED(handle, Succeeded());
+-    EXPECT_THAT_ERROR(loop.Run().takeError(), Succeeded());
 -  }
-+  getAssembler().getEmitter().encodeInstruction(
-+      Inst, F->getContentsForAppending(), Fixups, STI);
-+  F->doneAppending();
-   F->setHasInstructions(STI);
- 
-   if (Fixups.empty())
-diff -ruN --strip-trailing-cr a/llvm/lib/MC/MCWin64EH.cpp b/llvm/lib/MC/MCWin64EH.cpp
---- a/llvm/lib/MC/MCWin64EH.cpp
-+++ b/llvm/lib/MC/MCWin64EH.cpp
-@@ -318,9 +318,6 @@
- 
-   // Emit the epilog instructions.
-   if (EnableUnwindV2) {
--    // Ensure the fixups and appended content apply to the same fragment.
--    OS->ensureHeadroom(info->EpilogMap.size() * 2);
--
-     bool IsLast = true;
-     for (const auto &Epilog : llvm::reverse(info->EpilogMap)) {
-       if (IsLast) {
-diff -ruN --strip-trailing-cr a/llvm/lib/MC/MCWinCOFFStreamer.cpp b/llvm/lib/MC/MCWinCOFFStreamer.cpp
---- a/llvm/lib/MC/MCWinCOFFStreamer.cpp
-+++ b/llvm/lib/MC/MCWinCOFFStreamer.cpp
-@@ -280,7 +280,6 @@
- void MCWinCOFFStreamer::emitCOFFSectionIndex(const MCSymbol *Symbol) {
-   visitUsedSymbol(*Symbol);
-   const MCSymbolRefExpr *SRE = MCSymbolRefExpr::create(Symbol, getContext());
--  ensureHeadroom(2);
-   addFixup(SRE, FK_SecRel_2);
-   appendContents(2, 0);
+ };
+ 
+ class HTTPDelimitedJSONTransportTest
+@@ -101,123 +56,40 @@
+ } // namespace
+ 
+ TEST_F(HTTPDelimitedJSONTransportTest, MalformedRequests) {
+-  std::string malformed_header =
+-      "COnTent-LenGth: -1\r\nContent-Type: text/json\r\n\r\nnotjosn";
++  std::string malformed_header = "COnTent-LenGth: -1{}\r\n\r\nnotjosn";
+   ASSERT_THAT_EXPECTED(
+       input.Write(malformed_header.data(), malformed_header.size()),
+       Succeeded());
+-  ASSERT_THAT_EXPECTED(RunOnce<JSONTestType>(),
+-                       FailedWithMessage("invalid content length: -1"));
++  ASSERT_THAT_EXPECTED(
++      transport->Read<JSONTestType>(std::chrono::milliseconds(1)),
++      FailedWithMessage(
++          "expected 'Content-Length: ' and got 'COnTent-LenGth: '"));
  }
-@@ -294,7 +293,6 @@
-   if (Offset)
-     MCE = MCBinaryExpr::createAdd(
-         MCE, MCConstantExpr::create(Offset, getContext()), getContext());
--  ensureHeadroom(4);
-   addFixup(MCE, FK_SecRel_4);
-   // Emit 4 bytes (zeros) to the object file.
-   appendContents(4, 0);
-@@ -310,7 +308,6 @@
-   if (Offset)
-     MCE = MCBinaryExpr::createAdd(
-         MCE, MCConstantExpr::create(Offset, getContext()), getContext());
--  ensureHeadroom(4);
-   addFixup(MCE, FK_Data_4);
-   // Emit 4 bytes (zeros) to the object file.
-   appendContents(4, 0);
-@@ -321,7 +318,6 @@
-   // Create Symbol for section number.
-   const MCExpr *MCE = MCCOFFSectionNumberTargetExpr::create(
-       *Symbol, this->getWriter(), getContext());
--  ensureHeadroom(4);
-   addFixup(MCE, FK_Data_4);
-   // Emit 4 bytes (zeros) to the object file.
-   appendContents(4, 0);
-@@ -332,7 +328,6 @@
-   // Create Symbol for section offset.
-   const MCExpr *MCE =
-       MCCOFFSectionOffsetTargetExpr::create(*Symbol, getContext());
--  ensureHeadroom(4);
-   addFixup(MCE, FK_Data_4);
-   // Emit 4 bytes (zeros) to the object file.
-   appendContents(4, 0);
-diff -ruN --strip-trailing-cr a/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp b/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp
---- a/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp
-+++ b/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp
-@@ -1034,14 +1034,12 @@
- 
- void MipsTargetELFStreamer::emitGPRel32Value(const MCExpr *Value) {
-   auto &S = getStreamer();
--  S.ensureHeadroom(4);
-   S.addFixup(Value, Mips::fixup_Mips_GPREL32);
-   S.appendContents(4, 0);
+ 
+ TEST_F(HTTPDelimitedJSONTransportTest, Read) {
+   std::string json = R"json({"str": "foo"})json";
+   std::string message =
+-      formatv("Content-Length: {0}\r\nContent-type: text/json\r\n\r\n{1}",
+-              json.size(), json)
+-          .str();
+-  ASSERT_THAT_EXPECTED(input.Write(message.data(), message.size()),
+-                       Succeeded());
+-  ASSERT_THAT_EXPECTED(RunOnce<JSONTestType>(),
+-                       HasValue(testing::FieldsAre(/*str=*/"foo")));
+-}
+-
+-TEST_F(HTTPDelimitedJSONTransportTest, ReadMultipleMessages) {
+-  std::string json1 = R"json({"str": "one"})json";
+-  std::string json2 = R"json({"str": "two"})json";
+-  std::string message = formatv("Content-Length: {0}\r\nContent-type: "
+-                                "text/json\r\n\r\n{1}Content-Length: "
+-                                "{2}\r\nContent-type: text/json\r\n\r\n{3}",
+-                                json1.size(), json1, json2.size(), json2)
+-                            .str();
+-  ASSERT_THAT_EXPECTED(input.Write(message.data(), message.size()),
+-                       Succeeded());
+-  unsigned count = 0;
+-  RunUntil<JSONTestType>([&](Expected<JSONTestType> message) -> bool {
+-    if (count == 0) {
+-      EXPECT_THAT_EXPECTED(message,
+-                           HasValue(testing::FieldsAre(/*str=*/"one")));
+-    } else if (count == 1) {
+-      EXPECT_THAT_EXPECTED(message,
+-                           HasValue(testing::FieldsAre(/*str=*/"two")));
+-    }
+-
+-    count++;
+-    return count < 2;
+-  });
+-}
+-
+-TEST_F(HTTPDelimitedJSONTransportTest, ReadAcrossMultipleChunks) {
+-  std::string long_str = std::string(2048, 'x');
+-  std::string json = formatv(R"({"str": "{0}"})", long_str).str();
+-  std::string message =
+       formatv("Content-Length: {0}\r\n\r\n{1}", json.size(), json).str();
+   ASSERT_THAT_EXPECTED(input.Write(message.data(), message.size()),
+                        Succeeded());
+-  ASSERT_THAT_EXPECTED(RunOnce<JSONTestType>(),
+-                       HasValue(testing::FieldsAre(/*str=*/long_str)));
+-}
+-
+-TEST_F(HTTPDelimitedJSONTransportTest, ReadPartialMessage) {
+-  std::future<void> background_task = std::async(std::launch::async, [&]() {
+-    std::string json = R"({"str": "foo"})";
+-    std::string message =
+-        formatv("Content-Length: {0}\r\n\r\n{1}", json.size(), json).str();
+-    std::string part1 = message.substr(0, 28);
+-    std::string part2 = message.substr(28);
+-
+-    ASSERT_THAT_EXPECTED(input.Write(part1.data(), part1.size()), Succeeded());
+-    std::this_thread::sleep_for(std::chrono::milliseconds(10));
+-    ASSERT_THAT_EXPECTED(input.Write(part2.data(), part2.size()), Succeeded());
+-  });
+-
+-  ASSERT_THAT_EXPECTED(RunOnce<JSONTestType>(),
+-                       HasValue(testing::FieldsAre(/*str=*/"foo")));
+-}
+-
+-TEST_F(HTTPDelimitedJSONTransportTest, ReadWithZeroByteWrites) {
+-  std::future<void> background_task = std::async(std::launch::async, [&]() {
+-    std::string json = R"({"str": "foo"})";
+-    std::string message =
+-        formatv("Content-Length: {0}\r\n\r\n{1}", json.size(), json).str();
+-    std::string part1 = message.substr(0, 28);
+-    std::string part2 = message.substr(28);
+-
+-    ASSERT_THAT_EXPECTED(input.Write(part1.data(), part1.size()), Succeeded());
+-    ASSERT_THAT_EXPECTED(input.Write(part1.data(), 0),
+-                         Succeeded()); // zero-byte write.
+-    std::this_thread::sleep_for(std::chrono::milliseconds(10));
+-    ASSERT_THAT_EXPECTED(input.Write(part2.data(), part2.size()), Succeeded());
+-  });
+-
+-  ASSERT_THAT_EXPECTED(RunOnce<JSONTestType>(),
+-                       HasValue(testing::FieldsAre(/*str=*/"foo")));
++  ASSERT_THAT_EXPECTED(
++      transport->Read<JSONTestType>(std::chrono::milliseconds(1)),
++      HasValue(testing::FieldsAre(/*str=*/"foo")));
  }
  
- void MipsTargetELFStreamer::emitGPRel64Value(const MCExpr *Value) {
-   auto &S = getStreamer();
--  S.ensureHeadroom(8);
-   // fixup_Mips_GPREL32 desginates R_MIPS_GPREL32+R_MIPS_64 on MIPS64.
-   S.addFixup(Value, Mips::fixup_Mips_GPREL32);
-   S.appendContents(8, 0);
-@@ -1049,28 +1047,24 @@
- 
- void MipsTargetELFStreamer::emitDTPRel32Value(const MCExpr *Value) {
-   auto &S = getStreamer();
--  S.ensureHeadroom(4);
-   S.addFixup(Value, Mips::fixup_Mips_DTPREL32);
-   S.appendContents(4, 0);
+ TEST_F(HTTPDelimitedJSONTransportTest, ReadWithEOF) {
+   input.CloseWriteFileDescriptor();
+-  ASSERT_THAT_EXPECTED(RunOnce<JSONTestType>(), Failed<TransportEOFError>());
++  ASSERT_THAT_EXPECTED(
++      transport->Read<JSONTestType>(std::chrono::milliseconds(1)),
++      Failed<TransportEOFError>());
  }
  
- void MipsTargetELFStreamer::emitDTPRel64Value(const MCExpr *Value) {
-   auto &S = getStreamer();
--  S.ensureHeadroom(8);
-   S.addFixup(Value, Mips::fixup_Mips_DTPREL64);
-   S.appendContents(8, 0);
+-TEST_F(HTTPDelimitedJSONTransportTest, ReaderWithUnhandledData) {
+-  std::string json = R"json({"str": "foo"})json";
+-  std::string message =
+-      formatv("Content-Length: {0}\r\nContent-type: text/json\r\n\r\n{1}",
+-              json.size(), json)
+-          .str();
+-  // Write an incomplete message and close the handle.
+-  ASSERT_THAT_EXPECTED(input.Write(message.data(), message.size() - 1),
+-                       Succeeded());
+-  input.CloseWriteFileDescriptor();
+-  ASSERT_THAT_EXPECTED(RunOnce<JSONTestType>(),
+-                       Failed<TransportUnhandledContentsError>());
+-}
+ 
+ TEST_F(HTTPDelimitedJSONTransportTest, InvalidTransport) {
+   transport = std::make_unique<HTTPDelimitedJSONTransport>(nullptr, nullptr);
+-  auto handle = transport->RegisterReadObject<JSONTestType>(
+-      loop, [&](MainLoopBase &, llvm::Expected<JSONTestType>) {});
+-  ASSERT_THAT_EXPECTED(handle, FailedWithMessage("IO object is not valid."));
++  ASSERT_THAT_EXPECTED(
++      transport->Read<JSONTestType>(std::chrono::milliseconds(1)),
++      Failed<TransportInvalidError>());
  }
  
- void MipsTargetELFStreamer::emitTPRel32Value(const MCExpr *Value) {
-   auto &S = getStreamer();
--  S.ensureHeadroom(4);
-   S.addFixup(Value, Mips::fixup_Mips_TPREL32);
-   S.appendContents(4, 0);
+ TEST_F(HTTPDelimitedJSONTransportTest, Write) {
+@@ -236,7 +108,9 @@
+   ASSERT_THAT_EXPECTED(
+       input.Write(malformed_header.data(), malformed_header.size()),
+       Succeeded());
+-  ASSERT_THAT_EXPECTED(RunOnce<JSONTestType>(), llvm::Failed());
++  ASSERT_THAT_EXPECTED(
++      transport->Read<JSONTestType>(std::chrono::milliseconds(1)),
++      llvm::Failed());
  }
  
- void MipsTargetELFStreamer::emitTPRel64Value(const MCExpr *Value) {
-   auto &S = getStreamer();
--  S.ensureHeadroom(8);
-   S.addFixup(Value, Mips::fixup_Mips_TPREL64);
-   S.appendContents(8, 0);
+ TEST_F(JSONRPCTransportTest, Read) {
+@@ -244,50 +118,16 @@
+   std::string message = formatv("{0}\n", json).str();
+   ASSERT_THAT_EXPECTED(input.Write(message.data(), message.size()),
+                        Succeeded());
+-  ASSERT_THAT_EXPECTED(RunOnce<JSONTestType>(),
+-                       HasValue(testing::FieldsAre(/*str=*/"foo")));
+-}
+-
+-TEST_F(JSONRPCTransportTest, ReadAcrossMultipleChunks) {
+-  std::string long_str = std::string(2048, 'x');
+-  std::string json = formatv(R"({"str": "{0}"})", long_str).str();
+-  std::string message = formatv("{0}\n", json).str();
+-  ASSERT_THAT_EXPECTED(input.Write(message.data(), message.size()),
+-                       Succeeded());
+-  ASSERT_THAT_EXPECTED(RunOnce<JSONTestType>(),
+-                       HasValue(testing::FieldsAre(/*str=*/long_str)));
+-}
+-
+-TEST_F(JSONRPCTransportTest, ReadPartialMessage) {
+-  std::future<void> background_task = std::async(std::launch::async, [&]() {
+-    std::string message = R"({"str": "foo"})"
+-                          "\n";
+-    std::string part1 = message.substr(0, 7);
+-    std::string part2 = message.substr(7);
+-
+-    ASSERT_THAT_EXPECTED(input.Write(part1.data(), part1.size()), Succeeded());
+-    std::this_thread::sleep_for(std::chrono::milliseconds(10));
+-    ASSERT_THAT_EXPECTED(input.Write(part2.data(), part2.size()), Succeeded());
+-  });
+-
+-  ASSERT_THAT_EXPECTED(RunOnce<JSONTestType>(),
+-                       HasValue(testing::FieldsAre(/*str=*/"foo")));
++  ASSERT_THAT_EXPECTED(
++      transport->Read<JSONTestType>(std::chrono::milliseconds(1)),
++      HasValue(testing::FieldsAre(/*str=*/"foo")));
  }
-diff -ruN --strip-trailing-cr a/llvm/lib/Target/NVPTX/NVPTXInstrInfo.td b/llvm/lib/Target/NVPTX/NVPTXInstrInfo.td
---- a/llvm/lib/Target/NVPTX/NVPTXInstrInfo.td
-+++ b/llvm/lib/Target/NVPTX/NVPTXInstrInfo.td
-@@ -1830,6 +1830,18 @@
- def : Pat<(declare_scalar_param externalsym:$a, imm:$size),
-           (DECLARE_PARAM_scalar (to_texternsym $a), imm:$size)>;
- 
-+// Call prototype wrapper, this is a dummy instruction that just prints it's
-+// operand which is string defining the prototype.
-+def SDTCallPrototype : SDTypeProfile<0, 1, [SDTCisInt<0>]>;
-+def CallPrototype :
-+  SDNode<"NVPTXISD::CallPrototype", SDTCallPrototype,
-+         [SDNPHasChain, SDNPOutGlue, SDNPInGlue, SDNPSideEffect]>;
-+def ProtoIdent : Operand<i32> { let PrintMethod = "printProtoIdent"; }
-+def CALL_PROTOTYPE :
-+  NVPTXInst<(outs), (ins ProtoIdent:$ident),
-+            "$ident", [(CallPrototype (i32 texternalsym:$ident))]>;
-+
-+
- foreach t = [I32RT, I64RT] in {
-   defvar inst_name = "MOV" # t.Size # "_PARAM";
-   def inst_name : BasicNVPTXInst<(outs t.RC:$dst), (ins t.RC:$src), "mov.b" # t.Size>;
-@@ -1849,6 +1861,32 @@
- defm ProxyRegB32 : ProxyRegInst<"b32",  B32>;
- defm ProxyRegB64 : ProxyRegInst<"b64",  B64>;
  
-+
-+// Callseq start and end
-+
-+// Note: these nodes are marked as SDNPMayStore and SDNPMayLoad because
-+// they define the scope in which the declared params may be used. Therefore
-+// we add these flags to ensure ld.param and st.param are not sunk or hoisted
-+// out of that scope.
-+
-+def callseq_start : SDNode<"ISD::CALLSEQ_START",
-+                           SDCallSeqStart<[SDTCisVT<0, i32>, SDTCisVT<1, i32>]>,
-+                           [SDNPHasChain, SDNPOutGlue,
-+                            SDNPSideEffect, SDNPMayStore, SDNPMayLoad]>;
-+def callseq_end   : SDNode<"ISD::CALLSEQ_END",
-+                           SDCallSeqEnd<[SDTCisVT<0, i32>, SDTCisVT<1, i32>]>,
-+                           [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue,
-+                            SDNPSideEffect, SDNPMayStore, SDNPMayLoad]>;
-+
-+def Callseq_Start :
-+  NVPTXInst<(outs), (ins i32imm:$amt1, i32imm:$amt2),
-+            "\\{ // callseq $amt1, $amt2",
-+            [(callseq_start timm:$amt1, timm:$amt2)]>;
-+def Callseq_End :
-+  NVPTXInst<(outs), (ins i32imm:$amt1, i32imm:$amt2),
-+            "\\} // callseq $amt1",
-+            [(callseq_end timm:$amt1, timm:$amt2)]>;
-+
- //
- // Load / Store Handling
- //
-@@ -2392,26 +2430,6 @@
- def : Pat<(brcond (i1 (setne i1:$a, -1)), bb:$target),
-           (CBranchOther $a, bb:$target)>;
- 
--// Call
--def SDT_NVPTXCallSeqStart : SDCallSeqStart<[SDTCisVT<0, i32>,
--                                            SDTCisVT<1, i32>]>;
--def SDT_NVPTXCallSeqEnd   : SDCallSeqEnd<[SDTCisVT<0, i32>, SDTCisVT<1, i32>]>;
--
--def callseq_start : SDNode<"ISD::CALLSEQ_START", SDT_NVPTXCallSeqStart,
--                           [SDNPHasChain, SDNPOutGlue, SDNPSideEffect]>;
--def callseq_end   : SDNode<"ISD::CALLSEQ_END", SDT_NVPTXCallSeqEnd,
--                           [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue,
--                            SDNPSideEffect]>;
--
--def Callseq_Start :
--  NVPTXInst<(outs), (ins i32imm:$amt1, i32imm:$amt2),
--            "\\{ // callseq $amt1, $amt2",
--            [(callseq_start timm:$amt1, timm:$amt2)]>;
--def Callseq_End :
--  NVPTXInst<(outs), (ins i32imm:$amt1, i32imm:$amt2),
--            "\\} // callseq $amt1",
--            [(callseq_end timm:$amt1, timm:$amt2)]>;
--
- // trap instruction
- def trapinst : BasicNVPTXInst<(outs), (ins), "trap", [(trap)]>, Requires<[noPTXASUnreachableBug]>;
- // Emit an `exit` as well to convey to ptxas that `trap` exits the CFG.
-@@ -2420,18 +2438,6 @@
- // brkpt instruction
- def debugtrapinst : BasicNVPTXInst<(outs), (ins), "brkpt", [(debugtrap)]>;
- 
--// Call prototype wrapper
--def SDTCallPrototype : SDTypeProfile<0, 1, [SDTCisInt<0>]>;
--def CallPrototype :
--  SDNode<"NVPTXISD::CallPrototype", SDTCallPrototype,
--         [SDNPHasChain, SDNPOutGlue, SDNPInGlue, SDNPSideEffect]>;
--def ProtoIdent : Operand<i32> {
--  let PrintMethod = "printProtoIdent";
+ TEST_F(JSONRPCTransportTest, ReadWithEOF) {
+   input.CloseWriteFileDescriptor();
+-  ASSERT_THAT_EXPECTED(RunOnce<JSONTestType>(), Failed<TransportEOFError>());
 -}
--def CALL_PROTOTYPE :
--  NVPTXInst<(outs), (ins ProtoIdent:$ident),
--            "$ident", [(CallPrototype (i32 texternalsym:$ident))]>;
--
- def SDTDynAllocaOp :
-   SDTypeProfile<1, 2, [SDTCisSameAs<0, 1>, SDTCisInt<1>, SDTCisVT<2, i32>]>;
- 
-diff -ruN --strip-trailing-cr a/llvm/test/CodeGen/NVPTX/ld-param-sink.ll b/llvm/test/CodeGen/NVPTX/ld-param-sink.ll
---- a/llvm/test/CodeGen/NVPTX/ld-param-sink.ll
-+++ b/llvm/test/CodeGen/NVPTX/ld-param-sink.ll
-@@ -0,0 +1,47 @@
-+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
-+; RUN: llc < %s -verify-machineinstrs | FileCheck %s
-+; RUN: %if ptxas %{ llc < %s | %ptxas-verify %}
-+
-+target triple = "nvptx64-nvidia-cuda"
-+
-+declare ptr @bar(i64)
-+declare i64 @baz()
-+
-+define ptr @foo(i1 %cond) {
-+; CHECK-LABEL: foo(
-+; CHECK:       {
-+; CHECK-NEXT:    .reg .pred %p<2>;
-+; CHECK-NEXT:    .reg .b16 %rs<3>;
-+; CHECK-NEXT:    .reg .b64 %rd<3>;
-+; CHECK-EMPTY:
-+; CHECK-NEXT:  // %bb.0: // %entry
-+; CHECK-NEXT:    ld.param.b8 %rs1, [foo_param_0];
-+; CHECK-NEXT:    and.b16 %rs2, %rs1, 1;
-+; CHECK-NEXT:    setp.ne.b16 %p1, %rs2, 0;
-+; CHECK-NEXT:    { // callseq 0, 0
-+; CHECK-NEXT:    .param .b64 retval0;
-+; CHECK-NEXT:    call.uni (retval0), baz, ();
-+; CHECK-NEXT:    ld.param.b64 %rd2, [retval0];
-+; CHECK-NEXT:    } // callseq 0
-+; CHECK-NEXT:    @%p1 bra $L__BB0_2;
-+; CHECK-NEXT:  // %bb.1: // %bb
-+; CHECK-NEXT:    { // callseq 1, 0
-+; CHECK-NEXT:    .param .b64 param0;
-+; CHECK-NEXT:    .param .b64 retval0;
-+; CHECK-NEXT:    st.param.b64 [param0], %rd2;
-+; CHECK-NEXT:    call.uni (retval0), bar, (param0);
-+; CHECK-NEXT:    } // callseq 1
-+; CHECK-NEXT:  $L__BB0_2: // %common.ret
-+; CHECK-NEXT:    st.param.b64 [func_retval0], 0;
-+; CHECK-NEXT:    ret;
-+entry:
-+  %call = call i64 @baz()
-+  br i1 %cond, label %common.ret, label %bb
+-
+-TEST_F(JSONRPCTransportTest, ReaderWithUnhandledData) {
+-  std::string message = R"json({"str": "foo"})json"
+-                        "\n";
+-  // Write an incomplete message and close the handle.
+-  ASSERT_THAT_EXPECTED(input.Write(message.data(), message.size() - 1),
+-                       Succeeded());
+-  input.CloseWriteFileDescriptor();
+-  ASSERT_THAT_EXPECTED(RunOnce<JSONTestType>(),
+-                       Failed<TransportUnhandledContentsError>());
++  ASSERT_THAT_EXPECTED(
++      transport->Read<JSONTestType>(std::chrono::milliseconds(1)),
++      Failed<TransportEOFError>());
+ }
+ 
+ TEST_F(JSONRPCTransportTest, Write) {
+@@ -303,7 +143,39 @@
+ 
+ TEST_F(JSONRPCTransportTest, InvalidTransport) {
+   transport = std::make_unique<JSONRPCTransport>(nullptr, nullptr);
+-  auto handle = transport->RegisterReadObject<JSONTestType>(
+-      loop, [&](MainLoopBase &, llvm::Expected<JSONTestType>) {});
+-  ASSERT_THAT_EXPECTED(handle, FailedWithMessage("IO object is not valid."));
++  ASSERT_THAT_EXPECTED(
++      transport->Read<JSONTestType>(std::chrono::milliseconds(1)),
++      Failed<TransportInvalidError>());
++}
 +
-+bb:
-+  %tmp = call ptr @bar(i64 %call)
-+  br label %common.ret
++#ifndef _WIN32
++TEST_F(HTTPDelimitedJSONTransportTest, ReadWithTimeout) {
++  ASSERT_THAT_EXPECTED(
++      transport->Read<JSONTestType>(std::chrono::milliseconds(1)),
++      Failed<TransportTimeoutError>());
++}
 +
-+common.ret:
-+  ret ptr null
++TEST_F(JSONRPCTransportTest, ReadWithTimeout) {
++  ASSERT_THAT_EXPECTED(
++      transport->Read<JSONTestType>(std::chrono::milliseconds(1)),
++      Failed<TransportTimeoutError>());
 +}
-diff -ruN --strip-trailing-cr a/llvm/test/MC/ELF/many-instructions.s b/llvm/test/MC/ELF/many-instructions.s
---- a/llvm/test/MC/ELF/many-instructions.s
-+++ b/llvm/test/MC/ELF/many-instructions.s
-@@ -1,10 +0,0 @@
--# REQUIRES: asserts
--# RUN: llvm-mc -filetype=obj -triple=x86_64 %s -o /dev/null -debug-only=mc-dump
--
--## Test that encodeInstruction may cause a new fragment to be created.
--# CHECK: 0 Data Size:16200
--# CHECK: 16200 Data Size:180
--
--.rept 16384/10
--movabsq $foo, %rax
--.endr
-diff -ruN --strip-trailing-cr a/mlir/lib/IR/MLIRContext.cpp b/mlir/lib/IR/MLIRContext.cpp
---- a/mlir/lib/IR/MLIRContext.cpp
-+++ b/mlir/lib/IR/MLIRContext.cpp
-@@ -884,6 +884,8 @@
- void OperationName::UnregisteredOpModel::initProperties(
-     OperationName opName, OpaqueProperties storage, OpaqueProperties init) {
-   new (storage.as<Attribute *>()) Attribute();
-+  if (init)
-+    *storage.as<Attribute *>() = *init.as<Attribute *>();
- }
- void OperationName::UnregisteredOpModel::deleteProperties(
-     OpaqueProperties prop) {
-diff -ruN --strip-trailing-cr a/mlir/lib/Parser/Parser.cpp b/mlir/lib/Parser/Parser.cpp
---- a/mlir/lib/Parser/Parser.cpp
-+++ b/mlir/lib/Parser/Parser.cpp
-@@ -17,14 +17,32 @@
- 
- using namespace mlir;
- 
-+static std::pair<int64_t, int64_t>
-+getLineAndColStart(const llvm::SourceMgr &sourceMgr) {
-+  unsigned lastFileID = sourceMgr.getNumBuffers();
-+  if (lastFileID == 1)
-+    return {0, 0};
 +
-+  auto bufferID = sourceMgr.getMainFileID();
-+  const llvm::MemoryBuffer *main = sourceMgr.getMemoryBuffer(bufferID);
-+  const llvm::MemoryBuffer *last = sourceMgr.getMemoryBuffer(lastFileID);
-+  // Exclude same start.
-+  if (main->getBufferStart() < last->getBufferStart() &&
-+      main->getBufferEnd() >= last->getBufferEnd()) {
-+    return sourceMgr.getLineAndColumn(
-+        llvm::SMLoc::getFromPointer(last->getBufferStart()), bufferID);
-+  }
-+  return {0, 0};
++// Windows CRT _read checks that the file descriptor is valid and calls a
++// handler if not. This handler is normally a breakpoint, which looks like a
++// crash when not handled by a debugger.
++// https://learn.microsoft.com/en-us/%20cpp/c-runtime-library/reference/read?view=msvc-170
++TEST_F(HTTPDelimitedJSONTransportTest, ReadAfterClosed) {
++  input.CloseReadFileDescriptor();
++  ASSERT_THAT_EXPECTED(
++      transport->Read<JSONTestType>(std::chrono::milliseconds(1)),
++      llvm::Failed());
 +}
 +
- LogicalResult mlir::parseSourceFile(const llvm::SourceMgr &sourceMgr,
-                                     Block *block, const ParserConfig &config,
-                                     LocationAttr *sourceFileLoc) {
-   const auto *sourceBuf = sourceMgr.getMemoryBuffer(sourceMgr.getMainFileID());
-   if (sourceFileLoc) {
--    *sourceFileLoc = FileLineColLoc::get(config.getContext(),
--                                         sourceBuf->getBufferIdentifier(),
--                                         /*line=*/0, /*column=*/0);
-+    auto [line, column] = getLineAndColStart(sourceMgr);
-+    *sourceFileLoc = FileLineColLoc::get(
-+        config.getContext(), sourceBuf->getBufferIdentifier(), line, column);
++TEST_F(JSONRPCTransportTest, ReadAfterClosed) {
++  input.CloseReadFileDescriptor();
++  ASSERT_THAT_EXPECTED(
++      transport->Read<JSONTestType>(std::chrono::milliseconds(1)),
++      llvm::Failed());
+ }
++#endif
+diff -ruN --strip-trailing-cr a/lldb/unittests/Protocol/ProtocolMCPServerTest.cpp b/lldb/unittests/Protocol/ProtocolMCPServerTest.cpp
+--- a/lldb/unittests/Protocol/ProtocolMCPServerTest.cpp
++++ b/lldb/unittests/Protocol/ProtocolMCPServerTest.cpp
+@@ -15,15 +15,9 @@
+ #include "lldb/Host/FileSystem.h"
+ #include "lldb/Host/HostInfo.h"
+ #include "lldb/Host/JSONTransport.h"
+-#include "lldb/Host/MainLoop.h"
+-#include "lldb/Host/MainLoopBase.h"
+ #include "lldb/Host/Socket.h"
+-#include "llvm/Support/Error.h"
+ #include "llvm/Testing/Support/Error.h"
+ #include "gtest/gtest.h"
+-#include <chrono>
+-#include <condition_variable>
+-#include <mutex>
+ 
+ using namespace llvm;
+ using namespace lldb;
+@@ -44,7 +38,7 @@
+ class TestJSONTransport : public lldb_private::JSONRPCTransport {
+ public:
+   using JSONRPCTransport::JSONRPCTransport;
+-  using JSONRPCTransport::Parse;
++  using JSONRPCTransport::ReadImpl;
+   using JSONRPCTransport::WriteImpl;
+ };
+ 
+@@ -53,7 +47,7 @@
+ public:
+   using mcp::Tool::Tool;
+ 
+-  llvm::Expected<mcp::protocol::TextResult>
++  virtual llvm::Expected<mcp::protocol::TextResult>
+   Call(const ToolArguments &args) override {
+     std::string argument;
+     if (const json::Object *args_obj =
+@@ -106,7 +100,7 @@
+ public:
+   using mcp::Tool::Tool;
+ 
+-  llvm::Expected<mcp::protocol::TextResult>
++  virtual llvm::Expected<mcp::protocol::TextResult>
+   Call(const ToolArguments &args) override {
+     return llvm::createStringError("error");
+   }
+@@ -117,7 +111,7 @@
+ public:
+   using mcp::Tool::Tool;
+ 
+-  llvm::Expected<mcp::protocol::TextResult>
++  virtual llvm::Expected<mcp::protocol::TextResult>
+   Call(const ToolArguments &args) override {
+     mcp::protocol::TextResult text_result;
+     text_result.content.emplace_back(mcp::protocol::TextContent{{"failed"}});
+@@ -134,7 +128,6 @@
+   lldb::IOObjectSP m_io_sp;
+   std::unique_ptr<TestJSONTransport> m_transport_up;
+   std::unique_ptr<TestProtocolServerMCP> m_server_up;
+-  MainLoop loop;
+ 
+   static constexpr llvm::StringLiteral k_localhost = "localhost";
+ 
+@@ -142,26 +135,11 @@
+     return m_transport_up->WriteImpl(llvm::formatv("{0}\n", message).str());
+   }
+ 
+-  template <typename P>
+-  void
+-  RunOnce(std::function<void(llvm::Expected<P>)> callback,
+-          std::chrono::milliseconds timeout = std::chrono::milliseconds(100)) {
+-    auto handle = m_transport_up->RegisterReadObject<P>(
+-        loop, [&](lldb_private::MainLoopBase &loop, llvm::Expected<P> message) {
+-          callback(std::move(message));
+-          loop.RequestTermination();
+-        });
+-    loop.AddCallback(
+-        [&](lldb_private::MainLoopBase &loop) {
+-          loop.RequestTermination();
+-          FAIL() << "timeout waiting for read callback";
+-        },
+-        timeout);
+-    ASSERT_THAT_EXPECTED(handle, llvm::Succeeded());
+-    ASSERT_THAT_ERROR(loop.Run().takeError(), llvm::Succeeded());
++  llvm::Expected<std::string> Read() {
++    return m_transport_up->ReadImpl(std::chrono::milliseconds(100));
    }
-   if (isBytecode(*sourceBuf))
-     return readBytecodeFile(*sourceBuf, block, config);
-@@ -37,9 +55,9 @@
-   const auto *sourceBuf =
-       sourceMgr->getMemoryBuffer(sourceMgr->getMainFileID());
-   if (sourceFileLoc) {
--    *sourceFileLoc = FileLineColLoc::get(config.getContext(),
--                                         sourceBuf->getBufferIdentifier(),
--                                         /*line=*/0, /*column=*/0);
-+    auto [line, column] = getLineAndColStart(*sourceMgr);
-+    *sourceFileLoc = FileLineColLoc::get(
-+        config.getContext(), sourceBuf->getBufferIdentifier(), line, column);
+ 
+-  void SetUp() override {
++  void SetUp() {
+     // Create a debugger.
+     ArchSpec arch("arm64-apple-macosx-");
+     Platform::SetHostPlatform(
+@@ -193,7 +171,7 @@
+     m_transport_up = std::make_unique<TestJSONTransport>(m_io_sp, m_io_sp);
+   }
+ 
+-  void TearDown() override {
++  void TearDown() {
+     // Stop the server.
+     ASSERT_THAT_ERROR(m_server_up->Stop(), llvm::Succeeded());
    }
-   if (isBytecode(*sourceBuf))
-     return readBytecodeFile(sourceMgr, block, config);
-diff -ruN --strip-trailing-cr a/mlir/test/IR/test-clone.mlir b/mlir/test/IR/test-clone.mlir
---- a/mlir/test/IR/test-clone.mlir
-+++ b/mlir/test/IR/test-clone.mlir
-@@ -1,4 +1,4 @@
--// RUN: mlir-opt -allow-unregistered-dialect %s -pass-pipeline="builtin.module(func.func(test-clone))" | FileCheck %s
-+// RUN: mlir-opt -allow-unregistered-dialect %s -pass-pipeline="builtin.module(func.func(test-clone))" --split-input-file | FileCheck %s
- 
- module {
-   func.func @fixpoint(%arg1 : i32) -> i32 {
-@@ -18,7 +18,8 @@
- // CHECK-NEXT: notifyOperationInserted: test.yield
- // CHECK-NEXT: notifyOperationInserted: func.return
- 
--// CHECK:   func @fixpoint(%[[arg0:.+]]: i32) -> i32 {
-+// CHECK-LABEL: func @fixpoint
-+// CHECK-SAME:       (%[[arg0:.+]]: i32) -> i32 {
- // CHECK-NEXT:     %[[i0:.+]] = "test.use"(%[[arg0]]) ({
- // CHECK-NEXT:       %[[r2:.+]] = "test.use2"(%[[arg0]]) ({
- // CHECK-NEXT:         "test.yield2"(%[[arg0]]) : (i32) -> ()
-@@ -33,3 +34,33 @@
- // CHECK-NEXT:     }) : (i32) -> i32
- // CHECK-NEXT:     return %[[i1]] : i32
- // CHECK-NEXT:   }
+@@ -208,16 +186,17 @@
+       R"json( {"id":0,"jsonrpc":"2.0","result":{"capabilities":{"resources":{"listChanged":false,"subscribe":false},"tools":{"listChanged":true}},"protocolVersion":"2024-11-05","serverInfo":{"name":"lldb-mcp","version":"0.1.0"}}})json";
+ 
+   ASSERT_THAT_ERROR(Write(request), llvm::Succeeded());
+-  RunOnce<std::string>([&](llvm::Expected<std::string> response_str) {
+-    ASSERT_THAT_EXPECTED(response_str, llvm::Succeeded());
+-    llvm::Expected<json::Value> response_json = json::parse(*response_str);
+-    ASSERT_THAT_EXPECTED(response_json, llvm::Succeeded());
+ 
+-    llvm::Expected<json::Value> expected_json = json::parse(response);
+-    ASSERT_THAT_EXPECTED(expected_json, llvm::Succeeded());
++  llvm::Expected<std::string> response_str = Read();
++  ASSERT_THAT_EXPECTED(response_str, llvm::Succeeded());
+ 
+-    EXPECT_EQ(*response_json, *expected_json);
+-  });
++  llvm::Expected<json::Value> response_json = json::parse(*response_str);
++  ASSERT_THAT_EXPECTED(response_json, llvm::Succeeded());
 +
-+// -----
++  llvm::Expected<json::Value> expected_json = json::parse(response);
++  ASSERT_THAT_EXPECTED(expected_json, llvm::Succeeded());
 +
-+func.func @clone_unregistered_with_attrs() {
-+  "unregistered.foo"() <{bar = 1 : i64, flag = true, name = "test", value = 3.14 : f32}> : () -> ()
-+  "unregistered.bar"() : () -> ()
-+  "unregistered.empty_dict"() <{}> : () -> ()
-+  "unregistered.complex"() <{
-+    array = [1, 2, 3],
-+    dict = {key1 = 42 : i32, key2 = "value"},
-+    nested = {inner = {deep = 100 : i64}}
-+  }> : () -> ()
-+  return
-+}
++  EXPECT_EQ(*response_json, *expected_json);
+ }
+ 
+ TEST_F(ProtocolServerMCPTest, ToolsList) {
+@@ -227,17 +206,17 @@
+       R"json({"id":1,"jsonrpc":"2.0","result":{"tools":[{"description":"test tool","inputSchema":{"type":"object"},"name":"test"},{"description":"Run an lldb command.","inputSchema":{"properties":{"arguments":{"type":"string"},"debugger_id":{"type":"number"}},"required":["debugger_id"],"type":"object"},"name":"lldb_command"}]}})json";
+ 
+   ASSERT_THAT_ERROR(Write(request), llvm::Succeeded());
+-  RunOnce<std::string>([&](llvm::Expected<std::string> response_str) {
+-    ASSERT_THAT_EXPECTED(response_str, llvm::Succeeded());
+ 
+-    llvm::Expected<json::Value> response_json = json::parse(*response_str);
+-    ASSERT_THAT_EXPECTED(response_json, llvm::Succeeded());
++  llvm::Expected<std::string> response_str = Read();
++  ASSERT_THAT_EXPECTED(response_str, llvm::Succeeded());
+ 
+-    llvm::Expected<json::Value> expected_json = json::parse(response);
+-    ASSERT_THAT_EXPECTED(expected_json, llvm::Succeeded());
++  llvm::Expected<json::Value> response_json = json::parse(*response_str);
++  ASSERT_THAT_EXPECTED(response_json, llvm::Succeeded());
+ 
+-    EXPECT_EQ(*response_json, *expected_json);
+-  });
++  llvm::Expected<json::Value> expected_json = json::parse(response);
++  ASSERT_THAT_EXPECTED(expected_json, llvm::Succeeded());
 +
-+// CHECK: notifyOperationInserted: unregistered.foo
-+// CHECK-NEXT: notifyOperationInserted: unregistered.bar
-+// CHECK-NEXT: notifyOperationInserted: unregistered.empty_dict
-+// CHECK-NEXT: notifyOperationInserted: unregistered.complex
-+// CHECK-NEXT: notifyOperationInserted: func.return
++  EXPECT_EQ(*response_json, *expected_json);
+ }
+ 
+ TEST_F(ProtocolServerMCPTest, ResourcesList) {
+@@ -247,17 +226,17 @@
+       R"json({"id":2,"jsonrpc":"2.0","result":{"resources":[{"description":"description","mimeType":"application/json","name":"name","uri":"lldb://foo/bar"}]}})json";
+ 
+   ASSERT_THAT_ERROR(Write(request), llvm::Succeeded());
+-  RunOnce<std::string>([&](llvm::Expected<std::string> response_str) {
+-    ASSERT_THAT_EXPECTED(response_str, llvm::Succeeded());
+ 
+-    llvm::Expected<json::Value> response_json = json::parse(*response_str);
+-    ASSERT_THAT_EXPECTED(response_json, llvm::Succeeded());
++  llvm::Expected<std::string> response_str = Read();
++  ASSERT_THAT_EXPECTED(response_str, llvm::Succeeded());
++
++  llvm::Expected<json::Value> response_json = json::parse(*response_str);
++  ASSERT_THAT_EXPECTED(response_json, llvm::Succeeded());
+ 
+-    llvm::Expected<json::Value> expected_json = json::parse(response);
+-    ASSERT_THAT_EXPECTED(expected_json, llvm::Succeeded());
++  llvm::Expected<json::Value> expected_json = json::parse(response);
++  ASSERT_THAT_EXPECTED(expected_json, llvm::Succeeded());
+ 
+-    EXPECT_EQ(*response_json, *expected_json);
+-  });
++  EXPECT_EQ(*response_json, *expected_json);
+ }
+ 
+ TEST_F(ProtocolServerMCPTest, ToolsCall) {
+@@ -267,17 +246,17 @@
+       R"json({"id":11,"jsonrpc":"2.0","result":{"content":[{"text":"foo","type":"text"}],"isError":false}})json";
+ 
+   ASSERT_THAT_ERROR(Write(request), llvm::Succeeded());
+-  RunOnce<std::string>([&](llvm::Expected<std::string> response_str) {
+-    ASSERT_THAT_EXPECTED(response_str, llvm::Succeeded());
+ 
+-    llvm::Expected<json::Value> response_json = json::parse(*response_str);
+-    ASSERT_THAT_EXPECTED(response_json, llvm::Succeeded());
++  llvm::Expected<std::string> response_str = Read();
++  ASSERT_THAT_EXPECTED(response_str, llvm::Succeeded());
+ 
+-    llvm::Expected<json::Value> expected_json = json::parse(response);
+-    ASSERT_THAT_EXPECTED(expected_json, llvm::Succeeded());
++  llvm::Expected<json::Value> response_json = json::parse(*response_str);
++  ASSERT_THAT_EXPECTED(response_json, llvm::Succeeded());
+ 
+-    EXPECT_EQ(*response_json, *expected_json);
+-  });
++  llvm::Expected<json::Value> expected_json = json::parse(response);
++  ASSERT_THAT_EXPECTED(expected_json, llvm::Succeeded());
++
++  EXPECT_EQ(*response_json, *expected_json);
+ }
+ 
+ TEST_F(ProtocolServerMCPTest, ToolsCallError) {
+@@ -289,17 +268,17 @@
+       R"json({"error":{"code":-32603,"message":"error"},"id":11,"jsonrpc":"2.0"})json";
+ 
+   ASSERT_THAT_ERROR(Write(request), llvm::Succeeded());
+-  RunOnce<std::string>([&](llvm::Expected<std::string> response_str) {
+-    ASSERT_THAT_EXPECTED(response_str, llvm::Succeeded());
+ 
+-    llvm::Expected<json::Value> response_json = json::parse(*response_str);
+-    ASSERT_THAT_EXPECTED(response_json, llvm::Succeeded());
++  llvm::Expected<std::string> response_str = Read();
++  ASSERT_THAT_EXPECTED(response_str, llvm::Succeeded());
 +
-+// CHECK-LABEL:  func @clone_unregistered_with_attrs() {
-+// CHECK-NEXT:     "unregistered.foo"() <{bar = 1 : i64, flag = true, name = "test", value = [[PI:.+]] : f32}> : () -> ()
-+// CHECK-NEXT:     "unregistered.bar"() : () -> ()
-+// CHECK-NEXT:     "unregistered.empty_dict"() <{}> : () -> ()
-+// CHECK-NEXT:     "unregistered.complex"() <{array = [1, 2, 3], dict = {key1 = 42 : i32, key2 = "value"}, nested = {inner = {deep = 100 : i64}}}> : () -> ()
-+// CHECK-NEXT:     "unregistered.foo"() <{bar = 1 : i64, flag = true, name = "test", value = [[PI]] : f32}> : () -> ()
-+// CHECK-NEXT:     "unregistered.bar"() : () -> ()
-+// CHECK-NEXT:     "unregistered.empty_dict"() <{}> : () -> ()
-+// CHECK-NEXT:     "unregistered.complex"() <{array = [1, 2, 3], dict = {key1 = 42 : i32, key2 = "value"}, nested = {inner = {deep = 100 : i64}}}> : () -> ()
-diff -ruN --strip-trailing-cr a/mlir/test/IR/top-level.mlir b/mlir/test/IR/top-level.mlir
---- a/mlir/test/IR/top-level.mlir
-+++ b/mlir/test/IR/top-level.mlir
-@@ -6,10 +6,10 @@
- 
- // -----
- 
--// expected-error@-9 {{source must contain a single top-level operation, found: 2}}
-+// expected-error@-2 {{source must contain a single top-level operation, found: 2}}
- func.func private @bar()
- func.func private @baz()
- 
- // -----
- 
--// expected-error@-15 {{source must contain a single top-level operation, found: 0}}
-+// expected-error@-2 {{source must contain a single top-level operation, found: 0}}
++  llvm::Expected<json::Value> response_json = json::parse(*response_str);
++  ASSERT_THAT_EXPECTED(response_json, llvm::Succeeded());
+ 
+-    llvm::Expected<json::Value> expected_json = json::parse(response);
+-    ASSERT_THAT_EXPECTED(expected_json, llvm::Succeeded());
++  llvm::Expected<json::Value> expected_json = json::parse(response);
++  ASSERT_THAT_EXPECTED(expected_json, llvm::Succeeded());
+ 
+-    EXPECT_EQ(*response_json, *expected_json);
+-  });
++  EXPECT_EQ(*response_json, *expected_json);
+ }
+ 
+ TEST_F(ProtocolServerMCPTest, ToolsCallFail) {
+@@ -311,17 +290,17 @@
+       R"json({"id":11,"jsonrpc":"2.0","result":{"content":[{"text":"failed","type":"text"}],"isError":true}})json";
+ 
+   ASSERT_THAT_ERROR(Write(request), llvm::Succeeded());
+-  RunOnce<std::string>([&](llvm::Expected<std::string> response_str) {
+-    ASSERT_THAT_EXPECTED(response_str, llvm::Succeeded());
+ 
+-    llvm::Expected<json::Value> response_json = json::parse(*response_str);
+-    ASSERT_THAT_EXPECTED(response_json, llvm::Succeeded());
++  llvm::Expected<std::string> response_str = Read();
++  ASSERT_THAT_EXPECTED(response_str, llvm::Succeeded());
++
++  llvm::Expected<json::Value> response_json = json::parse(*response_str);
++  ASSERT_THAT_EXPECTED(response_json, llvm::Succeeded());
+ 
+-    llvm::Expected<json::Value> expected_json = json::parse(response);
+-    ASSERT_THAT_EXPECTED(expected_json, llvm::Succeeded());
++  llvm::Expected<json::Value> expected_json = json::parse(response);
++  ASSERT_THAT_EXPECTED(expected_json, llvm::Succeeded());
+ 
+-    EXPECT_EQ(*response_json, *expected_json);
+-  });
++  EXPECT_EQ(*response_json, *expected_json);
+ }
+ 
+ TEST_F(ProtocolServerMCPTest, NotificationInitialized) {
diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl
index 6bf7b5d..5510aff 100644
--- a/third_party/llvm/workspace.bzl
+++ b/third_party/llvm/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive")
 
 def repo(name):
     """Imports LLVM."""
-    LLVM_COMMIT = "8e7b02fc0cd5f63a14f4117866f860b7f174baf3"
-    LLVM_SHA256 = "465cf31bab17d09f9e119ea7a295ddc027ff2d142ee2aa971e8187c154bcdf44"
+    LLVM_COMMIT = "2e0ddbb5cd5b4c860cba6197b6977b96b9dde881"
+    LLVM_SHA256 = "8586cdfcd0b37cc25f3badb5a58529e2d2e1fda284fed16721dcc599daf2c7df"
 
     tf_http_archive(
         name = name,
