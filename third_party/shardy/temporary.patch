diff --git a/third_party/llvm/generated.patch b/third_party/llvm/generated.patch
index 57aff79..31ac103 100644
--- a/third_party/llvm/generated.patch
+++ b/third_party/llvm/generated.patch
@@ -1,293 +1,109 @@
 Auto generated patch. Do not edit or delete it, even if empty.
-diff -ruN --strip-trailing-cr a/clang/include/clang/AST/Decl.h b/clang/include/clang/AST/Decl.h
---- a/clang/include/clang/AST/Decl.h
-+++ b/clang/include/clang/AST/Decl.h
-@@ -888,13 +888,17 @@
-   bool HasICEInit : 1;
-   bool CheckedForICEInit : 1;
- 
-+  bool HasSideEffects : 1;
-+  bool CheckedForSideEffects : 1;
-+
-   LazyDeclStmtPtr Value;
-   APValue Evaluated;
- 
-   EvaluatedStmt()
-       : WasEvaluated(false), IsEvaluating(false),
-         HasConstantInitialization(false), HasConstantDestruction(false),
--        HasICEInit(false), CheckedForICEInit(false) {}
-+        HasICEInit(false), CheckedForICEInit(false), HasSideEffects(false),
-+        CheckedForSideEffects(false) {}
- };
- 
- /// Represents a variable declaration or definition.
-@@ -1353,9 +1357,11 @@
-     return const_cast<VarDecl *>(this)->getInitializingDeclaration();
-   }
- 
--  /// Checks whether this declaration has an initializer with side effects,
--  /// without triggering deserialization if the initializer is not yet
--  /// deserialized.
-+  /// Checks whether this declaration has an initializer with side effects.
-+  /// The result is cached. If the result hasn't been computed this can trigger
-+  /// deserialization and constant evaluation. By running this during
-+  /// serialization and serializing the result all clients can safely call this
-+  /// without triggering further deserialization.
-   bool hasInitWithSideEffects() const;
- 
-   /// Determine whether this variable's value might be usable in a
-diff -ruN --strip-trailing-cr a/clang/include/clang/AST/ExternalASTSource.h b/clang/include/clang/AST/ExternalASTSource.h
---- a/clang/include/clang/AST/ExternalASTSource.h
-+++ b/clang/include/clang/AST/ExternalASTSource.h
-@@ -196,10 +196,6 @@
-   /// module.
-   virtual bool wasThisDeclarationADefinition(const FunctionDecl *FD);
- 
--  virtual bool hasInitializerWithSideEffects(const VarDecl *VD) const {
--    return false;
--  }
--
-   /// Finds all declarations lexically contained within the given
-   /// DeclContext, after applying an optional filter predicate.
-   ///
-@@ -433,17 +429,6 @@
-     }
-     return GetPtr();
-   }
--
--  /// Retrieve the pointer to the AST node that this lazy pointer points to,
--  /// if it can be done without triggering deserialization.
--  ///
--  /// \returns a pointer to the AST node, or null if not yet deserialized.
--  T *getWithoutDeserializing() const {
--    if (isOffset()) {
--      return nullptr;
--    }
--    return GetPtr();
--  }
- 
-   /// Retrieve the address of the AST node pointer. Deserializes the pointee if
-   /// necessary.
-diff -ruN --strip-trailing-cr a/clang/include/clang/Sema/MultiplexExternalSemaSource.h b/clang/include/clang/Sema/MultiplexExternalSemaSource.h
---- a/clang/include/clang/Sema/MultiplexExternalSemaSource.h
-+++ b/clang/include/clang/Sema/MultiplexExternalSemaSource.h
-@@ -94,8 +94,6 @@
- 
-   bool wasThisDeclarationADefinition(const FunctionDecl *FD) override;
- 
--  bool hasInitializerWithSideEffects(const VarDecl *VD) const override;
--
-   /// Find all declarations with the given name in the
-   /// given context.
-   bool FindExternalVisibleDeclsByName(const DeclContext *DC,
-diff -ruN --strip-trailing-cr a/clang/include/clang/Serialization/ASTReader.h b/clang/include/clang/Serialization/ASTReader.h
---- a/clang/include/clang/Serialization/ASTReader.h
-+++ b/clang/include/clang/Serialization/ASTReader.h
-@@ -1453,12 +1453,6 @@
-     const StringRef &operator*() && = delete;
-   };
- 
--  /// VarDecls with initializers containing side effects must be emitted,
--  /// but DeclMustBeEmitted is not allowed to deserialize the intializer.
--  /// FIXME: Lower memory usage by removing VarDecls once the initializer
--  /// is deserialized.
--  llvm::SmallPtrSet<Decl *, 16> InitSideEffectVars;
--
- public:
-   /// Get the buffer for resolving paths.
-   SmallString<0> &getPathBuf() { return PathBuf; }
-@@ -2410,8 +2404,6 @@
- 
-   bool wasThisDeclarationADefinition(const FunctionDecl *FD) override;
- 
--  bool hasInitializerWithSideEffects(const VarDecl *VD) const override;
--
-   /// Retrieve a selector from the given module with its local ID
-   /// number.
-   Selector getLocalSelector(ModuleFile &M, unsigned LocalID);
 diff -ruN --strip-trailing-cr a/clang/lib/AST/Decl.cpp b/clang/lib/AST/Decl.cpp
 --- a/clang/lib/AST/Decl.cpp
 +++ b/clang/lib/AST/Decl.cpp
-@@ -2444,24 +2444,17 @@
-   if (!hasInit())
-     return false;
- 
--  // Check if we can get the initializer without deserializing
--  const Expr *E = nullptr;
--  if (auto *S = dyn_cast<Stmt *>(Init)) {
--    E = cast<Expr>(S);
--  } else {
--    E = cast_or_null<Expr>(getEvaluatedStmt()->Value.getWithoutDeserializing());
-+  EvaluatedStmt *ES = ensureEvaluatedStmt();
-+  if (!ES->CheckedForSideEffects) {
-+    const Expr *E = getInit();
-+    ES->HasSideEffects =
-+        E->HasSideEffects(getASTContext()) &&
-+        // We can get a value-dependent initializer during error recovery.
+@@ -2450,7 +2450,8 @@
+     ES->HasSideEffects =
+         E->HasSideEffects(getASTContext()) &&
+         // We can get a value-dependent initializer during error recovery.
+-        (E->isValueDependent() || !evaluateValue());
 +        (E->isValueDependent() || getType()->isDependentType() ||
 +         !evaluateValue());
-+    ES->CheckedForSideEffects = true;
+     ES->CheckedForSideEffects = true;
    }
--
--  if (E)
--    return E->HasSideEffects(getASTContext()) &&
--           // We can get a value-dependent initializer during error recovery.
--           (E->isValueDependent() || !evaluateValue());
--
--  assert(getEvaluatedStmt()->Value.isOffset());
--  // ASTReader tracks this without having to deserialize the initializer
--  if (auto Source = getASTContext().getExternalSource())
--    return Source->hasInitializerWithSideEffects(this);
--  return false;
-+  return ES->HasSideEffects;
- }
- 
- bool VarDecl::isOutOfLine() const {
-diff -ruN --strip-trailing-cr a/clang/lib/Sema/MultiplexExternalSemaSource.cpp b/clang/lib/Sema/MultiplexExternalSemaSource.cpp
---- a/clang/lib/Sema/MultiplexExternalSemaSource.cpp
-+++ b/clang/lib/Sema/MultiplexExternalSemaSource.cpp
-@@ -115,14 +115,6 @@
-   return false;
- }
- 
--bool MultiplexExternalSemaSource::hasInitializerWithSideEffects(
--    const VarDecl *VD) const {
--  for (const auto &S : Sources)
--    if (S->hasInitializerWithSideEffects(VD))
--      return true;
--  return false;
--}
--
- bool MultiplexExternalSemaSource::FindExternalVisibleDeclsByName(
-     const DeclContext *DC, DeclarationName Name,
-     const DeclContext *OriginalDC) {
-diff -ruN --strip-trailing-cr a/clang/lib/Serialization/ASTReader.cpp b/clang/lib/Serialization/ASTReader.cpp
---- a/clang/lib/Serialization/ASTReader.cpp
-+++ b/clang/lib/Serialization/ASTReader.cpp
-@@ -9725,10 +9725,6 @@
-   return ThisDeclarationWasADefinitionSet.contains(FD);
- }
+   return ES->HasSideEffects;
+diff -ruN --strip-trailing-cr a/clang/lib/Headers/CMakeLists.txt b/clang/lib/Headers/CMakeLists.txt
+--- a/clang/lib/Headers/CMakeLists.txt
++++ b/clang/lib/Headers/CMakeLists.txt
+@@ -347,6 +347,10 @@
+   cuda_wrappers/bits/basic_string.tcc
+ )
  
--bool ASTReader::hasInitializerWithSideEffects(const VarDecl *VD) const {
--  return InitSideEffectVars.count(VD);
--}
--
- Selector ASTReader::getLocalSelector(ModuleFile &M, unsigned LocalID) {
-   return DecodeSelector(getGlobalSelectorID(M, LocalID));
- }
-diff -ruN --strip-trailing-cr a/clang/lib/Serialization/ASTReaderDecl.cpp b/clang/lib/Serialization/ASTReaderDecl.cpp
---- a/clang/lib/Serialization/ASTReaderDecl.cpp
-+++ b/clang/lib/Serialization/ASTReaderDecl.cpp
-@@ -1628,9 +1628,6 @@
-     VD->NonParmVarDeclBits.PreviousDeclInSameBlockScope =
-         VarDeclBits.getNextBit();
++set(cuda_wrapper_utility_files
++  cuda_wrappers/__utility/declval.h
++)
++
+ set(ppc_wrapper_files
+   ppc_wrappers/mmintrin.h
+   ppc_wrappers/xmmintrin.h
+@@ -443,8 +447,9 @@
  
--    if (VarDeclBits.getNextBit())
--      Reader.InitSideEffectVars.insert(VD);
--
-     VD->NonParmVarDeclBits.EscapingByref = VarDeclBits.getNextBit();
-     HasDeducedType = VarDeclBits.getNextBit();
-     VD->NonParmVarDeclBits.ImplicitParamKind =
-@@ -1701,6 +1698,8 @@
-     Eval->HasConstantInitialization = (Val & 2) != 0;
-     Eval->HasConstantDestruction = (Val & 4) != 0;
-     Eval->WasEvaluated = (Val & 8) != 0;
-+    Eval->HasSideEffects = (Val & 16) != 0;
-+    Eval->CheckedForSideEffects = true;
-     if (Eval->WasEvaluated) {
-       Eval->Evaluated = Record.readAPValue();
-       if (Eval->Evaluated.needsCleanup())
-diff -ruN --strip-trailing-cr a/clang/lib/Serialization/ASTWriter.cpp b/clang/lib/Serialization/ASTWriter.cpp
---- a/clang/lib/Serialization/ASTWriter.cpp
-+++ b/clang/lib/Serialization/ASTWriter.cpp
-@@ -7320,6 +7320,10 @@
+ # Copy header files from the source directory to the build directory
+ foreach( f ${files} ${cuda_wrapper_files} ${cuda_wrapper_bits_files}
+-           ${ppc_wrapper_files} ${openmp_wrapper_files} ${zos_wrapper_files} ${hlsl_files}
+-	   ${llvm_libc_wrapper_files} ${llvm_offload_wrapper_files})
++           ${cuda_wrapper_utility_files} ${ppc_wrapper_files} ${openmp_wrapper_files}
++           ${zos_wrapper_files} ${hlsl_files} ${llvm_libc_wrapper_files}
++           ${llvm_offload_wrapper_files})
+   copy_header_to_output_dir(${CMAKE_CURRENT_SOURCE_DIR} ${f})
+ endforeach( f )
  
-   uint64_t Val = 1;
-   if (EvaluatedStmt *ES = VD->getEvaluatedStmt()) {
-+    // This may trigger evaluation, so run it first
-+    if (VD->hasInitWithSideEffects())
-+      Val |= 16;
-+    assert(ES->CheckedForSideEffects);
-     Val |= (ES->HasConstantInitialization ? 2 : 0);
-     Val |= (ES->HasConstantDestruction ? 4 : 0);
-     APValue *Evaluated = VD->getEvaluatedValue();
-diff -ruN --strip-trailing-cr a/clang/lib/Serialization/ASTWriterDecl.cpp b/clang/lib/Serialization/ASTWriterDecl.cpp
---- a/clang/lib/Serialization/ASTWriterDecl.cpp
-+++ b/clang/lib/Serialization/ASTWriterDecl.cpp
-@@ -1305,7 +1305,6 @@
-     VarDeclBits.addBit(D->isConstexpr());
-     VarDeclBits.addBit(D->isInitCapture());
-     VarDeclBits.addBit(D->isPreviousDeclInSameBlockScope());
--    VarDeclBits.addBit(D->hasInitWithSideEffects());
+@@ -553,7 +558,7 @@
+ # Architecture/platform specific targets
+ add_header_target("arm-resource-headers" "${arm_only_files};${arm_only_generated_files}")
+ add_header_target("aarch64-resource-headers" "${aarch64_only_files};${aarch64_only_generated_files}")
+-add_header_target("cuda-resource-headers" "${cuda_files};${cuda_wrapper_files};${cuda_wrapper_bits_files}")
++add_header_target("cuda-resource-headers" "${cuda_files};${cuda_wrapper_files};${cuda_wrapper_bits_files};${cuda_wrapper_utility_files}")
+ add_header_target("hexagon-resource-headers" "${hexagon_files}")
+ add_header_target("hip-resource-headers" "${hip_files}")
+ add_header_target("loongarch-resource-headers" "${loongarch_files}")
+@@ -601,6 +606,11 @@
+   COMPONENT clang-resource-headers)
  
-     VarDeclBits.addBit(D->isEscapingByref());
-     HasDeducedType = D->getType()->getContainedDeducedType();
-diff -ruN --strip-trailing-cr a/clang/test/Driver/autocomplete.c b/clang/test/Driver/autocomplete.c
---- a/clang/test/Driver/autocomplete.c
-+++ b/clang/test/Driver/autocomplete.c
-@@ -111,6 +111,7 @@
- // RUN: %clang --autocomplete=-Wma | FileCheck %s -check-prefix=WARNING
- // WARNING: -Wmacro-redefined
- // WARNING-NEXT: -Wmain
-+// WARNING-NEXT: -Wmain-attached-to-named-module
- // WARNING-NEXT: -Wmain-return-type
- // WARNING-NEXT: -Wmalformed-warning-check
- // WARNING-NEXT: -Wmany-braces-around-scalar-init
-diff -ruN --strip-trailing-cr a/clang/test/Modules/var-init-side-effects-modulemap.cpp b/clang/test/Modules/var-init-side-effects-modulemap.cpp
---- a/clang/test/Modules/var-init-side-effects-modulemap.cpp
-+++ b/clang/test/Modules/var-init-side-effects-modulemap.cpp
-@@ -0,0 +1,51 @@
-+// RUN: rm -rf %t
-+// RUN: mkdir -p %t
-+// RUN: split-file %s %t
-+
-+// RUN: %clang_cc1 -fsyntax-only -fmodules -fmodules-cache-path=%t -fmodule-map-file=%t/module.modulemap  %t/test.cppm -I%t
-+//
-+
-+//--- test.cppm
-+#pragma clang module import Baz
+ install(
++  FILES ${cuda_wrapper_utility_files}
++  DESTINATION ${header_install_dir}/cuda_wrappers/__utility
++  COMPONENT clang-resource-headers)
 +
-+//--- Foo.h
-+#pragma once
-+class foo {
-+  char dummy = 1;
-+
-+public:
-+  static foo var;
++install(
+   FILES ${ppc_wrapper_files}
+   DESTINATION ${header_install_dir}/ppc_wrappers
+   COMPONENT clang-resource-headers)
+@@ -663,6 +673,12 @@
+   EXCLUDE_FROM_ALL
+   COMPONENT cuda-resource-headers)
+ 
++install(
++  FILES ${cuda_wrapper_utility_files}
++  DESTINATION ${header_install_dir}/cuda_wrappers/__utility
++  EXCLUDE_FROM_ALL
++  COMPONENT cuda-resource-headers)
 +
-+};
+ install(
+   FILES ${cuda_files}
+   DESTINATION ${header_install_dir}
+diff -ruN --strip-trailing-cr a/clang/lib/Headers/cuda_wrappers/__utility/declval.h b/clang/lib/Headers/cuda_wrappers/__utility/declval.h
+--- a/clang/lib/Headers/cuda_wrappers/__utility/declval.h
++++ b/clang/lib/Headers/cuda_wrappers/__utility/declval.h
+@@ -0,0 +1,28 @@
++#ifndef __CUDA_WRAPPERS_UTILITY_DECLVAL_H__
++#define __CUDA_WRAPPERS_UTILITY_DECLVAL_H__
 +
-+inline foo foo::var;
++#include_next <__utility/declval.h>
 +
-+//--- Bar.h
-+#pragma once
-+#include <Foo.h>
++// The stuff below is the exact copy of the <__utility/declval.h>,
++// but with __device__ attribute applied to the functions, so it works on a GPU.
 +
-+void bar() {
-+  (void) foo::var;
-+}
++_LIBCPP_BEGIN_NAMESPACE_STD
 +
-+//--- Baz.h
-+#pragma once
-+#include <Foo.h>
++// Suppress deprecation notice for volatile-qualified return type resulting
++// from volatile-qualified types _Tp.
++_LIBCPP_SUPPRESS_DEPRECATED_PUSH
++template <class _Tp> __attribute__((device)) _Tp &&__declval(int);
++template <class _Tp> __attribute__((device)) _Tp __declval(long);
++_LIBCPP_SUPPRESS_DEPRECATED_POP
 +
-+void baz() {
-+  (void) foo::var;
-+}
-+
-+#include <Bar.h>
-+
-+//--- module.modulemap
-+module Foo {
-+  header "Foo.h"
-+}
-+module Bar {
-+  header "Bar.h"
-+}
-+module Baz {
-+  header "Baz.h"
++template <class _Tp>
++__attribute__((device)) _LIBCPP_HIDE_FROM_ABI decltype(std::__declval<_Tp>(0))
++declval() _NOEXCEPT {
++  static_assert(!__is_same(_Tp, _Tp),
++                "std::declval can only be used in an unevaluated context. "
++                "It's likely that your current usage is trying to extract a "
++                "value from the function.");
 +}
 +
++_LIBCPP_END_NAMESPACE_STD
++#endif // __CUDA_WRAPPERS_UTILITY_DECLVAL_H__
 diff -ruN --strip-trailing-cr a/clang/test/Modules/var-init-side-effects-templated.cpp b/clang/test/Modules/var-init-side-effects-templated.cpp
 --- a/clang/test/Modules/var-init-side-effects-templated.cpp
 +++ b/clang/test/Modules/var-init-side-effects-templated.cpp
@@ -312,23 +128,1386 @@ diff -ruN --strip-trailing-cr a/clang/test/Modules/var-init-side-effects-templat
 +  const Wrapper<Float> a = Compute();
 +  return a;
 +}
-diff -ruN --strip-trailing-cr a/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp b/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
---- a/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
-+++ b/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
-@@ -18090,8 +18090,7 @@
+diff -ruN --strip-trailing-cr a/libcxx/include/unordered_map b/libcxx/include/unordered_map
+--- a/libcxx/include/unordered_map
++++ b/libcxx/include/unordered_map
+@@ -967,9 +967,8 @@
+   typedef __hash_value_type<key_type, mapped_type> __value_type;
+   typedef __unordered_map_hasher<key_type, value_type, hasher, key_equal> __hasher;
+   typedef __unordered_map_equal<key_type, value_type, key_equal, hasher> __key_equal;
+-  typedef __rebind_alloc<allocator_traits<allocator_type>, __value_type> __allocator_type;
+ 
+-  typedef __hash_table<__value_type, __hasher, __key_equal, __allocator_type> __table;
++  typedef __hash_table<__value_type, __hasher, __key_equal, allocator_type> __table;
+ 
+   __table __table_;
+ 
+@@ -1777,9 +1776,8 @@
+   typedef __hash_value_type<key_type, mapped_type> __value_type;
+   typedef __unordered_map_hasher<key_type, value_type, hasher, key_equal> __hasher;
+   typedef __unordered_map_equal<key_type, value_type, key_equal, hasher> __key_equal;
+-  typedef __rebind_alloc<allocator_traits<allocator_type>, __value_type> __allocator_type;
+ 
+-  typedef __hash_table<__value_type, __hasher, __key_equal, __allocator_type> __table;
++  typedef __hash_table<__value_type, __hasher, __key_equal, allocator_type> __table;
+ 
+   __table __table_;
+ 
+diff -ruN --strip-trailing-cr a/libcxx/test/std/containers/associative/multimap/incomplete_type.pass.cpp b/libcxx/test/std/containers/associative/multimap/incomplete_type.pass.cpp
+--- a/libcxx/test/std/containers/associative/multimap/incomplete_type.pass.cpp
++++ b/libcxx/test/std/containers/associative/multimap/incomplete_type.pass.cpp
+@@ -13,6 +13,7 @@
+ 
+ #include <map>
+ 
++#include "min_allocator.h"
+ #include "test_macros.h"
+ 
+ struct A {
+@@ -28,5 +29,8 @@
+ int main(int, char**) {
+   A a;
+ 
++  // Make sure that the allocator isn't rebound to and incomplete type
++  std::multimap<int, int, std::less<int>, complete_type_allocator<std::pair<const int, int> > > m;
++
+   return 0;
+ }
+diff -ruN --strip-trailing-cr a/libcxx/test/std/containers/unord/unord.map/incomplete_type.pass.cpp b/libcxx/test/std/containers/unord/unord.map/incomplete_type.pass.cpp
+--- a/libcxx/test/std/containers/unord/unord.map/incomplete_type.pass.cpp
++++ b/libcxx/test/std/containers/unord/unord.map/incomplete_type.pass.cpp
+@@ -14,6 +14,7 @@
+ 
+ #include <unordered_map>
+ 
++#include "min_allocator.h"
+ #include "test_macros.h"
+ 
+ template <class Tp>
+@@ -36,5 +37,9 @@
+ int main(int, char**) {
+   A a;
+ 
++  // Make sure that the allocator isn't rebound to an incomplete type
++  std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, complete_type_allocator<std::pair<const int, int> > >
++      m;
++
+   return 0;
+ }
+diff -ruN --strip-trailing-cr a/libcxx/test/std/containers/unord/unord.multimap/incomplete.pass.cpp b/libcxx/test/std/containers/unord/unord.multimap/incomplete.pass.cpp
+--- a/libcxx/test/std/containers/unord/unord.multimap/incomplete.pass.cpp
++++ b/libcxx/test/std/containers/unord/unord.multimap/incomplete.pass.cpp
+@@ -14,6 +14,7 @@
+ 
+ #include <unordered_map>
+ 
++#include "min_allocator.h"
+ #include "test_macros.h"
+ 
+ template <class Tp>
+@@ -36,5 +37,13 @@
+ int main(int, char**) {
+   A a;
+ 
++  // Make sure that the allocator isn't rebound to an incomplete type
++  std::unordered_multimap<int,
++                          int,
++                          std::hash<int>,
++                          std::equal_to<int>,
++                          complete_type_allocator<std::pair<const int, int> > >
++      m;
++
+   return 0;
+ }
+diff -ruN --strip-trailing-cr a/lldb/cmake/modules/LLDBConfig.cmake b/lldb/cmake/modules/LLDBConfig.cmake
+--- a/lldb/cmake/modules/LLDBConfig.cmake
++++ b/lldb/cmake/modules/LLDBConfig.cmake
+@@ -323,6 +323,4 @@
+     set(LLDB_CAN_USE_DEBUGSERVER OFF)
+ endif()
+ 
+-set(LLDB_BUILD_LLDBRPC ON CACHE BOOL "")
+-
+ include(LLDBGenerateConfig)
+diff -ruN --strip-trailing-cr a/lldb/test/CMakeLists.txt b/lldb/test/CMakeLists.txt
+--- a/lldb/test/CMakeLists.txt
++++ b/lldb/test/CMakeLists.txt
+@@ -132,10 +132,6 @@
+   add_lldb_test_dependency(lldb-framework)
+ endif()
+ 
+-if (LLDB_BUILD_LLDBRPC)
+-  add_lldb_test_dependency(lldb-rpc-generate-sources)
+-endif()
+-
+ # Add dependencies that are not exported targets when building standalone.
+ if(NOT LLDB_BUILT_STANDALONE)
+   add_lldb_test_dependency(
+@@ -253,8 +249,7 @@
+   LLDB_TEST_SHELL_DISABLE_REMOTE
+   LLDB_TOOL_LLDB_SERVER_BUILD
+   LLDB_USE_SYSTEM_DEBUGSERVER
+-  LLDB_IS_64_BITS
+-  LLDB_BUILD_LLDBRPC)
++  LLDB_IS_64_BITS)
+ 
+ # Configure the individual test suites.
+ add_subdirectory(API)
+diff -ruN --strip-trailing-cr a/lldb/test/Shell/helper/toolchain.py b/lldb/test/Shell/helper/toolchain.py
+--- a/lldb/test/Shell/helper/toolchain.py
++++ b/lldb/test/Shell/helper/toolchain.py
+@@ -156,16 +156,6 @@
+             extra_args=["platform"],
+             unresolved="ignore",
+         ),
+-        ToolSubst(
+-            "%lldb-rpc-gen",
+-            command=FindTool("lldb-rpc-gen"),
+-            # We need the LLDB build directory root to pass into the tool, not the test build root.
+-            extra_args=[
+-                "-p " + config.lldb_build_directory + "/..",
+-                '--extra-arg="-resource-dir=' + config.clang_resource_dir + '"',
+-            ],
+-            unresolved="ignore",
+-        ),
+         "lldb-test",
+         "lldb-dap",
+         ToolSubst(
+diff -ruN --strip-trailing-cr a/lldb/test/Shell/lit.site.cfg.py.in b/lldb/test/Shell/lit.site.cfg.py.in
+--- a/lldb/test/Shell/lit.site.cfg.py.in
++++ b/lldb/test/Shell/lit.site.cfg.py.in
+@@ -33,7 +33,6 @@
+ config.have_lldb_server = @LLDB_TOOL_LLDB_SERVER_BUILD@
+ config.lldb_system_debugserver = @LLDB_USE_SYSTEM_DEBUGSERVER@
+ config.llvm_use_sanitizer = "@LLVM_USE_SANITIZER@"
+-config.lldb_has_lldbrpc = @LLDB_BUILD_LLDBRPC@
+ # The shell tests use their own module caches.
+ config.lldb_module_cache = os.path.join("@LLDB_TEST_MODULE_CACHE_LLDB@", "lldb-shell")
+ config.clang_module_cache = os.path.join("@LLDB_TEST_MODULE_CACHE_CLANG@", "lldb-shell")
+diff -ruN --strip-trailing-cr a/lldb/test/Shell/RPC/Generator/lit.local.cfg b/lldb/test/Shell/RPC/Generator/lit.local.cfg
+--- a/lldb/test/Shell/RPC/Generator/lit.local.cfg
++++ b/lldb/test/Shell/RPC/Generator/lit.local.cfg
+@@ -1,3 +0,0 @@
+-# All tests for the tool need lldb-rpc-gen to be built.
+-if not config.lldb_has_lldbrpc:
+-   config.unsupported = True
+diff -ruN --strip-trailing-cr a/lldb/test/Shell/RPC/Generator/Tests/CheckRPCGenToolByproducts.test b/lldb/test/Shell/RPC/Generator/Tests/CheckRPCGenToolByproducts.test
+--- a/lldb/test/Shell/RPC/Generator/Tests/CheckRPCGenToolByproducts.test
++++ b/lldb/test/Shell/RPC/Generator/Tests/CheckRPCGenToolByproducts.test
+@@ -1,9 +0,0 @@
+-RUN: %lldb-rpc-gen --output-dir=%t %S/../Inputs/SBDummy.h
+-
+-RUN: ls %t | FileCheck %s
+-
+-# We're just making sure that the tool emits the class names,
+-# methods and skipped methods file in the output directory.
+-CHECK: SBAPI.def
+-CHECK: SBClasses.def
+-CHECK: SkippedMethods.txt
+diff -ruN --strip-trailing-cr a/lldb/tools/CMakeLists.txt b/lldb/tools/CMakeLists.txt
+--- a/lldb/tools/CMakeLists.txt
++++ b/lldb/tools/CMakeLists.txt
+@@ -10,9 +10,6 @@
+ 
+ add_lldb_tool_subdirectory(lldb-instr)
+ add_lldb_tool_subdirectory(lldb-dap)
+-if (LLDB_BUILD_LLDBRPC)
+-  add_lldb_tool_subdirectory(lldb-rpc)
+-endif()
  
-   // FIXME: use fast math flags instead of Options.UnsafeFPMath
-   // TODO: Finally migrate away from global TargetOptions.
--  if (Options.AllowFPOpFusion == FPOpFusion::Fast ||
--      (Options.NoNaNsFPMath && Options.NoInfsFPMath) ||
-+  if ((Options.NoNaNsFPMath && Options.NoInfsFPMath) ||
-       (N->getFlags().hasNoNaNs() && N->getFlags().hasNoInfs())) {
-     if (Options.NoSignedZerosFPMath || N->getFlags().hasNoSignedZeros() ||
-         (N2CFP && !N2CFP->isExactlyValue(-0.0))) {
+ if (CMAKE_SYSTEM_NAME MATCHES "Darwin")
+   add_lldb_tool_subdirectory(darwin-debug)
+diff -ruN --strip-trailing-cr a/lldb/tools/lldb-rpc/CMakeLists.txt b/lldb/tools/lldb-rpc/CMakeLists.txt
+--- a/lldb/tools/lldb-rpc/CMakeLists.txt
++++ b/lldb/tools/lldb-rpc/CMakeLists.txt
+@@ -1,22 +0,0 @@
+-include(CheckCXXCompilerFlag)
+-# Umbrella target for the entire framework is a default target.
+-add_custom_target(lldb-rpc ALL)
+-
+-if(LLDB_CODESIGN_IDENTITY)
+-  # Use explicit LLDB identity
+-  set(LLVM_CODESIGNING_IDENTITY ${LLDB_CODESIGN_IDENTITY})
+-else()
+-  # Use explicit LLVM identity or default to ad-hoc signing if empty
+-  if(NOT LLVM_CODESIGNING_IDENTITY)
+-    set(LLVM_CODESIGNING_IDENTITY -)
+-  endif()
+-endif()
+-
+-# LLDBRPCGeneration.cmake needs the LLDB_RPC_GEN_EXE variable
+-# which gets defined in the lldb-rpc-gen folder, so we're adding
+-# this folder before we add that file.
+-add_lldb_tool_subdirectory(lldb-rpc-gen)
+-include(${CMAKE_CURRENT_SOURCE_DIR}/LLDBRPCGeneration.cmake)
+-include(${CMAKE_CURRENT_SOURCE_DIR}/LLDBRPCHeaders.cmake)
+-
+-add_dependencies(lldb-rpc lldb-rpc-generate-sources liblldbrpc-headers)
+diff -ruN --strip-trailing-cr a/lldb/tools/lldb-rpc/lldb-rpc-gen/CMakeLists.txt b/lldb/tools/lldb-rpc/lldb-rpc-gen/CMakeLists.txt
+--- a/lldb/tools/lldb-rpc/lldb-rpc-gen/CMakeLists.txt
++++ b/lldb/tools/lldb-rpc/lldb-rpc-gen/CMakeLists.txt
+@@ -1,21 +0,0 @@
+-add_lldb_tool(lldb-rpc-gen
+-    RPCCommon.cpp
+-    lldb-rpc-gen.cpp
+-
+-    CLANG_LIBS
+-      clangAST
+-      clangBasic
+-      clangCodeGen
+-      clangFrontend
+-      clangLex
+-      clangRewrite
+-      clangSerialization
+-      clangTooling
+-
+-    LINK_COMPONENTS
+-      Support
+-  )
+-
+-if (NOT DEFINED LLDB_RPC_GEN_EXE)
+-  set(LLDB_RPC_GEN_EXE $<TARGET_FILE:lldb-rpc-gen> CACHE STRING "Executable that generates lldb-rpc-server")
+-endif()
+diff -ruN --strip-trailing-cr a/lldb/tools/lldb-rpc/lldb-rpc-gen/lldb-rpc-gen.cpp b/lldb/tools/lldb-rpc/lldb-rpc-gen/lldb-rpc-gen.cpp
+--- a/lldb/tools/lldb-rpc/lldb-rpc-gen/lldb-rpc-gen.cpp
++++ b/lldb/tools/lldb-rpc/lldb-rpc-gen/lldb-rpc-gen.cpp
+@@ -1,346 +0,0 @@
+-//===-- lldb-rpc-gen.cpp ----------------------------------------*- C++ -*-===//
+-//
+-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+-// See https://llvm.org/LICENSE.txt for license information.
+-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+-//
+-//===----------------------------------------------------------------------===//
+-
+-#include "RPCCommon.h"
+-
+-#include "clang/AST/AST.h"
+-#include "clang/AST/ASTConsumer.h"
+-#include "clang/AST/ASTContext.h"
+-#include "clang/AST/RecursiveASTVisitor.h"
+-#include "clang/Basic/SourceManager.h"
+-#include "clang/CodeGen/ObjectFilePCHContainerWriter.h"
+-#include "clang/Frontend/CompilerInstance.h"
+-#include "clang/Frontend/FrontendAction.h"
+-#include "clang/Frontend/FrontendActions.h"
+-#include "clang/Serialization/ObjectFilePCHContainerReader.h"
+-#include "clang/Tooling/CommonOptionsParser.h"
+-#include "clang/Tooling/Tooling.h"
+-
+-#include "llvm/ADT/StringRef.h"
+-#include "llvm/Support/CommandLine.h"
+-#include "llvm/Support/Path.h"
+-#include "llvm/Support/ToolOutputFile.h"
+-#include "llvm/Support/raw_ostream.h"
+-
+-using namespace clang;
+-using namespace clang::driver;
+-using namespace clang::tooling;
+-
+-static llvm::cl::OptionCategory RPCGenCategory("Tool for generating LLDBRPC");
+-
+-static llvm::cl::opt<std::string>
+-    OutputDir("output-dir",
+-              llvm::cl::desc("Directory to output generated files to"),
+-              llvm::cl::init(""), llvm::cl::cat(RPCGenCategory));
+-
+-static std::unique_ptr<llvm::ToolOutputFile>
+-CreateOutputFile(llvm::StringRef OutputDir, llvm::StringRef Filename) {
+-  llvm::SmallString<256> Path(OutputDir);
+-  llvm::sys::path::append(Path, Filename);
+-
+-  std::error_code EC;
+-  auto OutputFile =
+-      std::make_unique<llvm::ToolOutputFile>(Path, EC, llvm::sys::fs::OF_None);
+-  if (EC) {
+-    llvm::errs() << "Failed to create output file: " << Path << "!\n";
+-    return nullptr;
+-  }
+-  return OutputFile;
+-}
+-
+-struct GeneratedByproducts {
+-  std::set<std::string> ClassNames;
+-  std::set<std::string> MangledMethodNames;
+-  std::set<std::string> SkippedMethodNames;
+-};
+-
+-enum SupportLevel {
+-  eUnsupported,
+-  eUnimplemented,
+-  eImplemented,
+-};
+-
+-class SBVisitor : public RecursiveASTVisitor<SBVisitor> {
+-public:
+-  SBVisitor(GeneratedByproducts &Byproducts, SourceManager &Manager,
+-            ASTContext &Context)
+-      : Byproducts(Byproducts), Manager(Manager), Context(Context) {}
+-
+-  ~SBVisitor() {}
+-
+-  bool VisitCXXRecordDecl(CXXRecordDecl *RDecl) {
+-    if (ShouldSkipRecord(RDecl))
+-      return true;
+-
+-    const std::string ClassName = RDecl->getNameAsString();
+-    Byproducts.ClassNames.insert(ClassName);
+-
+-    // Print 'bool' instead of '_Bool'.
+-    PrintingPolicy Policy(Context.getLangOpts());
+-    Policy.Bool = true;
+-
+-    for (CXXMethodDecl *MDecl : RDecl->methods()) {
+-      const std::string MangledName =
+-          lldb_rpc_gen::GetMangledName(Context, MDecl);
+-      const bool IsDisallowed =
+-          lldb_rpc_gen::MethodIsDisallowed(Context, MDecl);
+-      SupportLevel MethodSupportLevel = GetMethodSupportLevel(MDecl);
+-      if (MethodSupportLevel == eImplemented && !IsDisallowed) {
+-        const lldb_rpc_gen::Method Method(MDecl, Policy, Context);
+-        Byproducts.MangledMethodNames.insert(MangledName);
+-      } else if (MethodSupportLevel == eUnimplemented)
+-        Byproducts.SkippedMethodNames.insert(MangledName);
+-    }
+-    return true;
+-  }
+-
+-private:
+-  /// Determines whether we should skip a RecordDecl.
+-  /// Conditions for skipping:
+-  ///   - Anything not in the header itself
+-  ///   - Certain inconvenient classes
+-  ///   - Records without definitions (forward declarations)
+-  bool ShouldSkipRecord(CXXRecordDecl *Decl) {
+-    const Type *DeclType = Decl->getTypeForDecl();
+-    QualType CanonicalType = DeclType->getCanonicalTypeInternal();
+-    return !Manager.isInMainFile(Decl->getBeginLoc()) ||
+-           !Decl->hasDefinition() || Decl->getDefinition() != Decl ||
+-           lldb_rpc_gen::TypeIsDisallowedClass(CanonicalType);
+-  }
+-
+-  /// Check the support level for a type
+-  /// Known unsupported types:
+-  ///  - FILE * (We do not want to expose this primitive)
+-  ///  - Types that are internal to LLDB
+-  SupportLevel GetTypeSupportLevel(QualType Type) {
+-    const std::string TypeName = Type.getAsString();
+-    if (TypeName == "FILE *" || lldb_rpc_gen::TypeIsFromLLDBPrivate(Type))
+-      return eUnsupported;
+-
+-    if (lldb_rpc_gen::TypeIsDisallowedClass(Type))
+-      return eUnsupported;
+-
+-    return eImplemented;
+-  }
+-
+-  /// Determine the support level of a given method.
+-  /// Known unsupported methods:
+-  ///   - Non-public methods (lldb-rpc is a client and can only see public
+-  ///     things)
+-  ///   - Copy assignment operators (the client side will handle this)
+-  ///   - Move assignment operators (the client side will handle this)
+-  ///   - Methods involving unsupported types.
+-  /// Known unimplemented methods:
+-  ///   - No variadic functions, e.g. Printf
+-  SupportLevel GetMethodSupportLevel(CXXMethodDecl *MDecl) {
+-    AccessSpecifier AS = MDecl->getAccess();
+-    if (AS != AccessSpecifier::AS_public)
+-      return eUnsupported;
+-    if (MDecl->isCopyAssignmentOperator())
+-      return eUnsupported;
+-    if (MDecl->isMoveAssignmentOperator())
+-      return eUnsupported;
+-
+-    if (MDecl->isVariadic())
+-      return eUnimplemented;
+-
+-    SupportLevel ReturnTypeLevel = GetTypeSupportLevel(MDecl->getReturnType());
+-    if (ReturnTypeLevel != eImplemented)
+-      return ReturnTypeLevel;
+-
+-    for (auto *ParamDecl : MDecl->parameters()) {
+-      SupportLevel ParamTypeLevel = GetTypeSupportLevel(ParamDecl->getType());
+-      if (ParamTypeLevel != eImplemented)
+-        return ParamTypeLevel;
+-    }
+-
+-    // FIXME: If a callback does not take a `void *baton` parameter, it is
+-    // considered unsupported at this time. On the server-side, we hijack the
+-    // baton argument in order to pass additional information to the server-side
+-    // callback so we can correctly perform a reverse RPC call back to the
+-    // client. Without this baton, we would need the server-side callback to
+-    // have some side channel by which it obtained that information, and
+-    // spending time designing that doesn't outweight the cost of doing it at
+-    // the moment.
+-    bool HasCallbackParameter = false;
+-    bool HasBatonParameter = false;
+-    auto End = MDecl->parameters().end();
+-    for (auto Iter = MDecl->parameters().begin(); Iter != End; Iter++) {
+-      if ((*Iter)->getType()->isFunctionPointerType()) {
+-        HasCallbackParameter = true;
+-        continue;
+-      }
+-
+-      // FIXME: We assume that if we have a function pointer and a void pointer
+-      // together in the same parameter list, that it is not followed by a
+-      // length argument. If that changes, we will need to revisit this
+-      // implementation.
+-      if ((*Iter)->getType()->isVoidPointerType())
+-        HasBatonParameter = true;
+-    }
+-
+-    if (HasCallbackParameter && !HasBatonParameter)
+-      return eUnimplemented;
+-
+-    return eImplemented;
+-  }
+-
+-  GeneratedByproducts &Byproducts;
+-  SourceManager &Manager;
+-  ASTContext &Context;
+-};
+-
+-class SBConsumer : public ASTConsumer {
+-public:
+-  SBConsumer(GeneratedByproducts &Byproducts, SourceManager &Manager,
+-             ASTContext &Context)
+-      : Visitor(Byproducts, Manager, Context) {}
+-  bool HandleTopLevelDecl(DeclGroupRef DR) override {
+-    for (Decl *D : DR)
+-      Visitor.TraverseDecl(D);
+-
+-    return true;
+-  }
+-
+-private:
+-  SBVisitor Visitor;
+-};
+-
+-class SBAction : public ASTFrontendAction {
+-public:
+-  SBAction(GeneratedByproducts &Byproducts) : Byproducts(Byproducts) {}
+-
+-  std::unique_ptr<ASTConsumer>
+-  CreateASTConsumer(CompilerInstance &CI, llvm::StringRef File) override {
+-    llvm::StringRef FilenameNoExt =
+-        llvm::sys::path::stem(llvm::sys::path::filename(File));
+-
+-    return std::make_unique<SBConsumer>(Byproducts, CI.getSourceManager(),
+-                                        CI.getASTContext());
+-  }
+-
+-private:
+-  GeneratedByproducts &Byproducts;
+-};
+-
+-class SBActionFactory : public FrontendActionFactory {
+-public:
+-  SBActionFactory(GeneratedByproducts &Byproducts) : Byproducts(Byproducts) {}
+-
+-  std::unique_ptr<FrontendAction> create() override {
+-    return std::make_unique<SBAction>(Byproducts);
+-  }
+-
+-private:
+-  GeneratedByproducts &Byproducts;
+-};
+-
+-bool EmitClassNamesFile(std::set<std::string> &ClassNames) {
+-  static constexpr llvm::StringLiteral ClassNamesFileName = "SBClasses.def";
+-  std::unique_ptr<llvm::ToolOutputFile> ClassNamesFile =
+-      CreateOutputFile(OutputDir.getValue(), ClassNamesFileName);
+-  if (!ClassNamesFile)
+-    return false;
+-
+-  ClassNamesFile->os() << "#ifndef SBCLASS\n"
+-                       << "#error \"SBClass must be defined\"\n"
+-                       << "#endif\n";
+-
+-  for (const auto &ClassName : ClassNames) {
+-    if (ClassName == "SBStream" || ClassName == "SBProgress")
+-      ClassNamesFile->os() << "#if !defined(SBCLASS_EXCLUDE_NONCOPYABLE)\n";
+-    else if (ClassName == "SBReproducer")
+-      ClassNamesFile->os() << "#if !defined(SBCLASS_EXCLUDE_STATICONLY)\n";
+-
+-    ClassNamesFile->os() << "SBCLASS(" << ClassName << ")\n";
+-    if (ClassName == "SBStream" || ClassName == "SBReproducer" ||
+-        ClassName == "SBProgress")
+-      ClassNamesFile->os() << "#endif\n";
+-  }
+-  ClassNamesFile->keep();
+-  return true;
+-}
+-
+-bool EmitMethodNamesFile(std::set<std::string> &MangledMethodNames) {
+-  static constexpr llvm::StringLiteral MethodNamesFileName = "SBAPI.def";
+-  std::unique_ptr<llvm::ToolOutputFile> MethodNamesFile =
+-      CreateOutputFile(OutputDir.getValue(), MethodNamesFileName);
+-  if (!MethodNamesFile)
+-    return false;
+-
+-  MethodNamesFile->os() << "#ifndef GENERATE_SBAPI\n"
+-                        << "#error \"GENERATE_SBAPI must be defined\"\n"
+-                        << "#endif\n";
+-
+-  for (const auto &MangledName : MangledMethodNames) {
+-    MethodNamesFile->os() << "GENERATE_SBAPI(" << MangledName << ")\n";
+-  }
+-  MethodNamesFile->keep();
+-  return true;
+-}
+-
+-bool EmitSkippedMethodsFile(std::set<std::string> &SkippedMethodNames) {
+-  static constexpr llvm::StringLiteral FileName = "SkippedMethods.txt";
+-  std::unique_ptr<llvm::ToolOutputFile> File =
+-      CreateOutputFile(OutputDir.getValue(), FileName);
+-  if (!File)
+-    return false;
+-
+-  for (const auto &Skipped : SkippedMethodNames)
+-    File->os() << Skipped << "\n";
+-  File->keep();
+-  return true;
+-}
+-
+-int main(int argc, const char *argv[]) {
+-  auto ExpectedParser = CommonOptionsParser::create(
+-      argc, argv, RPCGenCategory, llvm::cl::OneOrMore,
+-      "Tool for generating LLDBRPC interfaces and implementations");
+-
+-  if (!ExpectedParser) {
+-    llvm::errs() << ExpectedParser.takeError();
+-    return 1;
+-  }
+-
+-  if (OutputDir.empty()) {
+-    llvm::errs() << "Please specify an output directory for the generated "
+-                    "files with --output-dir!\n";
+-    return 1;
+-  }
+-
+-  // Create the output directory if the user specified one does not exist.
+-  if (!llvm::sys::fs::exists(OutputDir.getValue())) {
+-    llvm::sys::fs::create_directory(OutputDir.getValue());
+-  }
+-
+-  CommonOptionsParser &OP = ExpectedParser.get();
+-  auto PCHOpts = std::make_shared<PCHContainerOperations>();
+-  PCHOpts->registerWriter(std::make_unique<ObjectFilePCHContainerWriter>());
+-  PCHOpts->registerReader(std::make_unique<ObjectFilePCHContainerReader>());
+-
+-  ClangTool T(OP.getCompilations(), OP.getSourcePathList(), PCHOpts);
+-
+-  GeneratedByproducts Byproducts;
+-
+-  SBActionFactory Factory(Byproducts);
+-  auto Result = T.run(&Factory);
+-  if (!EmitClassNamesFile(Byproducts.ClassNames)) {
+-    llvm::errs() << "Failed to create SB Class file\n";
+-    return 1;
+-  }
+-  if (!EmitMethodNamesFile(Byproducts.MangledMethodNames)) {
+-    llvm::errs() << "Failed to create Method Names file\n";
+-    return 1;
+-  }
+-  if (!EmitSkippedMethodsFile(Byproducts.SkippedMethodNames)) {
+-    llvm::errs() << "Failed to create Skipped Methods file\n";
+-    return 1;
+-  }
+-
+-  return Result;
+-}
+diff -ruN --strip-trailing-cr a/lldb/tools/lldb-rpc/lldb-rpc-gen/RPCCommon.cpp b/lldb/tools/lldb-rpc/lldb-rpc-gen/RPCCommon.cpp
+--- a/lldb/tools/lldb-rpc/lldb-rpc-gen/RPCCommon.cpp
++++ b/lldb/tools/lldb-rpc/lldb-rpc-gen/RPCCommon.cpp
+@@ -1,501 +0,0 @@
+-//===-- RPCCommon.cpp -----------------------------------------------------===//
+-//
+-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+-// See https://llvm.org/LICENSE.txt for license information.
+-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+-//
+-//===----------------------------------------------------------------------===//
+-
+-#include "RPCCommon.h"
+-
+-#include "clang/AST/AST.h"
+-#include "clang/AST/Attr.h"
+-#include "clang/AST/DeclBase.h"
+-#include "clang/AST/Mangle.h"
+-#include "clang/Lex/Lexer.h"
+-
+-#include "llvm/ADT/STLExtras.h"
+-#include "llvm/ADT/StringExtras.h"
+-#include "llvm/ADT/StringMap.h"
+-#include "llvm/ADT/StringRef.h"
+-#include "llvm/Support/raw_ostream.h"
+-
+-#include <cstring>
+-
+-using namespace clang;
+-
+-// We intentionally do not generate some classes because they are currently
+-// inconvenient, they aren't really used by most consumers, or we're not sure
+-// why they exist.
+-static constexpr llvm::StringRef DisallowedClasses[] = {
+-    "SBCommunication", // This class is pretty much unused by consumers, so we
+-                       // skip it.
+-    "SBInputReader",   // This class is pretty much unused by consumers, so we
+-                       // skip it.
+-    "SBCommandPluginInterface", // This class uses virtual functions, and the SB
+-                                // API should not have those, so we skip this
+-                                // class.
+-    "SBCommand", // There's nothing too difficult about this one, but many of
+-                 // its methods take a SBCommandPluginInterface pointer so
+-                 // there's no reason to support this.
+-};
+-
+-// NOTE: In lldb-rpc-gen, we use mangled names when we need to work with
+-// functions. We do this because we support many functions that have overloads,
+-// and mangled names have no ambiguity which makes it easier to keep track of.
+-// This is also possible since the LLDB SB API is stable.
+-
+-// We intentionally avoid generating certain methods either because they are
+-// difficult to support correctly or they aren't really used much from C++.
+-// NOTE: These methods are marked as deprecated using LLDB_DEPRECATED.
+-// Normally this macro defines to the deprecated annotation, but this
+-// functionality is removed in SBDefines.h when generating SWIG bindings which
+-// we use for testing. Because of this, there is no annotation for the tool to
+-// pick up on so this list will be used while we have this restriction in
+-// SBDefines.h.
+-static constexpr llvm::StringRef DisallowedMethods[] = {
+-    // The threading functionality in SBHostOS is deprecated and thus we do not
+-    // generate them. It would be ideal to add the annotations to the methods
+-    // and then support not generating deprecated methods. However, without
+-    // annotations the generator generates most things correctly. This one is
+-    // problematic because it returns a pointer to an "opaque" structure
+-    // (thread_t) that is not `void *`, so special casing it is more effort than
+-    // it's worth.
+-    "_ZN4lldb8SBHostOS10ThreadJoinEP17_opaque_pthread_tPPvPNS_7SBErrorE",
+-    "_ZN4lldb8SBHostOS12ThreadCancelEP17_opaque_pthread_tPNS_7SBErrorE",
+-    "_ZN4lldb8SBHostOS12ThreadCreateEPKcPFPvS3_ES3_PNS_7SBErrorE",
+-    "_ZN4lldb8SBHostOS12ThreadDetachEP17_opaque_pthread_tPNS_7SBErrorE",
+-    "_ZN4lldb8SBHostOS13ThreadCreatedEPKc",
+-};
+-
+-static constexpr llvm::StringRef ClassesWithoutDefaultCtor[] = {
+-    "SBHostOS",
+-    "SBReproducer",
+-};
+-
+-static constexpr llvm::StringRef ClassesWithoutCopyOperations[] = {
+-    "SBHostOS",
+-    "SBReproducer",
+-    "SBStream",
+-    "SBProgress",
+-};
+-
+-static constexpr llvm::StringRef MethodsWithPointerPlusLen[] = {
+-    "_ZN4lldb6SBData11ReadRawDataERNS_7SBErrorEyPvm",
+-    "_ZN4lldb6SBData7SetDataERNS_7SBErrorEPKvmNS_9ByteOrderEh",
+-    "_ZN4lldb6SBData20SetDataWithOwnershipERNS_7SBErrorEPKvmNS_9ByteOrderEh",
+-    "_ZN4lldb6SBData25CreateDataFromUInt64ArrayENS_9ByteOrderEjPym",
+-    "_ZN4lldb6SBData25CreateDataFromUInt32ArrayENS_9ByteOrderEjPjm",
+-    "_ZN4lldb6SBData25CreateDataFromSInt64ArrayENS_9ByteOrderEjPxm",
+-    "_ZN4lldb6SBData25CreateDataFromSInt32ArrayENS_9ByteOrderEjPim",
+-    "_ZN4lldb6SBData25CreateDataFromDoubleArrayENS_9ByteOrderEjPdm",
+-    "_ZN4lldb6SBData22SetDataFromUInt64ArrayEPym",
+-    "_ZN4lldb6SBData22SetDataFromUInt32ArrayEPjm",
+-    "_ZN4lldb6SBData22SetDataFromSInt64ArrayEPxm",
+-    "_ZN4lldb6SBData22SetDataFromSInt32ArrayEPim",
+-    "_ZN4lldb6SBData22SetDataFromDoubleArrayEPdm",
+-    "_ZN4lldb10SBDebugger22GetDefaultArchitectureEPcm",
+-    "_ZN4lldb10SBDebugger13DispatchInputEPvPKvm",
+-    "_ZN4lldb10SBDebugger13DispatchInputEPKvm",
+-    "_ZN4lldb6SBFile4ReadEPhmPm",
+-    "_ZN4lldb6SBFile5WriteEPKhmPm",
+-    "_ZNK4lldb10SBFileSpec7GetPathEPcm",
+-    "_ZN4lldb10SBFileSpec11ResolvePathEPKcPcm",
+-    "_ZN4lldb8SBModule10GetVersionEPjj",
+-    "_ZN4lldb12SBModuleSpec12SetUUIDBytesEPKhm",
+-    "_ZNK4lldb9SBProcess9GetSTDOUTEPcm",
+-    "_ZNK4lldb9SBProcess9GetSTDERREPcm",
+-    "_ZNK4lldb9SBProcess19GetAsyncProfileDataEPcm",
+-    "_ZN4lldb9SBProcess10ReadMemoryEyPvmRNS_7SBErrorE",
+-    "_ZN4lldb9SBProcess11WriteMemoryEyPKvmRNS_7SBErrorE",
+-    "_ZN4lldb9SBProcess21ReadCStringFromMemoryEyPvmRNS_7SBErrorE",
+-    "_ZNK4lldb16SBStructuredData14GetStringValueEPcm",
+-    "_ZN4lldb8SBTarget23BreakpointCreateByNamesEPPKcjjRKNS_"
+-    "14SBFileSpecListES6_",
+-    "_ZN4lldb8SBTarget10ReadMemoryENS_9SBAddressEPvmRNS_7SBErrorE",
+-    "_ZN4lldb8SBTarget15GetInstructionsENS_9SBAddressEPKvm",
+-    "_ZN4lldb8SBTarget25GetInstructionsWithFlavorENS_9SBAddressEPKcPKvm",
+-    "_ZN4lldb8SBTarget15GetInstructionsEyPKvm",
+-    "_ZN4lldb8SBTarget25GetInstructionsWithFlavorEyPKcPKvm",
+-    "_ZN4lldb8SBThread18GetStopDescriptionEPcm",
+-    // The below mangled names are used for dummy methods in shell tests
+-    // that test the emitters' output. If you're adding any new mangled names
+-    // from the actual SB API to this list please add them above.
+-    "_ZN4lldb33SBRPC_"
+-    "CHECKCONSTCHARPTRPTRWITHLEN27CheckConstCharPtrPtrWithLenEPPKcm",
+-    "_ZN4lldb19SBRPC_CHECKARRAYPTR13CheckArrayPtrEPPKcm",
+-    "_ZN4lldb18SBRPC_CHECKVOIDPTR12CheckVoidPtrEPvm",
+-};
+-
+-// These classes inherit from rpc::ObjectRef directly (as opposed to
+-// rpc::LocalObjectRef). Changing them from ObjectRef to LocalObjectRef is ABI
+-// breaking, so we preserve that compatibility here.
+-//
+-// lldb-rpc-gen emits classes as LocalObjectRefs by default.
+-//
+-// FIXME: Does it matter which one it emits by default?
+-static constexpr llvm::StringRef ClassesThatInheritFromObjectRef[] = {
+-    "SBAddress",
+-    "SBBreakpointName",
+-    "SBCommandInterpreter",
+-    "SBCommandReturnObject",
+-    "SBError",
+-    "SBExecutionContext",
+-    "SBExpressionOptions",
+-    "SBFileSpec",
+-    "SBFileSpecList",
+-    "SBFormat",
+-    "SBFunction",
+-    "SBHistoricalFrame",
+-    "SBHistoricalLineEntry",
+-    "SBHistoricalLineEntryList",
+-    "SBLineEntry",
+-    "SBStream",
+-    "SBStringList",
+-    "SBStructuredData",
+-    "SBSymbolContext",
+-    "SBSymbolContextList",
+-    "SBTypeMember",
+-    "SBTypeSummaryOptions",
+-    "SBValueList",
+-};
+-
+-QualType lldb_rpc_gen::GetUnderlyingType(QualType T) {
+-  QualType UnderlyingType;
+-  if (T->isPointerType())
+-    UnderlyingType = T->getPointeeType();
+-  else if (T->isReferenceType())
+-    UnderlyingType = T.getNonReferenceType();
+-  else
+-    UnderlyingType = T;
+-
+-  return UnderlyingType;
+-}
+-
+-QualType lldb_rpc_gen::GetUnqualifiedUnderlyingType(QualType T) {
+-  return GetUnderlyingType(T).getUnqualifiedType();
+-}
+-
+-std::string lldb_rpc_gen::GetMangledName(ASTContext &Context,
+-                                         CXXMethodDecl *MDecl) {
+-  std::string Mangled;
+-  llvm::raw_string_ostream MangledStream(Mangled);
+-
+-  GlobalDecl GDecl;
+-  if (const auto *CtorDecl = dyn_cast<CXXConstructorDecl>(MDecl))
+-    GDecl = GlobalDecl(CtorDecl, Ctor_Complete);
+-  else if (const auto *DtorDecl = dyn_cast<CXXDestructorDecl>(MDecl))
+-    GDecl = GlobalDecl(DtorDecl, Dtor_Deleting);
+-  else
+-    GDecl = GlobalDecl(MDecl);
+-
+-  MangleContext *MC = Context.createMangleContext();
+-  MC->mangleName(GDecl, MangledStream);
+-  return Mangled;
+-}
+-
+-static auto CheckTypeForLLDBPrivate = [](const Type *Ty) {};
+-bool lldb_rpc_gen::TypeIsFromLLDBPrivate(QualType T) {
+-  auto CheckTypeForLLDBPrivate = [](const Type *Ty) {
+-    if (!Ty)
+-      return false;
+-    const auto *CXXRDecl = Ty->getAsCXXRecordDecl();
+-    if (!CXXRDecl)
+-      return false;
+-    const auto *NSDecl =
+-        llvm::dyn_cast<NamespaceDecl>(CXXRDecl->getDeclContext());
+-    if (!NSDecl)
+-      return false;
+-    return NSDecl->getName() == "lldb_private";
+-  };
+-
+-  // First, get the underlying type (remove qualifications and strip off any
+-  // pointers/references). Then we'll need to desugar this type. This will
+-  // remove things like typedefs, so instead of seeing "lldb::DebuggerSP" we'll
+-  // actually see something like "std::shared_ptr<lldb_private::Debugger>".
+-  QualType UnqualifiedUnderlyingType = GetUnqualifiedUnderlyingType(T);
+-  const Type *DesugaredType =
+-      UnqualifiedUnderlyingType->getUnqualifiedDesugaredType();
+-  assert(DesugaredType && "DesugaredType from a valid Type is nullptr!");
+-
+-  // Check the type itself.
+-  if (CheckTypeForLLDBPrivate(DesugaredType))
+-    return true;
+-
+-  // If that didn't work, it's possible that the type has a template argument
+-  // that is an lldb_private type.
+-  if (const auto *TemplateSDecl =
+-          llvm::dyn_cast_or_null<ClassTemplateSpecializationDecl>(
+-              DesugaredType->getAsCXXRecordDecl())) {
+-    for (const TemplateArgument &TA :
+-         TemplateSDecl->getTemplateArgs().asArray()) {
+-      if (TA.getKind() != TemplateArgument::Type)
+-        continue;
+-      if (CheckTypeForLLDBPrivate(TA.getAsType().getTypePtr()))
+-        return true;
+-    }
+-  }
+-  return false;
+-}
+-
+-bool lldb_rpc_gen::TypeIsSBClass(QualType T) {
+-  QualType UnqualifiedUnderlyingType = GetUnqualifiedUnderlyingType(T);
+-  const auto *CXXRDecl = UnqualifiedUnderlyingType->getAsCXXRecordDecl();
+-  if (!CXXRDecl)
+-    return false; // SB Classes are always C++ classes
+-
+-  return CXXRDecl->getName().starts_with("SB");
+-}
+-
+-bool lldb_rpc_gen::TypeIsConstCharPtr(QualType T) {
+-  if (!T->isPointerType())
+-    return false;
+-
+-  QualType UnderlyingType = T->getPointeeType();
+-  if (!UnderlyingType.isConstQualified())
+-    return false;
+-
+-  // NOTE: We should be able to do `UnderlyingType->isCharType` but that will
+-  // return true for `const uint8_t *` since that is effectively an unsigned
+-  // char pointer. We currently do not support pointers other than `const char
+-  // *` and `const char **`.
+-  return UnderlyingType->isSpecificBuiltinType(BuiltinType::Char_S) ||
+-         UnderlyingType->isSpecificBuiltinType(BuiltinType::SChar);
+-}
+-
+-bool lldb_rpc_gen::TypeIsConstCharPtrPtr(QualType T) {
+-  if (!T->isPointerType())
+-    return false;
+-
+-  return TypeIsConstCharPtr(T->getPointeeType());
+-}
+-
+-bool lldb_rpc_gen::TypeIsDisallowedClass(QualType T) {
+-  QualType UUT = GetUnqualifiedUnderlyingType(T);
+-  const auto *CXXRDecl = UUT->getAsCXXRecordDecl();
+-  if (!CXXRDecl)
+-    return false;
+-
+-  llvm::StringRef DeclName = CXXRDecl->getName();
+-  for (const llvm::StringRef DisallowedClass : DisallowedClasses)
+-    if (DeclName == DisallowedClass)
+-      return true;
+-  return false;
+-}
+-
+-bool lldb_rpc_gen::TypeIsCallbackFunctionPointer(QualType T) {
+-  return T->isFunctionPointerType();
+-}
+-
+-bool lldb_rpc_gen::MethodIsDisallowed(ASTContext &Context,
+-                                      CXXMethodDecl *MDecl) {
+-  bool isDisallowed = false;
+-  std::string MangledName = lldb_rpc_gen::GetMangledName(Context, MDecl);
+-  if (llvm::is_contained(DisallowedMethods, MangledName))
+-    isDisallowed = true;
+-
+-  if (MDecl->hasAttrs()) {
+-    for (auto *attr : MDecl->getAttrs()) {
+-      if (strcmp(attr->getAttrName()->getNameStart(), "deprecated") == 0)
+-        isDisallowed = true;
+-    }
+-  }
+-  return isDisallowed;
+-}
+-
+-bool lldb_rpc_gen::HasCallbackParameter(CXXMethodDecl *MDecl) {
+-  bool HasCallbackParameter = false;
+-  bool HasBatonParameter = false;
+-  auto End = MDecl->parameters().end();
+-  for (auto Iter = MDecl->parameters().begin(); Iter != End; Iter++) {
+-    if ((*Iter)->getType()->isFunctionPointerType())
+-      HasCallbackParameter = true;
+-    else if ((*Iter)->getType()->isVoidPointerType())
+-      HasBatonParameter = true;
+-  }
+-
+-  return HasCallbackParameter && HasBatonParameter;
+-}
+-
+-// NOTE: There's possibly a more clever way to do this, but we're keeping
+-// the string replacement way here. Here is why it is written this way:
+-// By the time we have already created a `Method` object, we have extracted the
+-// `QualifiedName` and the relevant QualTypes for parameters/return types, many
+-// of which contains "lldb::" in them. To change it in a way that would be
+-// friendly to liblldbrpc, we would need to have a way of replacing that
+-// namespace at the time of creating a Method, and only for liblldbrpc methods.
+-// IMO this would complicate Method more than what I'm doing here, and not
+-// necessarily for any more benefit.
+-// In clang-tools-extra, there is a ChangeNamespaces tool which tries to do
+-// something similar to this. It also operates primarily on string replacement,
+-// but uses more sophisticated clang tooling to do so.
+-// For now, this will do what we need it to do.
+-std::string
+-lldb_rpc_gen::ReplaceLLDBNamespaceWithRPCNamespace(std::string Name) {
+-  const char *lldb_namespace = "lldb::";
+-  auto Pos = Name.find(lldb_namespace);
+-  while (Pos != std::string::npos) {
+-    constexpr size_t SizeOfLLDBNamespace = 6;
+-    Name.replace(Pos, SizeOfLLDBNamespace, "lldb_rpc::");
+-    Pos = Name.find(lldb_namespace);
+-  }
+-  return Name;
+-}
+-
+-std::string lldb_rpc_gen::StripLLDBNamespace(std::string Name) {
+-  const char *lldb_namespace = "lldb::";
+-  auto Pos = Name.find(lldb_namespace);
+-  if (Pos != std::string::npos) {
+-    constexpr size_t SizeOfLLDBNamespace = 6;
+-    Name = Name.substr(Pos + SizeOfLLDBNamespace);
+-  }
+-  return Name;
+-}
+-
+-bool lldb_rpc_gen::SBClassRequiresDefaultCtor(const std::string &ClassName) {
+-  return !llvm::is_contained(ClassesWithoutDefaultCtor, ClassName);
+-}
+-
+-bool lldb_rpc_gen::SBClassRequiresCopyCtorAssign(const std::string &ClassName) {
+-  return !llvm::is_contained(ClassesWithoutCopyOperations, ClassName);
+-}
+-
+-bool lldb_rpc_gen::SBClassInheritsFromObjectRef(const std::string &ClassName) {
+-  return llvm::is_contained(ClassesThatInheritFromObjectRef, ClassName);
+-}
+-
+-std::string lldb_rpc_gen::GetSBClassNameFromType(QualType T) {
+-  assert(lldb_rpc_gen::TypeIsSBClass(T) &&
+-         "Cannot get SBClass name from non-SB class type!");
+-
+-  QualType UnqualifiedUnderlyingType = GetUnqualifiedUnderlyingType(T);
+-  const auto *CXXRDecl = UnqualifiedUnderlyingType->getAsCXXRecordDecl();
+-  assert(CXXRDecl && "SB class was not CXXRecordDecl!");
+-  if (!CXXRDecl)
+-    return std::string();
+-
+-  return CXXRDecl->getName().str();
+-}
+-lldb_rpc_gen::Method::Method(CXXMethodDecl *MDecl, const PrintingPolicy &Policy,
+-                             ASTContext &Context)
+-    : Policy(Policy), Context(Context),
+-      QualifiedName(MDecl->getQualifiedNameAsString()),
+-      BaseName(MDecl->getNameAsString()),
+-      MangledName(lldb_rpc_gen::GetMangledName(Context, MDecl)),
+-      ReturnType(MDecl->getReturnType()), IsConst(MDecl->isConst()),
+-      IsInstance(MDecl->isInstance()), IsCtor(isa<CXXConstructorDecl>(MDecl)),
+-      IsCopyAssign(MDecl->isCopyAssignmentOperator()),
+-      IsMoveAssign(MDecl->isMoveAssignmentOperator()),
+-      IsDtor(isa<CXXDestructorDecl>(MDecl)),
+-      IsConversionMethod(isa<CXXConversionDecl>(MDecl)) {
+-  uint8_t UnnamedArgIdx = 0;
+-  bool PrevParamWasPointer = false;
+-  for (const auto *ParamDecl : MDecl->parameters()) {
+-    Param param;
+-    if (ParamDecl->hasDefaultArg())
+-      param.DefaultValueText =
+-          Lexer::getSourceText(
+-              CharSourceRange::getTokenRange(
+-                  ParamDecl->getDefaultArg()->getSourceRange()),
+-              Context.getSourceManager(), Context.getLangOpts())
+-              .str();
+-
+-    param.IsFollowedByLen = false;
+-    param.Name = ParamDecl->getNameAsString();
+-    // If the parameter has no name, we'll generate one
+-    if (param.Name.empty()) {
+-      param.Name = "arg" + std::to_string(UnnamedArgIdx);
+-      UnnamedArgIdx++;
+-    }
+-    param.Type = ParamDecl->getType();
+-
+-    // FIXME: Instead of using this heuristic, the ideal thing would be to add
+-    // annotations to the SBAPI methods themselves. For now, we have a list of
+-    // methods that we know will need this.
+-    if (PrevParamWasPointer) {
+-      PrevParamWasPointer = false;
+-      const bool IsIntegerType = param.Type->isIntegerType() &&
+-                                 !param.Type->isBooleanType() &&
+-                                 !param.Type->isEnumeralType();
+-      if (IsIntegerType && llvm::is_contained(MethodsWithPointerPlusLen,
+-                                              llvm::StringRef(MangledName)))
+-        Params.back().IsFollowedByLen = true;
+-    }
+-
+-    if (param.Type->isPointerType() &&
+-        !lldb_rpc_gen::TypeIsConstCharPtr(param.Type) &&
+-        !param.Type->isFunctionPointerType())
+-      PrevParamWasPointer = true;
+-
+-    if (param.Type->isFunctionPointerType())
+-      ContainsFunctionPointerParameter = true;
+-
+-    Params.push_back(param);
+-  }
+-
+-  if (IsInstance)
+-    ThisType = MDecl->getThisType();
+-
+-  if (const auto *CtorDecl = dyn_cast<CXXConstructorDecl>(MDecl)) {
+-    IsExplicitCtorOrConversionMethod = CtorDecl->isExplicit();
+-    IsCopyCtor = CtorDecl->isCopyConstructor();
+-    IsMoveCtor = CtorDecl->isMoveConstructor();
+-  } else if (const auto *ConversionDecl = dyn_cast<CXXConversionDecl>(MDecl))
+-    IsExplicitCtorOrConversionMethod = ConversionDecl->isExplicit();
+-}
+-
+-// Adding a '<' allows us to use Methods in ordered containers.
+-// The ordering is on memory addresses.
+-bool lldb_rpc_gen::Method::operator<(const lldb_rpc_gen::Method &rhs) const {
+-  return this < &rhs;
+-}
+-
+-std::string
+-lldb_rpc_gen::Method::CreateParamListAsString(GenerationKind Generation,
+-                                              bool IncludeDefaultValue) const {
+-  assert((!IncludeDefaultValue || Generation == eLibrary) &&
+-         "Default values should only be emitted on the library side!");
+-
+-  std::vector<std::string> ParamList;
+-
+-  if (Generation == eLibrary && RequiresConnectionParameter())
+-    ParamList.push_back("const rpc::Connection &connection");
+-
+-  for (const auto &Param : Params) {
+-    std::string ParamString;
+-    llvm::raw_string_ostream ParamStringStream(ParamString);
+-
+-    if (Generation == eLibrary)
+-      ParamStringStream << lldb_rpc_gen::ReplaceLLDBNamespaceWithRPCNamespace(
+-          Param.Type.getAsString(Policy));
+-    else
+-      ParamStringStream << Param.Type.getAsString(Policy);
+-
+-    ParamStringStream << " " << Param.Name;
+-    if (IncludeDefaultValue && Generation == eLibrary &&
+-        !Param.DefaultValueText.empty())
+-      ParamStringStream << " = "
+-                        << lldb_rpc_gen::ReplaceLLDBNamespaceWithRPCNamespace(
+-                               Param.DefaultValueText);
+-
+-    ParamList.push_back(ParamString);
+-  }
+-
+-  return llvm::join(ParamList, ", ");
+-}
+-
+-bool lldb_rpc_gen::Method::RequiresConnectionParameter() const {
+-  if (!IsCtor && IsInstance)
+-    return false;
+-  if (IsCopyCtor || IsMoveCtor)
+-    return false;
+-  for (const auto &Param : Params)
+-    // We can re-use the connection from our parameter if possible.
+-    // Const-qualified parameters are input parameters and already
+-    // have a valid connection to provide to the current method.
+-    if (TypeIsSBClass(Param.Type) &&
+-        GetUnderlyingType(Param.Type).isConstQualified())
+-      return false;
+-
+-  return true;
+-}
+diff -ruN --strip-trailing-cr a/lldb/tools/lldb-rpc/lldb-rpc-gen/RPCCommon.h b/lldb/tools/lldb-rpc/lldb-rpc-gen/RPCCommon.h
+--- a/lldb/tools/lldb-rpc/lldb-rpc-gen/RPCCommon.h
++++ b/lldb/tools/lldb-rpc/lldb-rpc-gen/RPCCommon.h
+@@ -1,108 +0,0 @@
+-//===-- RPCCommon.h -------------------------------------------------------===//
+-//
+-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+-// See https://llvm.org/LICENSE.txt for license information.
+-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+-//
+-//===----------------------------------------------------------------------===//
+-
+-#ifndef LLDB_RPC_GEN_RPCCOMMON_H
+-#define LLDB_RPC_GEN_RPCCOMMON_H
+-
+-#include "clang/AST/AST.h"
+-#include "clang/AST/ASTContext.h"
+-#include "clang/AST/DeclCXX.h"
+-#include "llvm/Support/ToolOutputFile.h"
+-#include "llvm/Support/raw_ostream.h"
+-
+-#include <string>
+-
+-using namespace clang;
+-
+-namespace lldb_rpc_gen {
+-QualType GetUnderlyingType(QualType T);
+-QualType GetUnqualifiedUnderlyingType(QualType T);
+-std::string GetMangledName(ASTContext &Context, CXXMethodDecl *MDecl);
+-
+-bool TypeIsFromLLDBPrivate(QualType T);
+-bool TypeIsSBClass(QualType T);
+-bool TypeIsConstCharPtr(QualType T);
+-bool TypeIsConstCharPtrPtr(QualType T);
+-bool TypeIsDisallowedClass(QualType T);
+-bool TypeIsCallbackFunctionPointer(QualType T);
+-
+-bool MethodIsDisallowed(ASTContext &Context, CXXMethodDecl *MDecl);
+-bool HasCallbackParameter(CXXMethodDecl *MDecl);
+-
+-std::string ReplaceLLDBNamespaceWithRPCNamespace(std::string Name);
+-std::string StripLLDBNamespace(std::string Name);
+-bool SBClassRequiresDefaultCtor(const std::string &ClassName);
+-bool SBClassRequiresCopyCtorAssign(const std::string &ClassName);
+-bool SBClassInheritsFromObjectRef(const std::string &ClassName);
+-std::string GetSBClassNameFromType(QualType T);
+-struct Param {
+-  std::string Name;
+-  QualType Type;
+-  std::string DefaultValueText;
+-  bool IsFollowedByLen;
+-};
+-
+-enum GenerationKind : bool { eServer, eLibrary };
+-
+-struct Method {
+-  enum Type { eOther, eConstructor, eDestructor };
+-
+-  Method(CXXMethodDecl *MDecl, const PrintingPolicy &Policy,
+-         ASTContext &Context);
+-
+-  // Adding a '<' allows us to use Methods in ordered containers.
+-  // The ordering is on memory addresses.
+-  bool operator<(const lldb_rpc_gen::Method &rhs) const;
+-  const PrintingPolicy &Policy;
+-  const ASTContext &Context;
+-  std::string QualifiedName;
+-  std::string BaseName;
+-  std::string MangledName;
+-  QualType ReturnType;
+-  QualType ThisType;
+-  std::vector<Param> Params;
+-  bool IsConst = false;
+-  bool IsInstance = false;
+-  bool IsCtor = false;
+-  bool IsCopyCtor = false;
+-  bool IsCopyAssign = false;
+-  bool IsMoveCtor = false;
+-  bool IsMoveAssign = false;
+-  bool IsDtor = false;
+-  bool IsConversionMethod = false;
+-  bool IsExplicitCtorOrConversionMethod = false;
+-  bool ContainsFunctionPointerParameter = false;
+-
+-  std::string CreateParamListAsString(GenerationKind Generation,
+-                                      bool IncludeDefaultValue = false) const;
+-
+-  bool RequiresConnectionParameter() const;
+-};
+-
+-std::string
+-GetDefaultArgumentsForConstructor(std::string ClassName,
+-                                  const lldb_rpc_gen::Method &method);
+-
+-class FileEmitter {
+-protected:
+-  FileEmitter(std::unique_ptr<llvm::ToolOutputFile> &&OutputFile)
+-      : OutputFile(std::move(OutputFile)), IndentLevel(0) {}
+-  void EmitLine(const std::string &line) {
+-    for (auto i = 0; i < IndentLevel; i++)
+-      OutputFile->os() << "  ";
+-
+-    OutputFile->os() << line << "\n";
+-  }
+-
+-  void EmitNewLine() { OutputFile->os() << "\n"; }
+-
+-  std::unique_ptr<llvm::ToolOutputFile> OutputFile;
+-  uint8_t IndentLevel;
+-};
+-} // namespace lldb_rpc_gen
+-#endif // LLDB_RPC_GEN_RPCCOMMON_H
+diff -ruN --strip-trailing-cr a/lldb/tools/lldb-rpc/LLDBRPCGeneration.cmake b/lldb/tools/lldb-rpc/LLDBRPCGeneration.cmake
+--- a/lldb/tools/lldb-rpc/LLDBRPCGeneration.cmake
++++ b/lldb/tools/lldb-rpc/LLDBRPCGeneration.cmake
+@@ -1,60 +0,0 @@
+-if (NOT DEFINED LLDB_RPC_GEN_EXE)
+-  message(FATAL_ERROR
+-    "Unable to generate lldb-rpc sources because LLDB_RPC_GEN_EXE is not
+-    defined. If you are cross-compiling, please build lldb-rpc-gen for your host
+-    platform.")
+-endif()
+-set(lldb_rpc_generated_dir "${CMAKE_CURRENT_BINARY_DIR}/generated")
+-
+-file(GLOB api_headers ${LLDB_SOURCE_DIR}/include/lldb/API/SB*.h)
+-# We don't generate SBCommunication
+-list(REMOVE_ITEM api_headers ${LLDB_SOURCE_DIR}/include/lldb/API/SBCommunication.h)
+-# SBDefines.h is mostly definitions and forward declarations, nothing to
+-# generate.
+-list(REMOVE_ITEM api_headers ${LLDB_SOURCE_DIR}/include/lldb/API/SBDefines.h)
+-
+-# Generate the list of byproducts. Note that we cannot just glob the files in
+-# the directory with the generated sources because BYPRODUCTS needs to be known
+-# at configure time but the files are generated at build time.
+-set(lldb_rpc_gen_byproducts
+-  ${lldb_rpc_generated_dir}/SBClasses.def
+-  ${lldb_rpc_generated_dir}/SBAPI.def
+-  ${lldb_rpc_generated_dir}/lldb.py
+-  ${lldb_rpc_server_generated_source_dir}/SBAPI.h
+-)
+-
+-# Make sure that the clang-resource-dir is set correctly or else the tool will
+-# fail to run. This is only needed when we do a standalone build.
+-set(clang_resource_dir_arg)
+-if (LLDB_BUILT_STANDALONE)
+-  if (TARGET clang-resource-headers)
+-    set(clang_resource_headers_dir
+-      $<TARGET_PROPERTY:clang-resource-headers,INTERFACE_INCLUDE_DIRECTORIES>)
+-    set(clang_resource_dir_arg --extra-arg="-resource-dir=${clang_resource_headers_dir}/..")
+-  else()
+-    set(clang_resource_dir_arg --extra-arg="-resource-dir=${LLDB_EXTERNAL_CLANG_RESOURCE_DIR}")
+-  endif()
+-endif()
+-
+-add_custom_command(OUTPUT ${lldb_rpc_gen_byproducts}
+-  COMMAND ${CMAKE_COMMAND} -E make_directory
+-    ${lldb_rpc_generated_dir}
+-
+-  COMMAND ${LLDB_RPC_GEN_EXE}
+-    -p ${CMAKE_BINARY_DIR}
+-    --output-dir=${lldb_rpc_generated_dir}
+-    ${clang_resource_dir_arg}
+-    --extra-arg="-USWIG"
+-    ${api_headers}
+-
+-  DEPENDS ${LLDB_RPC_GEN_EXE} ${api_headers}
+-  COMMENT "Generating sources for lldb-rpc-server..."
+-  WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
+-)
+-
+-add_custom_target(lldb-rpc-generate-sources
+-  DEPENDS
+-    ${lldb_rpc_gen_byproducts}
+-    lldb-sbapi-dwarf-enums)
+-
+-add_dependencies(lldb-rpc-generate-sources clang-resource-headers)
+diff -ruN --strip-trailing-cr a/lldb/tools/lldb-rpc/LLDBRPCHeaders.cmake b/lldb/tools/lldb-rpc/LLDBRPCHeaders.cmake
+--- a/lldb/tools/lldb-rpc/LLDBRPCHeaders.cmake
++++ b/lldb/tools/lldb-rpc/LLDBRPCHeaders.cmake
+@@ -1,101 +0,0 @@
+-set(derived_headers_location "${CMAKE_CURRENT_BINARY_DIR}/DerivedHeaders")
+-
+-# Obtain the original headers from their staged location in the build directory.
+-set(original_headers_location "${CMAKE_BINARY_DIR}/include/lldb")
+-set(headers_to_process
+-  SBDefines.h
+-  lldb-defines.h
+-  lldb-enumerations.h
+-  lldb-types.h
+-)
+-
+-file(MAKE_DIRECTORY ${derived_headers_location})
+-
+-# Take the original headers and convert them RPC as necessary using the conversion script.
+-set(original_headers)
+-set(derived_headers)
+-foreach(header ${headers_to_process})
+-  set(original_header "${original_headers_location}/${header}")
+-
+-  get_filename_component(header_filename ${header} NAME)
+-  string(REPLACE "lldb-" "lldb-rpc-" rpc_header_filename "${header_filename}")
+-  set(derived_header "${derived_headers_location}/${rpc_header_filename}")
+-
+-  list(APPEND original_headers "${original_header}")
+-  list(APPEND derived_headers "${derived_header}")
+-  add_custom_command(OUTPUT ${derived_header}
+-    COMMAND ${Python3_EXECUTABLE} ${LLDB_SOURCE_DIR}/scripts/convert-lldb-header-to-rpc-header.py
+-            ${original_header} ${derived_header}
+-    DEPENDS ${original_header}
+-
+-    COMMENT "Creating ${derived_header}"
+-  )
+-endforeach()
+-
+-# Do the same thing for any header files that were autogenerated.
+-set(generated_headers_to_process
+-  API/SBLanguages.h
+-)
+-foreach(header ${generated_headers_to_process})
+-  set(original_header "${LLDB_OBJ_DIR}/include/lldb/${header}")
+-
+-  get_filename_component(header_filename ${header} NAME)
+-  string(REPLACE "lldb-" "lldb-rpc-" rpc_header_filename "${header_filename}")
+-  set(derived_header "${derived_headers_location}/${rpc_header_filename}")
+-
+-  list(APPEND original_headers "${original_header}")
+-  list(APPEND derived_headers "${derived_header}")
+-  add_custom_command(OUTPUT ${derived_header}
+-    COMMAND ${CMAKE_COMMAND} -E copy ${original_header} ${derived_header}
+-    COMMAND ${Python3_EXECUTABLE} ${LLDB_SOURCE_DIR}/scripts/convert-lldb-header-to-rpc-header.py
+-            ${original_header} ${derived_header}
+-    DEPENDS lldb-sbapi-dwarf-enums
+-
+-    COMMENT "Creating ${derived_header}"
+-  )
+-endforeach()
+-
+-add_custom_target(copy-aux-rpc-headers DEPENDS ${derived_headers})
+-add_dependencies(copy-aux-rpc-headers liblldb-header-staging)
+-
+-list(APPEND public_headers
+-  ${derived_headers_location}/SBDefines.h
+-  ${derived_headers_location}/SBLanguages.h
+-  ${derived_headers_location}/lldb-rpc-enumerations.h
+-  ${derived_headers_location}/lldb-rpc-types.h
+-  ${derived_headers_location}/lldb-rpc-defines.h
+-)
+-
+-# Collect and preprocess headers for the framework bundle
+-set(version_header
+-  ${derived_headers_location}/lldb-rpc-defines.h
+-)
+-
+-function(FixIncludePaths in subfolder out)
+-  get_filename_component(base_name ${in} NAME)
+-  set(parked_header ${CMAKE_CURRENT_BINARY_DIR}/ParkedHeaders/${subfolder}/${base_name})
+-  set(${out} ${parked_header} PARENT_SCOPE)
+-  find_program(unifdef_EXECUTABLE unifdef)
+-
+-  add_custom_command(OUTPUT ${parked_header}
+-    COMMAND ${LLDB_SOURCE_DIR}/scripts/framework-header-fix.py
+-            -f lldb_rpc -i ${in} -o ${parked_header} -p ${unifdef_EXECUTABLE} USWIG
+-    DEPENDS ${in}
+-    COMMENT "Fixing includes in ${in}"
+-  )
+-endfunction()
+-
+-set(preprocessed_headers)
+-
+-# Apply include-paths fix and any version fix on all headers and park them.
+-foreach(source_header ${public_headers})
+-  FixIncludePaths(${source_header} Headers parked_header)
+-  list(APPEND preprocessed_headers ${parked_header})
+-endforeach()
+-
+-# Wrap header preprocessing in a target, so liblldbrpc can depend on.
+-add_custom_target(liblldbrpc-headers DEPENDS ${preprocessed_headers})
+-add_dependencies(liblldbrpc-headers copy-aux-rpc-headers liblldb-header-staging)
+-set_target_properties(liblldbrpc-headers PROPERTIES
+-  LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/ParkedHeaders
+-)
 diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
 --- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
 +++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
-@@ -10101,8 +10101,7 @@
+@@ -10140,8 +10140,7 @@
    // Get user vectorization factor and interleave count.
    ElementCount UserVF = Hints.getWidth();
    unsigned UserIC = Hints.getInterleave();
@@ -349,31 +1528,6 @@ diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/Vectorize/VPlanUnroll.cpp b/
    New->insertBefore(RepR);
    return New;
  }
-diff -ruN --strip-trailing-cr a/llvm/test/CodeGen/X86/dag-combiner-fma-folding.ll b/llvm/test/CodeGen/X86/dag-combiner-fma-folding.ll
---- a/llvm/test/CodeGen/X86/dag-combiner-fma-folding.ll
-+++ b/llvm/test/CodeGen/X86/dag-combiner-fma-folding.ll
-@@ -1,5 +1,6 @@
- ; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
- ; RUN: llc -mtriple=x86_64-- --start-before=x86-isel -mattr=+avx,+fma %s -o - | FileCheck %s
-+; RUN: llc -mtriple=x86_64-- --start-before=x86-isel -mattr=+avx,+fma %s -o - -fp-contract=fast | FileCheck %s
- 
- define double @fma_folding(double %x) {
- ; CHECK-LABEL: fma_folding:
-@@ -20,3 +21,14 @@
-   %fused = call contract nnan ninf double @llvm.fma.f64(double %x, double 0.0, double -0.0)
-   ret double %fused
- }
-+
-+define double @fma_no_fold_potential_nan(double %x) {
-+; CHECK-LABEL: fma_no_fold_potential_nan:
-+; CHECK:       # %bb.0:
-+; CHECK-NEXT:    vxorpd %xmm1, %xmm1, %xmm1
-+; CHECK-NEXT:    vfmadd213sd {{.*#+}} xmm0 = (xmm1 * xmm0) + mem
-+; CHECK-NEXT:    retq
-+ %fused = call contract double @llvm.fma.f64(double %x, double 0.0, double 1.0)
-+ ret double %fused
-+}
-+
 diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LoopVectorize/AArch64/single-early-exit-interleave.ll b/llvm/test/Transforms/LoopVectorize/AArch64/single-early-exit-interleave.ll
 --- a/llvm/test/Transforms/LoopVectorize/AArch64/single-early-exit-interleave.ll
 +++ b/llvm/test/Transforms/LoopVectorize/AArch64/single-early-exit-interleave.ll
@@ -1253,3 +2407,22 @@ diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LoopVectorize/X86/drop-pois
 +attributes #1 = { "target-features"="+avx" }
  
  !0 = !{}
+diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/libc/BUILD.bazel b/utils/bazel/llvm-project-overlay/libc/BUILD.bazel
+--- a/utils/bazel/llvm-project-overlay/libc/BUILD.bazel
++++ b/utils/bazel/llvm-project-overlay/libc/BUILD.bazel
+@@ -752,6 +752,7 @@
+     name = "__support_blockstore",
+     hdrs = ["src/__support/blockstore.h"],
+     deps = [
++        ":__support_cpp_array",
+         ":__support_cpp_new",
+         ":__support_libc_assert",
+     ],
+@@ -1681,6 +1682,7 @@
+         ":__support_cpp_optional",
+         ":__support_macros_attributes",
+         ":__support_macros_config",
++        ":types_wint_t",
+     ],
+ )
+ 
diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl
index 02047a0..f768157 100644
--- a/third_party/llvm/workspace.bzl
+++ b/third_party/llvm/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive")
 
 def repo(name):
     """Imports LLVM."""
-    LLVM_COMMIT = "f8cb7987c64dcffb72414a40560055cb717dbf74"
-    LLVM_SHA256 = "2fb69c816106c22518a9b677d5daa7fed900187a84ad0be26453f5763ee88424"
+    LLVM_COMMIT = "2910c24638fcbc3dec02be072e6026d01012d946"
+    LLVM_SHA256 = "c340aa54c39af4ae28986e4266a72a22e2f0d1b8afd5605bb7f78fbc205d1e1e"
 
     tf_http_archive(
         name = name,
