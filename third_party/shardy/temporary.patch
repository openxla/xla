diff --git a/third_party/llvm/bufferization.patch b/third_party/llvm/bufferization.patch
deleted file mode 100644
index 4cf6d00..0000000
--- a/third_party/llvm/bufferization.patch
+++ /dev/null
@@ -1,22 +0,0 @@
-diff --git a/mlir/lib/Dialect/Bufferization/IR/BufferizationOps.cpp b/mlir/lib/Dialect/Bufferization/IR/BufferizationOps.cpp
-index 7eb729f34963..f1f12f4bca70 100644
---- a/mlir/lib/Dialect/Bufferization/IR/BufferizationOps.cpp
-+++ b/mlir/lib/Dialect/Bufferization/IR/BufferizationOps.cpp
-@@ -806,14 +806,12 @@ struct ToBufferOfCast : public OpRewritePattern<ToBufferOp> {
-     if (!srcTensorType)
-       return failure();
-     auto currentOutputMemRefType =
--        dyn_cast<MemRefType>(toBuffer.getResult().getType());
-+        dyn_cast<BaseMemRefType>(toBuffer.getResult().getType());
-     if (!currentOutputMemRefType)
-       return failure();
- 
--    auto memrefType = MemRefType::get(srcTensorType.getShape(),
--                                      srcTensorType.getElementType(),
--                                      currentOutputMemRefType.getLayout(),
--                                      currentOutputMemRefType.getMemorySpace());
-+    auto memrefType = currentOutputMemRefType.cloneWith(
-+        srcTensorType.getShape(), srcTensorType.getElementType());
-     Value memref = ToBufferOp::create(rewriter, toBuffer.getLoc(), memrefType,
-                                       tensorCastOperand.getOperand(),
-                                       toBuffer.getReadOnly());
diff --git a/third_party/llvm/generated.patch b/third_party/llvm/generated.patch
index 4fd42f9..9395279 100644
--- a/third_party/llvm/generated.patch
+++ b/third_party/llvm/generated.patch
@@ -1,4 +1,23 @@
 Auto generated patch. Do not edit or delete it, even if empty.
+diff -ruN --strip-trailing-cr a/clang/lib/Headers/cpuid.h b/clang/lib/Headers/cpuid.h
+--- a/clang/lib/Headers/cpuid.h
++++ b/clang/lib/Headers/cpuid.h
+@@ -345,10 +345,15 @@
+ // In some configurations, __cpuidex is defined as a builtin (primarily
+ // -fms-extensions) which will conflict with the __cpuidex definition below.
+ #if !(__has_builtin(__cpuidex))
++// In some cases, offloading will set the host as the aux triple and define the
++// builtin. Given __has_builtin does not detect builtins on aux triples, we need
++// to explicitly check for some offloading cases.
++#ifndef __NVPTX__
+ static __inline void __cpuidex(int __cpu_info[4], int __leaf, int __subleaf) {
+   __cpuid_count(__leaf, __subleaf, __cpu_info[0], __cpu_info[1], __cpu_info[2],
+                 __cpu_info[3]);
+ }
+ #endif
++#endif
+ 
+ #endif /* __CPUID_H */
 diff -ruN --strip-trailing-cr a/clang/lib/Sema/AnalysisBasedWarnings.cpp b/clang/lib/Sema/AnalysisBasedWarnings.cpp
 --- a/clang/lib/Sema/AnalysisBasedWarnings.cpp
 +++ b/clang/lib/Sema/AnalysisBasedWarnings.cpp
@@ -15,6 +34,41 @@ diff -ruN --strip-trailing-cr a/clang/lib/Sema/AnalysisBasedWarnings.cpp b/clang
      // First check the current block.
      for (CFGBlock::const_reverse_iterator ri = B->rbegin(), re = B->rend();
           ri != re; ++ri) {
+diff -ruN --strip-trailing-cr a/clang/test/Headers/__cpuidex_conflict.c b/clang/test/Headers/__cpuidex_conflict.c
+--- a/clang/test/Headers/__cpuidex_conflict.c
++++ b/clang/test/Headers/__cpuidex_conflict.c
+@@ -1,19 +1,18 @@
+ // Make sure that __cpuidex in cpuid.h doesn't conflict with the MS
+ // extensions built in by ensuring compilation succeeds:
+-// RUN: %clang_cc1 %s -ffreestanding -fms-extensions -fms-compatibility \
+-// RUN:  -fms-compatibility-version=19.00 -triple x86_64-pc-windows-msvc -emit-llvm -o -
+-// %clang_cc1 %s -ffreestanding -triple x86_64-w64-windows-gnu -fms-extensions -emit-llvm -o -
+-//
+-// FIXME: See https://github.com/llvm/llvm-project/pull/121839 and
+-// FIXME: https://github.com/llvm/llvm-project/pull/126324
+-// RUN: not %clang_cc1 %s -ffreestanding -fopenmp -fopenmp-is-target-device -aux-triple x86_64-unknown-linux-gnu
++// RUN: %clang_cc1 %s -DIS_STATIC="" -ffreestanding -fms-extensions -fms-compatibility -fms-compatibility-version=19.00 -triple x86_64-pc-windows-msvc -emit-llvm -o -
++// RUN: %clang_cc1 %s -DIS_STATIC="" -ffreestanding -triple x86_64-w64-windows-gnu -fms-extensions -emit-llvm -o -
++
++// Ensure that we do not run into conflicts when offloading.
++// RUN: %clang_cc1 %s -DIS_STATIC=static -ffreestanding -fopenmp -fopenmp-is-target-device -aux-triple x86_64-unknown-linux-gnu
++// RUN: %clang_cc1 -DIS_STATIC="" -triple nvptx64-nvidia-cuda -aux-triple x86_64-unknown-linux-gnu -aux-target-cpu x86-64 -fcuda-is-device -internal-isystem /home/gha/llvm-project/build/lib/clang/22/include -x cuda %s -o -
+ 
+ typedef __SIZE_TYPE__ size_t;
+ 
+ // We declare __cpuidex here as where the buitlin should be exposed (MSVC), the
+ // declaration is in <intrin.h>, but <intrin.h> is not available from all the
+ // targets that are being tested here.
+-void __cpuidex (int[4], int, int);
++IS_STATIC void __cpuidex (int[4], int, int);
+ 
+ #include <cpuid.h>
+ 
+@@ -22,4 +21,3 @@
+ void test_cpuidex(unsigned level, unsigned count) {
+   __cpuidex(cpuid_info, level, count);
+ }
+-
 diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/noreturn-weverything.c b/clang/test/SemaCXX/noreturn-weverything.c
 --- a/clang/test/SemaCXX/noreturn-weverything.c
 +++ b/clang/test/SemaCXX/noreturn-weverything.c
@@ -34,6 +88,144 @@ diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/noreturn-weverything.c b/clan
 +    if (data && free_func)
 +        free_func(data);
 +}
+diff -ruN --strip-trailing-cr a/libc/src/__support/FPUtil/rounding_mode.h b/libc/src/__support/FPUtil/rounding_mode.h
+--- a/libc/src/__support/FPUtil/rounding_mode.h
++++ b/libc/src/__support/FPUtil/rounding_mode.h
+@@ -17,30 +17,24 @@
+ namespace LIBC_NAMESPACE_DECL {
+ namespace fputil {
+ 
++namespace generic {
++
+ // Quick free-standing test whether fegetround() == FE_UPWARD.
+ // Using the following observation:
+ //   1.0f + 2^-25 = 1.0f        for FE_TONEAREST, FE_DOWNWARD, FE_TOWARDZERO
+ //                = 0x1.000002f for FE_UPWARD.
+-LIBC_INLINE static constexpr bool fenv_is_round_up() {
+-  if (cpp::is_constant_evaluated()) {
+-    return false;
+-  } else {
+-    volatile float x = 0x1.0p-25f;
+-    return (1.0f + x != 1.0f);
+-  }
++LIBC_INLINE bool fenv_is_round_up() {
++  static volatile float x = 0x1.0p-25f;
++  return (1.0f + x != 1.0f);
+ }
+ 
+ // Quick free-standing test whether fegetround() == FE_DOWNWARD.
+ // Using the following observation:
+ //   -1.0f - 2^-25 = -1.0f        for FE_TONEAREST, FE_UPWARD, FE_TOWARDZERO
+ //                 = -0x1.000002f for FE_DOWNWARD.
+-LIBC_INLINE static constexpr bool fenv_is_round_down() {
+-  if (cpp::is_constant_evaluated()) {
+-    return false;
+-  } else {
+-    volatile float x = 0x1.0p-25f;
+-    return (-1.0f - x != -1.0f);
+-  }
++LIBC_INLINE bool fenv_is_round_down() {
++  static volatile float x = 0x1.0p-25f;
++  return (-1.0f - x != -1.0f);
+ }
+ 
+ // Quick free-standing test whether fegetround() == FE_TONEAREST.
+@@ -49,14 +43,10 @@
+ //                = 0x1.100002p0f  for FE_UPWARD,
+ //   1.5f - 2^-24 = 1.5f           for FE_TONEAREST, FE_UPWARD
+ //                = 0x1.0ffffep-1f for FE_DOWNWARD, FE_TOWARDZERO
+-LIBC_INLINE static constexpr bool fenv_is_round_to_nearest() {
+-  if (cpp::is_constant_evaluated()) {
+-    return true;
+-  } else {
+-    volatile float x = 0x1.0p-24f;
+-    float y = 1.5f + x;
+-    return (y == 1.5f - x);
+-  }
++LIBC_INLINE bool fenv_is_round_to_nearest() {
++  static volatile float x = 0x1.0p-24f;
++  float y = 1.5f + x;
++  return (y == 1.5f - x);
+ }
+ 
+ // Quick free-standing test whether fegetround() == FE_TOWARDZERO.
+@@ -69,13 +59,56 @@
+ // (0x1.000002p0f + 2^-24) + (-1.0f - 2^-24) = 2^-23 for FE_TOWARDZERO
+ //                                           = 2^-22 for FE_TONEAREST, FE_UPWARD
+ //                                           = 0 for FE_DOWNWARD
++LIBC_INLINE bool fenv_is_round_to_zero() {
++  static volatile float x = 0x1.0p-24f;
++  float y = x;
++  return ((0x1.000002p0f + y) + (-1.0f - y) == 0x1.0p-23f);
++}
++
++// Quick free standing get rounding mode based on the above observations.
++LIBC_INLINE int quick_get_round() {
++  static volatile float x = 0x1.0p-24f;
++  float y = x;
++  float z = (0x1.000002p0f + y) + (-1.0f - y);
++
++  if (z == 0.0f)
++    return FE_DOWNWARD;
++  if (z == 0x1.0p-23f)
++    return FE_TOWARDZERO;
++  return (2.0f + y == 2.0f) ? FE_TONEAREST : FE_UPWARD;
++}
++
++} // namespace generic
++
++LIBC_INLINE static constexpr bool fenv_is_round_up() {
++  if (cpp::is_constant_evaluated()) {
++    return false;
++  } else {
++    return generic::fenv_is_round_up();
++  }
++}
++
++LIBC_INLINE static constexpr bool fenv_is_round_down() {
++  if (cpp::is_constant_evaluated()) {
++    return false;
++  } else {
++    return generic::fenv_is_round_down();
++  }
++}
++
++LIBC_INLINE static constexpr bool fenv_is_round_to_nearest() {
++  if (cpp::is_constant_evaluated()) {
++    return true;
++  } else {
++    return generic::fenv_is_round_to_nearest();
++  }
++}
++
+ LIBC_INLINE static constexpr bool fenv_is_round_to_zero() {
+   if (cpp::is_constant_evaluated()) {
+     return false;
+   } else {
+-    volatile float x = 0x1.0p-24f;
+-    volatile float y = 0x1.000002p0f + x;
+-    return (y + (-1.0f - x) == 0x1.0p-23f);
++    return generic::fenv_is_round_to_zero();
+   }
+ }
+ 
+@@ -84,15 +117,7 @@
+   if (cpp::is_constant_evaluated()) {
+     return FE_TONEAREST;
+   } else {
+-    volatile float x = 0x1.0p-24f;
+-    volatile float y = 0x1.000002p0f + x;
+-    float z = y + (-1.0f - x);
+-
+-    if (z == 0.0f)
+-      return FE_DOWNWARD;
+-    if (z == 0x1.0p-23f)
+-      return FE_TOWARDZERO;
+-    return (2.0f + x == 2.0f) ? FE_TONEAREST : FE_UPWARD;
++    return generic::quick_get_round();
+   }
+ }
+ 
 diff -ruN --strip-trailing-cr a/llvm/include/llvm/MC/MCObjectStreamer.h b/llvm/include/llvm/MC/MCObjectStreamer.h
 --- a/llvm/include/llvm/MC/MCObjectStreamer.h
 +++ b/llvm/include/llvm/MC/MCObjectStreamer.h
@@ -608,6 +800,27 @@ diff -ruN --strip-trailing-cr a/llvm/test/MC/ELF/many-instructions.s b/llvm/test
 -.rept 16384/10
 -movabsq $foo, %rax
 -.endr
+diff -ruN --strip-trailing-cr a/mlir/lib/Dialect/Bufferization/IR/BufferizationOps.cpp b/mlir/lib/Dialect/Bufferization/IR/BufferizationOps.cpp
+--- a/mlir/lib/Dialect/Bufferization/IR/BufferizationOps.cpp
++++ b/mlir/lib/Dialect/Bufferization/IR/BufferizationOps.cpp
+@@ -806,14 +806,12 @@
+     if (!srcTensorType)
+       return failure();
+     auto currentOutputMemRefType =
+-        dyn_cast<MemRefType>(toBuffer.getResult().getType());
++        dyn_cast<BaseMemRefType>(toBuffer.getResult().getType());
+     if (!currentOutputMemRefType)
+       return failure();
+ 
+-    auto memrefType = MemRefType::get(srcTensorType.getShape(),
+-                                      srcTensorType.getElementType(),
+-                                      currentOutputMemRefType.getLayout(),
+-                                      currentOutputMemRefType.getMemorySpace());
++    auto memrefType = currentOutputMemRefType.cloneWith(
++        srcTensorType.getShape(), srcTensorType.getElementType());
+     Value memref = ToBufferOp::create(rewriter, toBuffer.getLoc(), memrefType,
+                                       tensorCastOperand.getOperand(),
+                                       toBuffer.getReadOnly());
 diff -ruN --strip-trailing-cr a/mlir/lib/IR/MLIRContext.cpp b/mlir/lib/IR/MLIRContext.cpp
 --- a/mlir/lib/IR/MLIRContext.cpp
 +++ b/mlir/lib/IR/MLIRContext.cpp
@@ -672,6 +885,29 @@ diff -ruN --strip-trailing-cr a/mlir/lib/Parser/Parser.cpp b/mlir/lib/Parser/Par
    }
    if (isBytecode(*sourceBuf))
      return readBytecodeFile(sourceMgr, block, config);
+diff -ruN --strip-trailing-cr a/mlir/test/Dialect/Bufferization/canonicalize.mlir b/mlir/test/Dialect/Bufferization/canonicalize.mlir
+--- a/mlir/test/Dialect/Bufferization/canonicalize.mlir
++++ b/mlir/test/Dialect/Bufferization/canonicalize.mlir
+@@ -263,6 +263,19 @@
+ // CHECK-SAME: memref<4x6x16x32xi8> to memref<?x?x16x32xi8>
+ // CHECK:   return %[[M1]] : memref<?x?x16x32xi8>
+ 
++// CHECK-LABEL: func @tensor_cast_to_unranked_buffer
++//  CHECK-SAME:   %[[ARG0:.+]]: tensor<4x6x16x32xi8>
++func.func @tensor_cast_to_unranked_buffer(%arg0 : tensor<4x6x16x32xi8>) ->
++  memref<*xi8> {
++  %0 = tensor.cast %arg0 : tensor<4x6x16x32xi8> to tensor<*xi8>
++  %1 = bufferization.to_buffer %0 read_only : tensor<*xi8> to memref<*xi8>
++  return %1 : memref<*xi8>
++}
++// CHECK:   %[[M:.+]] = bufferization.to_buffer %[[ARG0]] read_only : tensor<4x6x16x32xi8>
++// CHECK:   %[[M1:.+]] = memref.cast %[[M]]
++// CHECK-SAME: memref<4x6x16x32xi8> to memref<*xi8>
++// CHECK:   return %[[M1]] : memref<*xi8>
++
+ // -----
+ 
+ // CHECK-LABEL: func @tensor_cast_to_buffer
 diff -ruN --strip-trailing-cr a/mlir/test/IR/test-clone.mlir b/mlir/test/IR/test-clone.mlir
 --- a/mlir/test/IR/test-clone.mlir
 +++ b/mlir/test/IR/test-clone.mlir
diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl
index 9dc087c..2e6de22 100644
--- a/third_party/llvm/workspace.bzl
+++ b/third_party/llvm/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive")
 
 def repo(name):
     """Imports LLVM."""
-    LLVM_COMMIT = "e68a20e0b7623738d6af736d3aa02625cba6126a"
-    LLVM_SHA256 = "2e49b6851d6625209d3db8e8d184142fc4fe549790e98292f9c8c1227d959946"
+    LLVM_COMMIT = "30ad2e24ab3392b1b1f022422255f010ed6dbd63"
+    LLVM_SHA256 = "b8ffe10685f1b50f37f1c76d468f414ab81d51e131d70172792575fb38e0bd45"
 
     tf_http_archive(
         name = name,
@@ -18,7 +18,6 @@ def repo(name):
         build_file = "//third_party/llvm:llvm.BUILD",
         patch_file = [
             "//third_party/llvm:generated.patch",  # Autogenerated, don't remove.
-            "//third_party/llvm:bufferization.patch",
             "//third_party/llvm:build.patch",
             "//third_party/llvm:mathextras.patch",
             "//third_party/llvm:toolchains.patch",
