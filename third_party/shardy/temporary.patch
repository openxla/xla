diff --git a/third_party/llvm/generated.patch b/third_party/llvm/generated.patch
index 7f5123e..704558b 100644
--- a/third_party/llvm/generated.patch
+++ b/third_party/llvm/generated.patch
@@ -1,254 +1,419 @@
 Auto generated patch. Do not edit or delete it, even if empty.
-diff -ruN --strip-trailing-cr a/llvm/include/llvm/Analysis/LoopInfo.h b/llvm/include/llvm/Analysis/LoopInfo.h
---- a/llvm/include/llvm/Analysis/LoopInfo.h
-+++ b/llvm/include/llvm/Analysis/LoopInfo.h
-@@ -59,11 +59,12 @@
-   };
- 
-   /// Return true if the specified value is loop invariant.
--  bool isLoopInvariant(const Value *V) const;
-+  bool isLoopInvariant(const Value *V, bool HasCoroSuspendInst = false) const;
- 
-   /// Return true if all the operands of the specified instruction are loop
-   /// invariant.
--  bool hasLoopInvariantOperands(const Instruction *I) const;
-+  bool hasLoopInvariantOperands(const Instruction *I,
-+                                bool HasCoroSuspendInst = false) const;
- 
-   /// If the given value is an instruction inside of the loop and it can be
-   /// hoisted, do so to make it trivially loop-invariant.
-diff -ruN --strip-trailing-cr a/llvm/include/llvm/Transforms/Utils/LoopUtils.h b/llvm/include/llvm/Transforms/Utils/LoopUtils.h
---- a/llvm/include/llvm/Transforms/Utils/LoopUtils.h
-+++ b/llvm/include/llvm/Transforms/Utils/LoopUtils.h
-@@ -185,7 +185,8 @@
-                           TargetLibraryInfo *, Loop *, MemorySSAUpdater &,
-                           ScalarEvolution *, ICFLoopSafetyInfo *,
-                           SinkAndHoistLICMFlags &, OptimizationRemarkEmitter *,
--                          bool, bool AllowSpeculation);
-+                          bool, bool AllowSpeculation,
-+                          bool HasCoroSuspendInst = false);
- 
- /// Return true if the induction variable \p IV in a Loop whose latch is
- /// \p LatchBlock would become dead if the exit test \p Cond were removed.
-diff -ruN --strip-trailing-cr a/llvm/lib/Analysis/LoopInfo.cpp b/llvm/lib/Analysis/LoopInfo.cpp
---- a/llvm/lib/Analysis/LoopInfo.cpp
-+++ b/llvm/lib/Analysis/LoopInfo.cpp
-@@ -58,14 +58,26 @@
- // Loop implementation
- //
- 
--bool Loop::isLoopInvariant(const Value *V) const {
--  if (const Instruction *I = dyn_cast<Instruction>(V))
--    return !contains(I);
-+bool Loop::isLoopInvariant(const Value *V, bool HasCoroSuspendInst) const {
-+  if (const Instruction *I = dyn_cast<Instruction>(V)) {
-+    // FIXME: this is semantically inconsistent. We're tracking a proper fix in
-+    // issue #149604.
-+    // If V is a pointer to stack object and L contains a coro.suspend function
-+    // call, then V may not be loop invariant because the ramp function and
-+    // resume function have different stack frames.
-+    if (HasCoroSuspendInst && isa<AllocaInst>(I))
-+      return false;
-+    else
-+      return !contains(I);
-+  }
-   return true; // All non-instructions are loop invariant
+diff -ruN --strip-trailing-cr a/clang/include/clang/ASTMatchers/ASTMatchers.h b/clang/include/clang/ASTMatchers/ASTMatchers.h
+--- a/clang/include/clang/ASTMatchers/ASTMatchers.h
++++ b/clang/include/clang/ASTMatchers/ASTMatchers.h
+@@ -5739,6 +5739,14 @@
+   return Builder->removeBindings(Predicate);
  }
  
--bool Loop::hasLoopInvariantOperands(const Instruction *I) const {
--  return all_of(I->operands(), [this](Value *V) { return isLoopInvariant(V); });
-+bool Loop::hasLoopInvariantOperands(const Instruction *I,
-+                                    bool HasCoroSuspendInst) const {
-+  return all_of(I->operands(), [&](Value *V) {
-+    return isLoopInvariant(V, HasCoroSuspendInst);
++/// Matches a declaration if it declares the same entity as the node previously
++/// bound to \p ID.
++AST_MATCHER_P(Decl, declaresSameEntityAsBoundNode, std::string, ID) {
++  return Builder->removeBindings([&](const internal::BoundNodesMap &Nodes) {
++    return !clang::declaresSameEntity(&Node, Nodes.getNodeAs<Decl>(ID));
 +  });
++}
++
+ /// Matches the condition variable statement in an if statement.
+ ///
+ /// Given
+diff -ruN --strip-trailing-cr a/clang/lib/AST/Decl.cpp b/clang/lib/AST/Decl.cpp
+--- a/clang/lib/AST/Decl.cpp
++++ b/clang/lib/AST/Decl.cpp
+@@ -1604,17 +1604,20 @@
+   // We have just computed the linkage for this decl. By induction we know
+   // that all other computed linkages match, check that the one we just
+   // computed also does.
+-  NamedDecl *Old = nullptr;
+-  for (auto *I : D->redecls()) {
+-    auto *T = cast<NamedDecl>(I);
+-    if (T == D)
++  // We can't assume the redecl chain is well formed at this point,
++  // so keep track of already visited declarations.
++  for (llvm::SmallPtrSet<const Decl *, 4> AlreadyVisited{D}; /**/; /**/) {
++    D = cast<NamedDecl>(const_cast<NamedDecl *>(D)->getNextRedeclarationImpl());
++    if (!AlreadyVisited.insert(D).second)
++      break;
++    if (D->isInvalidDecl())
+       continue;
+-    if (!T->isInvalidDecl() && T->hasCachedLinkage()) {
+-      Old = T;
++    if (auto OldLinkage = D->getCachedLinkage();
++        OldLinkage != Linkage::Invalid) {
++      assert(LV.getLinkage() == OldLinkage);
+       break;
+     }
+   }
+-  assert(!Old || Old->getCachedLinkage() == D->getCachedLinkage());
+ #endif
+ 
+   return LV;
+diff -ruN --strip-trailing-cr a/clang/lib/ASTMatchers/Dynamic/Registry.cpp b/clang/lib/ASTMatchers/Dynamic/Registry.cpp
+--- a/clang/lib/ASTMatchers/Dynamic/Registry.cpp
++++ b/clang/lib/ASTMatchers/Dynamic/Registry.cpp
+@@ -240,6 +240,7 @@
+   REGISTER_MATCHER(enumDecl);
+   REGISTER_MATCHER(enumType);
+   REGISTER_MATCHER(equalsBoundNode);
++  REGISTER_MATCHER(declaresSameEntityAsBoundNode);
+   REGISTER_MATCHER(equalsIntegralValue);
+   REGISTER_MATCHER(explicitCastExpr);
+   REGISTER_MATCHER(exportDecl);
+diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaDeclCXX.cpp b/clang/lib/Sema/SemaDeclCXX.cpp
+--- a/clang/lib/Sema/SemaDeclCXX.cpp
++++ b/clang/lib/Sema/SemaDeclCXX.cpp
+@@ -1373,10 +1373,13 @@
+         S.BuildReferenceType(T, E.get()->isLValue(), Loc, B->getDeclName());
+     if (RefType.isNull())
+       return true;
+-    auto *RefVD = VarDecl::Create(
+-        S.Context, Src->getDeclContext(), Loc, Loc,
+-        B->getDeclName().getAsIdentifierInfo(), RefType,
+-        S.Context.getTrivialTypeSourceInfo(T, Loc), Src->getStorageClass());
++
++    // Don't give this VarDecl a TypeSourceInfo, since this is a synthesized
++    // entity and this type was never written in source code.
++    auto *RefVD =
++        VarDecl::Create(S.Context, Src->getDeclContext(), Loc, Loc,
++                        B->getDeclName().getAsIdentifierInfo(), RefType,
++                        /*TInfo=*/nullptr, Src->getStorageClass());
+     RefVD->setLexicalDeclContext(Src->getLexicalDeclContext());
+     RefVD->setTSCSpec(Src->getTSCSpec());
+     RefVD->setImplicit();
+@@ -4565,6 +4568,7 @@
+       MarkAnyDeclReferenced(TyD->getLocation(), TyD, /*OdrUse=*/false);
+ 
+       TypeLocBuilder TLB;
++      // FIXME: This is missing building the UsingType for TyD, if any.
+       if (const auto *TD = dyn_cast<TagDecl>(TyD)) {
+         BaseType = Context.getTagType(ElaboratedTypeKeyword::None,
+                                       SS.getScopeRep(), TD, /*OwnsTag=*/false);
+@@ -4578,6 +4582,12 @@
+         TLB.push<TypedefTypeLoc>(BaseType).set(
+             /*ElaboratedKeywordLoc=*/SourceLocation(),
+             SS.getWithLocInContext(Context), IdLoc);
++      } else if (auto *UD = dyn_cast<UnresolvedUsingTypenameDecl>(TyD)) {
++        BaseType = Context.getUnresolvedUsingType(ElaboratedTypeKeyword::None,
++                                                  SS.getScopeRep(), UD);
++        TLB.push<UnresolvedUsingTypeLoc>(BaseType).set(
++            /*ElaboratedKeywordLoc=*/SourceLocation(),
++            SS.getWithLocInContext(Context), IdLoc);
+       } else {
+         // FIXME: What else can appear here?
+         assert(SS.isEmpty());
+diff -ruN --strip-trailing-cr a/clang/lib/Sema/TreeTransform.h b/clang/lib/Sema/TreeTransform.h
+--- a/clang/lib/Sema/TreeTransform.h
++++ b/clang/lib/Sema/TreeTransform.h
+@@ -5417,6 +5417,7 @@
+   case TypeLoc::Typedef:
+   case TypeLoc::TemplateSpecialization:
+   case TypeLoc::SubstTemplateTypeParm:
++  case TypeLoc::SubstTemplateTypeParmPack:
+   case TypeLoc::PackIndexing:
+   case TypeLoc::Enum:
+   case TypeLoc::Record:
+@@ -7668,8 +7669,11 @@
+   } else if (isa<TypedefType>(Result)) {
+     TLB.push<TypedefTypeLoc>(Result).set(TL.getElaboratedKeywordLoc(),
+                                          QualifierLoc, TL.getNameLoc());
++  } else if (isa<UnresolvedUsingType>(Result)) {
++    auto NewTL = TLB.push<UnresolvedUsingTypeLoc>(Result);
++    NewTL.set(TL.getElaboratedKeywordLoc(), QualifierLoc, TL.getNameLoc());
+   } else {
+-    DependentNameTypeLoc NewTL = TLB.push<DependentNameTypeLoc>(Result);
++    auto NewTL = TLB.push<DependentNameTypeLoc>(Result);
+     NewTL.setElaboratedKeywordLoc(TL.getElaboratedKeywordLoc());
+     NewTL.setQualifierLoc(QualifierLoc);
+     NewTL.setNameLoc(TL.getNameLoc());
+diff -ruN --strip-trailing-cr a/clang/test/Analysis/anonymous-decls.cpp b/clang/test/Analysis/anonymous-decls.cpp
+--- a/clang/test/Analysis/anonymous-decls.cpp
++++ b/clang/test/Analysis/anonymous-decls.cpp
+@@ -78,12 +78,12 @@
+ // CHECK-NEXT:   8: decomposition-a-b
+ // CHECK-NEXT:   9: [B3.7]([B3.8])
+ // CHECK-NEXT:  10: [B3.9]
+-// CHECK-NEXT:  11: std::tuple_element<0UL, std::pair<int, int>>::type a = get<0UL>(decomposition-a-b);
++// CHECK-NEXT:  11: std::tuple_element<0UL, std::pair<int, int>>::type &&a = get<0UL>(decomposition-a-b);
+ // CHECK-NEXT:  12: get<1UL>
+ // CHECK-NEXT:  13: [B3.12] (ImplicitCastExpr, FunctionToPointerDecay, tuple_element<1L, pair<int, int> >::type (*)(pair<int, int> &))
+ // CHECK-NEXT:  14: decomposition-a-b
+ // CHECK-NEXT:  15: [B3.13]([B3.14])
+ // CHECK-NEXT:  16: [B3.15]
+-// CHECK-NEXT:  17: std::tuple_element<1UL, std::pair<int, int>>::type b = get<1UL>(decomposition-a-b);
++// CHECK-NEXT:  17: std::tuple_element<1UL, std::pair<int, int>>::type &&b = get<1UL>(decomposition-a-b);
+ // CHECK-NEXT:   Preds (1): B1
+ // CHECK-NEXT:   Succs (1): B2
+diff -ruN --strip-trailing-cr a/clang/test/Modules/GH153933.cpp b/clang/test/Modules/GH153933.cpp
+--- a/clang/test/Modules/GH153933.cpp
++++ b/clang/test/Modules/GH153933.cpp
+@@ -0,0 +1,23 @@
++// RUN: rm -rf %t
++// RUN: mkdir -p %t
++// RUN: split-file %s %t
++//
++// RUN: %clang_cc1 -std=c++20 %t/B.cppm -emit-module-interface -o %t/B.pcm
++// RUN: %clang_cc1 -std=c++20 -fsyntax-only -fprebuilt-module-path=%t %t/C.cpp
++
++//--- A.hpp
++template<class> struct A {};
++template<class T> struct B {
++  virtual A<T> v() { return {}; }
++};
++B<void> x;
++
++//--- B.cppm
++module;
++#include "A.hpp"
++export module B;
++using ::x;
++
++//--- C.cpp
++#include "A.hpp"
++import B;
+diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/using-decl-templates.cpp b/clang/test/SemaCXX/using-decl-templates.cpp
+--- a/clang/test/SemaCXX/using-decl-templates.cpp
++++ b/clang/test/SemaCXX/using-decl-templates.cpp
+@@ -153,3 +153,11 @@
  }
+ } // namespace sss
+ } // namespace func_templ
++
++namespace DependentName {
++  template <typename T> struct S {
++    using typename T::Ty;
++    static Ty Val;
++  };
++  template <typename T> typename S<T>::Ty S<T>::Val;
++} // DependentName
+diff -ruN --strip-trailing-cr a/clang/test/SemaTemplate/class-template-ctor-initializer.cpp b/clang/test/SemaTemplate/class-template-ctor-initializer.cpp
+--- a/clang/test/SemaTemplate/class-template-ctor-initializer.cpp
++++ b/clang/test/SemaTemplate/class-template-ctor-initializer.cpp
+@@ -4,8 +4,8 @@
  
- bool Loop::makeLoopInvariant(Value *V, bool &Changed, Instruction *InsertPt,
-diff -ruN --strip-trailing-cr a/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp b/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
---- a/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
-+++ b/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
-@@ -680,6 +680,8 @@
-   // No support for these operations with v2f32.
-   setOperationAction(ISD::INSERT_VECTOR_ELT, MVT::v2f32, Expand);
-   setOperationAction(ISD::VECTOR_SHUFFLE, MVT::v2f32, Expand);
-+  // Need custom lowering in case the index is dynamic.
-+  setOperationAction(ISD::EXTRACT_VECTOR_ELT, MVT::v2f32, Custom);
+ template<class X> struct A {};
  
-   // Custom conversions to/from v2i8.
-   setOperationAction(ISD::BITCAST, MVT::v2i8, Custom);
-diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/Scalar/LICM.cpp b/llvm/lib/Transforms/Scalar/LICM.cpp
---- a/llvm/lib/Transforms/Scalar/LICM.cpp
-+++ b/llvm/lib/Transforms/Scalar/LICM.cpp
-@@ -472,7 +472,7 @@
-   if (Preheader)
-     Changed |= hoistRegion(DT->getNode(L->getHeader()), AA, LI, DT, AC, TLI, L,
-                            MSSAU, SE, &SafetyInfo, Flags, ORE, LoopNestMode,
--                           LicmAllowSpeculation);
-+                           LicmAllowSpeculation, HasCoroSuspendInst);
+-template<class X> struct B : A<X> { 
+-  B() : A<X>() {} 
++template<class X> struct B : A<X> {
++  B() : A<X>() {}
+ };
+ B<int> x;
  
-   // Now that all loop invariants have been removed from the loop, promote any
-   // memory references to scalars that we can.
-@@ -881,7 +881,7 @@
-                        ICFLoopSafetyInfo *SafetyInfo,
-                        SinkAndHoistLICMFlags &Flags,
-                        OptimizationRemarkEmitter *ORE, bool LoopNestMode,
--                       bool AllowSpeculation) {
-+                       bool AllowSpeculation, bool HasCoroSuspendInst) {
-   // Verify inputs.
-   assert(N != nullptr && AA != nullptr && LI != nullptr && DT != nullptr &&
-          CurLoop != nullptr && SafetyInfo != nullptr &&
-@@ -914,11 +914,11 @@
-       // TODO: It may be safe to hoist if we are hoisting to a conditional block
-       // and we have accurately duplicated the control flow from the loop header
-       // to that block.
--      if (CurLoop->hasLoopInvariantOperands(&I) &&
-+      if (CurLoop->hasLoopInvariantOperands(&I, HasCoroSuspendInst) &&
-           canSinkOrHoistInst(I, AA, DT, CurLoop, MSSAU, true, Flags, ORE) &&
--          isSafeToExecuteUnconditionally(
--              I, DT, TLI, CurLoop, SafetyInfo, ORE,
--              Preheader->getTerminator(), AC, AllowSpeculation)) {
-+          isSafeToExecuteUnconditionally(I, DT, TLI, CurLoop, SafetyInfo, ORE,
-+                                         Preheader->getTerminator(), AC,
-+                                         AllowSpeculation)) {
-         hoist(I, DT, CurLoop, CFH.getOrCreateHoistedBlock(BB), SafetyInfo,
-               MSSAU, SE, ORE);
-         HoistedInstructions.push_back(&I);
-@@ -964,7 +964,7 @@
-                SafetyInfo->doesNotWriteMemoryBefore(I, CurLoop);
-       };
-       if ((IsInvariantStart(I) || isGuard(&I)) &&
--          CurLoop->hasLoopInvariantOperands(&I) &&
-+          CurLoop->hasLoopInvariantOperands(&I, HasCoroSuspendInst) &&
-           MustExecuteWithoutWritesBefore(I)) {
-         hoist(I, DT, CurLoop, CFH.getOrCreateHoistedBlock(BB), SafetyInfo,
-               MSSAU, SE, ORE);
-diff -ruN --strip-trailing-cr a/llvm/test/CodeGen/NVPTX/f32x2-instructions.ll b/llvm/test/CodeGen/NVPTX/f32x2-instructions.ll
---- a/llvm/test/CodeGen/NVPTX/f32x2-instructions.ll
-+++ b/llvm/test/CodeGen/NVPTX/f32x2-instructions.ll
-@@ -79,13 +79,24 @@
-   ret float %e
+@@ -76,3 +76,12 @@
+   Derived1<void> d1;
+   Derived2<void> d2;
  }
++
++namespace UnresolvedUsing {
++  template <class T> class A {
++    using typename T::B;
++    struct C : B {
++      C() : B() {}
++    };
++  };
++} // namespace UnresolvedUsing
+diff -ruN --strip-trailing-cr a/clang/test/SemaTemplate/nested-name-spec-template.cpp b/clang/test/SemaTemplate/nested-name-spec-template.cpp
+--- a/clang/test/SemaTemplate/nested-name-spec-template.cpp
++++ b/clang/test/SemaTemplate/nested-name-spec-template.cpp
+@@ -167,3 +167,18 @@
+   };
+   template struct C<int>;
+ } // namespace unresolved_using
++
++#if __cplusplus >= 201703L
++namespace SubstTemplateTypeParmPackType {
++  template <int...> struct A {};
++
++  template <class... Ts> void f() {
++    []<int ... Is>(A<Is...>) { (Ts::g(Is) && ...); }(A<0>{});
++    // expected-warning@-1 {{explicit template parameter list for lambdas is a C++20 extension}}
++  };
++
++  struct B { static void g(int); };
++
++  template void f<B>();
++} // namespace SubstTemplateTypeParmPackType
++#endif
+diff -ruN --strip-trailing-cr a/clang-tools-extra/clang-tidy/misc/UnconventionalAssignOperatorCheck.cpp b/clang-tools-extra/clang-tidy/misc/UnconventionalAssignOperatorCheck.cpp
+--- a/clang-tools-extra/clang-tidy/misc/UnconventionalAssignOperatorCheck.cpp
++++ b/clang-tools-extra/clang-tidy/misc/UnconventionalAssignOperatorCheck.cpp
+@@ -29,11 +29,13 @@
+   const auto HasGoodReturnType =
+       cxxMethodDecl(returns(hasCanonicalType(lValueReferenceType(pointee(
+           unless(isConstQualified()),
+-          anyOf(autoType(), hasDeclaration(equalsBoundNode("class"))))))));
++          anyOf(autoType(),
++                hasDeclaration(declaresSameEntityAsBoundNode("class"))))))));
  
--; NOTE: disabled as -O3 miscompiles this into pointer arithmetic on
--; test_extract_i_param_0 where the symbol's address is not taken first (that
--; is, moved to a temporary)
--; define float @test_extract_i(<2 x float> %a, i64 %idx) #0 {
--;   %e = extractelement <2 x float> %a, i64 %idx
--;   ret float %e
--; }
-+define float @test_extract_i(<2 x float> %a, i64 %idx) #0 {
-+; CHECK-LABEL: test_extract_i(
-+; CHECK:       {
-+; CHECK-NEXT:    .reg .pred %p<2>;
-+; CHECK-NEXT:    .reg .b32 %r<4>;
-+; CHECK-NEXT:    .reg .b64 %rd<3>;
-+; CHECK-EMPTY:
-+; CHECK-NEXT:  // %bb.0:
-+; CHECK-NEXT:    ld.param.b64 %rd2, [test_extract_i_param_1];
-+; CHECK-NEXT:    ld.param.b64 %rd1, [test_extract_i_param_0];
-+; CHECK-NEXT:    setp.eq.b64 %p1, %rd2, 0;
-+; CHECK-NEXT:    mov.b64 {%r1, %r2}, %rd1;
-+; CHECK-NEXT:    selp.f32 %r3, %r1, %r2, %p1;
-+; CHECK-NEXT:    st.param.b32 [func_retval0], %r3;
-+; CHECK-NEXT:    ret;
-+  %e = extractelement <2 x float> %a, i64 %idx
-+  ret float %e
+   const auto IsSelf = qualType(hasCanonicalType(
+-      anyOf(hasDeclaration(equalsBoundNode("class")),
+-            referenceType(pointee(hasDeclaration(equalsBoundNode("class")))))));
++      anyOf(hasDeclaration(declaresSameEntityAsBoundNode("class")),
++            referenceType(pointee(
++                hasDeclaration(declaresSameEntityAsBoundNode("class")))))));
+   const auto IsAssign =
+       cxxMethodDecl(unless(anyOf(isDeleted(), isPrivate(), isImplicit())),
+                     hasName("operator="), ofClass(recordDecl().bind("class")))
+diff -ruN --strip-trailing-cr a/clang-tools-extra/test/clang-tidy/checkers/misc/unconventional-assign-operator.cpp b/clang-tools-extra/test/clang-tidy/checkers/misc/unconventional-assign-operator.cpp
+--- a/clang-tools-extra/test/clang-tidy/checkers/misc/unconventional-assign-operator.cpp
++++ b/clang-tools-extra/test/clang-tidy/checkers/misc/unconventional-assign-operator.cpp
+@@ -176,3 +176,11 @@
+   }
+ };
+ }
++
++namespace GH153770 {
++  struct A;
++  struct A {
++    A() = default;
++    A& operator=(const A&) = default;
++  };
++} // namespace GH153770
+diff -ruN --strip-trailing-cr a/clang-tools-extra/test/clang-tidy/checkers/modernize/type-traits-GH153649.cpp b/clang-tools-extra/test/clang-tidy/checkers/modernize/type-traits-GH153649.cpp
+--- a/clang-tools-extra/test/clang-tidy/checkers/modernize/type-traits-GH153649.cpp
++++ b/clang-tools-extra/test/clang-tidy/checkers/modernize/type-traits-GH153649.cpp
+@@ -0,0 +1,15 @@
++// RUN: %check_clang_tidy -std=c++20 %s modernize-type-traits %t
++
++namespace std {
++template <class> struct tuple_size {
++  static const int value = 1;
++};
++template <int, class> struct tuple_element {
++  using type = int;
++};
 +}
- 
- define <2 x float> @test_fadd(<2 x float> %a, <2 x float> %b) #0 {
- ; CHECK-NOF32X2-LABEL: test_fadd(
-diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LICM/licm-coroutine.ll b/llvm/test/Transforms/LICM/licm-coroutine.ll
---- a/llvm/test/Transforms/LICM/licm-coroutine.ll
-+++ b/llvm/test/Transforms/LICM/licm-coroutine.ll
-@@ -0,0 +1,78 @@
-+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
-+; RUN: opt < %s -passes=licm -S | FileCheck %s
-+
-+; %fca.0 and %fca.1 should not be hoisted out of the loop because the ramp
-+; function and resume function have different stack frames, so %pointer1 and
-+; %pointer2 have different values before and after @llvm.coro.suspend.
-+
-+define ptr @f(i32 %n) presplitcoroutine {
-+; CHECK-LABEL: define ptr @f(
-+; CHECK-SAME: i32 [[N:%.*]]) #[[ATTR0:[0-9]+]] {
-+; CHECK-NEXT:  [[ENTRY:.*]]:
-+; CHECK-NEXT:    [[POINTER1:%.*]] = alloca ptr, align 8
-+; CHECK-NEXT:    [[POINTER2:%.*]] = alloca ptr, align 8
-+; CHECK-NEXT:    [[ID:%.*]] = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null)
-+; CHECK-NEXT:    [[SIZE:%.*]] = call i32 @llvm.coro.size.i32()
-+; CHECK-NEXT:    [[ALLOC:%.*]] = call ptr @malloc(i32 [[SIZE]])
-+; CHECK-NEXT:    [[HDL:%.*]] = call noalias ptr @llvm.coro.begin(token [[ID]], ptr [[ALLOC]])
-+; CHECK-NEXT:    br label %[[LOOP:.*]]
-+; CHECK:       [[LOOP]]:
-+; CHECK-NEXT:    [[N_VAL:%.*]] = phi i32 [ [[N]], %[[ENTRY]] ], [ [[INC:%.*]], %[[RESUME:.*]] ]
-+; CHECK-NEXT:    [[INC]] = add nsw i32 [[N_VAL]], 1
-+; CHECK-NEXT:    call void @print(i32 [[N_VAL]])
-+; CHECK-NEXT:    [[TMP0:%.*]] = call i8 @llvm.coro.suspend(token none, i1 false)
-+; CHECK-NEXT:    switch i8 [[TMP0]], label %[[SUSPEND_LOOPEXIT:.*]] [
-+; CHECK-NEXT:      i8 0, label %[[RESUME]]
-+; CHECK-NEXT:      i8 1, label %[[CLEANUP:.*]]
-+; CHECK-NEXT:    ]
-+; CHECK:       [[RESUME]]:
-+; CHECK-NEXT:    [[FCA_0:%.*]] = insertvalue [2 x ptr] poison, ptr [[POINTER1]], 0
-+; CHECK-NEXT:    [[FCA_1:%.*]] = insertvalue [2 x ptr] [[FCA_0]], ptr [[POINTER2]], 1
-+; CHECK-NEXT:    call void @foo([2 x ptr] [[FCA_1]])
-+; CHECK-NEXT:    br label %[[LOOP]]
-+; CHECK:       [[CLEANUP]]:
-+; CHECK-NEXT:    [[MEM:%.*]] = call ptr @llvm.coro.free(token [[ID]], ptr [[HDL]])
-+; CHECK-NEXT:    call void @free(ptr [[MEM]])
-+; CHECK-NEXT:    br label %[[SUSPEND:.*]]
-+; CHECK:       [[SUSPEND_LOOPEXIT]]:
-+; CHECK-NEXT:    br label %[[SUSPEND]]
-+; CHECK:       [[SUSPEND]]:
-+; CHECK-NEXT:    [[UNUSED:%.*]] = call i1 @llvm.coro.end(ptr [[HDL]], i1 false, token none)
-+; CHECK-NEXT:    ret ptr [[HDL]]
++
++struct A {};
++template <int> int get(const A&);
++
++auto [a] = A();
+diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
+--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
++++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
+@@ -9786,6 +9786,19 @@
+                "Must only have a single non-zero incoming value");
+         EPI.VectorTripCount = Inc;
+       }
++      // If we didn't find a non-zero vector trip count, all incoming values
++      // must be zero, which also means the vector trip count is zero. Pick the
++      // first zero as vector trip count.
++      // TODO: We should not choose VF * UF so the main vector loop is known to
++      // be dead.
++      if (!EPI.VectorTripCount) {
++        assert(
++            EPResumeVal->getNumIncomingValues() > 0 &&
++            all_of(EPResumeVal->incoming_values(),
++                   [](Value *Inc) { return match(Inc, m_SpecificInt(0)); }) &&
++            "all incoming values must be 0");
++        EPI.VectorTripCount = EPResumeVal->getOperand(0);
++      }
+       VPValue *VPV = Plan.getOrAddLiveIn(EPResumeVal);
+       assert(all_of(IV->users(),
+                     [](const VPUser *U) {
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LoopVectorize/AArch64/epilog-vectorization-factors.ll b/llvm/test/Transforms/LoopVectorize/AArch64/epilog-vectorization-factors.ll
+--- a/llvm/test/Transforms/LoopVectorize/AArch64/epilog-vectorization-factors.ll
++++ b/llvm/test/Transforms/LoopVectorize/AArch64/epilog-vectorization-factors.ll
+@@ -333,3 +333,91 @@
+ exit:
+   ret void
+ }
++
++; TODO: Choose smaller VF * UF for main loop, so we do not create a dead vector loop.
++define void @small_trip_count_loop(ptr %arg, ptr %arg2) {
++; CHECK-LABEL: @small_trip_count_loop(
++; CHECK-NEXT:  iter.check:
++; CHECK-NEXT:    [[ARG3:%.*]] = ptrtoint ptr [[ARG:%.*]] to i64
++; CHECK-NEXT:    [[ARG21:%.*]] = ptrtoint ptr [[ARG2:%.*]] to i64
++; CHECK-NEXT:    br i1 false, label [[VEC_EPILOG_SCALAR_PH:%.*]], label [[VECTOR_MEMCHECK:%.*]]
++; CHECK:       vector.memcheck:
++; CHECK-NEXT:    [[TMP0:%.*]] = sub i64 [[ARG21]], [[ARG3]]
++; CHECK-NEXT:    [[DIFF_CHECK:%.*]] = icmp ult i64 [[TMP0]], 64
++; CHECK-NEXT:    br i1 [[DIFF_CHECK]], label [[VEC_EPILOG_SCALAR_PH]], label [[VECTOR_MAIN_LOOP_ITER_CHECK:%.*]]
++; CHECK:       vector.main.loop.iter.check:
++; CHECK-NEXT:    br i1 true, label [[VEC_EPILOG_PH:%.*]], label [[VECTOR_PH:%.*]]
++; CHECK:       vector.ph:
++; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
++; CHECK:       vector.body:
++; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i8, ptr [[ARG]], i32 16
++; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, ptr [[ARG]], i32 32
++; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i8, ptr [[ARG]], i32 48
++; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <16 x i8>, ptr [[ARG]], align 1
++; CHECK-NEXT:    [[WIDE_LOAD4:%.*]] = load <16 x i8>, ptr [[TMP1]], align 1
++; CHECK-NEXT:    [[WIDE_LOAD5:%.*]] = load <16 x i8>, ptr [[TMP2]], align 1
++; CHECK-NEXT:    [[WIDE_LOAD6:%.*]] = load <16 x i8>, ptr [[TMP3]], align 1
++; CHECK-NEXT:    [[TMP4:%.*]] = add <16 x i8> [[WIDE_LOAD]], splat (i8 10)
++; CHECK-NEXT:    [[TMP5:%.*]] = add <16 x i8> [[WIDE_LOAD4]], splat (i8 10)
++; CHECK-NEXT:    [[TMP6:%.*]] = add <16 x i8> [[WIDE_LOAD5]], splat (i8 10)
++; CHECK-NEXT:    [[TMP7:%.*]] = add <16 x i8> [[WIDE_LOAD6]], splat (i8 10)
++; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr inbounds i8, ptr [[ARG2]], i32 16
++; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr inbounds i8, ptr [[ARG2]], i32 32
++; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr inbounds i8, ptr [[ARG2]], i32 48
++; CHECK-NEXT:    store <16 x i8> [[TMP4]], ptr [[ARG2]], align 1
++; CHECK-NEXT:    store <16 x i8> [[TMP5]], ptr [[TMP8]], align 1
++; CHECK-NEXT:    store <16 x i8> [[TMP6]], ptr [[TMP9]], align 1
++; CHECK-NEXT:    store <16 x i8> [[TMP7]], ptr [[TMP10]], align 1
++; CHECK-NEXT:    br label [[MIDDLE_BLOCK:%.*]]
++; CHECK:       middle.block:
++; CHECK-NEXT:    br i1 false, label [[EXIT:%.*]], label [[VEC_EPILOG_ITER_CHECK:%.*]]
++; CHECK:       vec.epilog.iter.check:
++; CHECK-NEXT:    br i1 false, label [[VEC_EPILOG_SCALAR_PH]], label [[VEC_EPILOG_PH]]
++; CHECK:       vec.epilog.ph:
++; CHECK-NEXT:    [[VEC_EPILOG_RESUME_VAL:%.*]] = phi i32 [ 0, [[VEC_EPILOG_ITER_CHECK]] ], [ 0, [[VECTOR_MAIN_LOOP_ITER_CHECK]] ]
++; CHECK-NEXT:    br label [[VEC_EPILOG_VECTOR_BODY:%.*]]
++; CHECK:       vec.epilog.vector.body:
++; CHECK-NEXT:    [[INDEX:%.*]] = phi i32 [ [[VEC_EPILOG_RESUME_VAL]], [[VEC_EPILOG_PH]] ], [ [[INDEX_NEXT:%.*]], [[VEC_EPILOG_VECTOR_BODY]] ]
++; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr inbounds i8, ptr [[ARG]], i32 [[INDEX]]
++; CHECK-NEXT:    [[WIDE_LOAD7:%.*]] = load <16 x i8>, ptr [[TMP11]], align 1
++; CHECK-NEXT:    [[TMP12:%.*]] = add <16 x i8> [[WIDE_LOAD7]], splat (i8 10)
++; CHECK-NEXT:    [[TMP13:%.*]] = getelementptr inbounds i8, ptr [[ARG2]], i32 [[INDEX]]
++; CHECK-NEXT:    store <16 x i8> [[TMP12]], ptr [[TMP13]], align 1
++; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i32 [[INDEX]], 16
++; CHECK-NEXT:    [[TMP14:%.*]] = icmp eq i32 [[INDEX_NEXT]], 16
++; CHECK-NEXT:    br i1 [[TMP14]], label [[VEC_EPILOG_MIDDLE_BLOCK:%.*]], label [[VEC_EPILOG_VECTOR_BODY]], !llvm.loop [[LOOP11:![0-9]+]]
++; CHECK:       vec.epilog.middle.block:
++; CHECK-NEXT:    br i1 false, label [[EXIT]], label [[VEC_EPILOG_SCALAR_PH]]
++; CHECK:       vec.epilog.scalar.ph:
++; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i32 [ 16, [[VEC_EPILOG_MIDDLE_BLOCK]] ], [ 0, [[VEC_EPILOG_ITER_CHECK]] ], [ 0, [[VECTOR_MEMCHECK]] ], [ 0, [[ITER_CHECK:%.*]] ]
++; CHECK-NEXT:    br label [[LOOP:%.*]]
++; CHECK:       loop:
++; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ [[BC_RESUME_VAL]], [[VEC_EPILOG_SCALAR_PH]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
++; CHECK-NEXT:    [[GEP_A:%.*]] = getelementptr inbounds i8, ptr [[ARG]], i32 [[IV]]
++; CHECK-NEXT:    [[LOAD:%.*]] = load i8, ptr [[GEP_A]], align 1
++; CHECK-NEXT:    [[SELECT:%.*]] = add i8 [[LOAD]], 10
++; CHECK-NEXT:    [[GEP_B:%.*]] = getelementptr inbounds i8, ptr [[ARG2]], i32 [[IV]]
++; CHECK-NEXT:    store i8 [[SELECT]], ptr [[GEP_B]], align 1
++; CHECK-NEXT:    [[IV_NEXT]] = add i32 [[IV]], 1
++; CHECK-NEXT:    [[EC:%.*]] = icmp eq i32 [[IV]], 20
++; CHECK-NEXT:    br i1 [[EC]], label [[EXIT]], label [[LOOP]], !llvm.loop [[LOOP12:![0-9]+]]
++; CHECK:       exit:
++; CHECK-NEXT:    ret void
 +;
 +entry:
-+  %pointer1 = alloca ptr
-+  %pointer2 = alloca ptr
-+  %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null)
-+  %size = call i32 @llvm.coro.size.i32()
-+  %alloc = call ptr @malloc(i32 %size)
-+  %hdl = call noalias ptr @llvm.coro.begin(token %id, ptr %alloc)
 +  br label %loop
 +
 +loop:
-+  %n.val = phi i32 [ %n, %entry ], [ %inc, %resume ]
-+  %inc = add nsw i32 %n.val, 1
-+  call void @print(i32 %n.val)
-+  %0 = call i8 @llvm.coro.suspend(token none, i1 false)
-+  switch i8 %0, label %suspend [i8 0, label %resume
-+  i8 1, label %cleanup]
-+
-+resume:
-+  %fca.0 = insertvalue [2 x ptr] poison, ptr %pointer1, 0
-+  %fca.1 = insertvalue [2 x ptr] %fca.0, ptr %pointer2, 1
-+  call void @foo([2 x ptr] %fca.1)
-+  br label %loop
++  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
++  %gep.A = getelementptr inbounds i8, ptr %arg, i32 %iv
++  %load = load i8, ptr %gep.A, align 1
++  %select = add i8 %load, 10
++  %gep.B = getelementptr inbounds i8, ptr %arg2, i32 %iv
++  store i8 %select, ptr %gep.B, align 1
++  %iv.next = add i32 %iv, 1
++  %ec = icmp eq i32 %iv, 20
++  br i1 %ec, label %exit, label %loop
 +
-+cleanup:
-+  %mem = call ptr @llvm.coro.free(token %id, ptr %hdl)
-+  call void @free(ptr %mem)
-+  br label %suspend
-+suspend:
-+  %unused = call i1 @llvm.coro.end(ptr %hdl, i1 false, token none)
-+  ret ptr %hdl
++exit:
++  ret void
 +}
-+
-+declare void @free(ptr)
-+declare ptr @malloc(i32)
-+declare void @print(i32)
-+declare void @foo([2 x ptr])
-diff -ruN --strip-trailing-cr a/mlir/test/Dialect/Linalg/linalg-morph-category-ops.mlir b/mlir/test/Dialect/Linalg/linalg-morph-category-ops.mlir
---- a/mlir/test/Dialect/Linalg/linalg-morph-category-ops.mlir
-+++ b/mlir/test/Dialect/Linalg/linalg-morph-category-ops.mlir
-@@ -2,7 +2,7 @@
- // RUN: mlir-opt %s -linalg-morph-ops=named-to-category | FileCheck %s  --check-prefix=NAMED_TO_CATEGORY
+diff -ruN --strip-trailing-cr a/llvm/tools/llvm-c-test/debuginfo.c b/llvm/tools/llvm-c-test/debuginfo.c
+--- a/llvm/tools/llvm-c-test/debuginfo.c
++++ b/llvm/tools/llvm-c-test/debuginfo.c
+@@ -448,6 +448,7 @@
+   assert(ME != NULL);
+   assert(numEntries == 2);
  
- // RUN: mlir-opt %s -linalg-morph-ops=named-to-category |  \
--// RUN:   mlir-opt %s -linalg-morph-ops=category-to-generic | FileCheck %s  --check-prefix=CATEGORY_TO_GENERIC
-+// RUN:   mlir-opt -linalg-morph-ops=category-to-generic | FileCheck %s  --check-prefix=CATEGORY_TO_GENERIC
++  LLVMDisposeValueMetadataEntries(ME);
+   LLVMDisposeDIBuilder(Builder);
+   LLVMDisposeModule(M);
  
- func.func @exp(%A : tensor<16x8xf32>, %B : tensor<16x8xf32>) ->  tensor<16x8xf32> {
-   %exp = linalg.exp ins(%A : tensor<16x8xf32>) outs(%B :  tensor<16x8xf32>) -> tensor<16x8xf32>
diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl
index e54cc0d..ed69d9f 100644
--- a/third_party/llvm/workspace.bzl
+++ b/third_party/llvm/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive")
 
 def repo(name):
     """Imports LLVM."""
-    LLVM_COMMIT = "fc44a4fcd3c54be927c15ddd9211aca1501633e7"
-    LLVM_SHA256 = "d228aebe5583c69c4e48fd7a8e149e3d22ee6dafaeae94009467143d32d9bfc4"
+    LLVM_COMMIT = "cb2f0d0a5f14c183e7182aba0f0e54a518de9e3f"
+    LLVM_SHA256 = "e8ece380fdb57dc6f8e42df9db872a1ade5056c5379075e3e2f99c89200aea69"
 
     tf_http_archive(
         name = name,
