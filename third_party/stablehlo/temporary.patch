diff --ruN a/stablehlo/stablehlo/dialect/VhloAttrs.td b/stablehlo/stablehlo/dialect/VhloAttrs.td
--- stablehlo/stablehlo/dialect/VhloAttrs.td
+++ stablehlo/stablehlo/dialect/VhloAttrs.td
@@ -45,14 +45,6 @@
 def VHLO_ArrayAttrV1 : VHLO_AttrDef<"ArrayV1", "0.9.0", "current"> {
   let mnemonic = "array_v1";
   let parameters = (ins ArrayRefParameter<"mlir::Attribute">:$value);
-  let genVerifyDecl = 1;
-  let extraClassDefinition = [{
-    LogicalResult ArrayV1Attr::verify(
-        llvm::function_ref<mlir::InFlightDiagnostic ()> errFn, ArrayRef<mlir::Attribute> value) {
-      if (!allFromVhlo(value)) return errFn() << "expected array of VHLO attriutes";
-      return success();
-    }
-  }];
   let assemblyFormat = "`<` custom<AttributeArray>($value) `>`";
 }
 
@@ -75,9 +67,9 @@
     LogicalResult DictionaryV1Attr::verify(
         llvm::function_ref<mlir::InFlightDiagnostic ()> errFn,
         ArrayRef<std::pair<mlir::Attribute, mlir::Attribute>> value) {
-      for (auto & entry : value)
-        if (!isFromVhlo(entry.first) || !isFromVhlo(entry.second))
-          errFn() << "expected VHLO attribute";
+      for (auto & entry : value) {
+        if (!isFromVhlo(entry.first)) errFn() << "expected VHLO key attribute";
+      }
       return success();
     }
   }];
diff --ruN a/stablehlo/stablehlo/dialect/VhloTypes.h b/stablehlo/stablehlo/dialect/VhloTypes.h
--- stablehlo/stablehlo/dialect/VhloTypes.h
+++ stablehlo/stablehlo/dialect/VhloTypes.h
@@ -27,20 +27,23 @@
 namespace mlir {
 namespace vhlo {
 
-class VhloTypeConverterBase : public TypeConverter {
- public:
-  VhloTypeConverterBase() : TypeConverter(){};
-
-  virtual ~VhloTypeConverterBase() = default;
-
-  virtual Attribute convertEncoding(Attribute attr) const = 0;
-};
 
 // This class is used to manage conversions between VHLO and Builtin
 // dialects.
-class VhloTypeConverter : public VhloTypeConverterBase {
+class VhloTypeConverter : public TypeConverter {
  public:
-  VhloTypeConverter() : VhloTypeConverterBase() {}
+  VhloTypeConverter() : TypeConverter(), allowOtherDialects(false) {}
+  VhloTypeConverter(bool allowOtherDialects)
+      : TypeConverter(), allowOtherDialects(allowOtherDialects) {}
+
+  virtual ~VhloTypeConverter() = default;
+
+  virtual Attribute convertEncoding(Attribute attr) const = 0;
+
+  Attribute convertUnknownAttribute(Attribute attr) const {
+    if (allowOtherDialects) return attr;
+    return {};
+  }
 
   // A subclass can call this method to add conversions from VHLO -> Builtin
   // types. Note that conversions are applied in reverse order, with the most
@@ -58,6 +61,9 @@
 
   // Mark unrealized casts as legal. Useful for dialect mixing.
   void addUnrealizedMaterializations();
+
+ private:
+  bool allowOtherDialects;
 };
 
 // Autogenerated VHLO type printers and parsers.
diff --ruN a/stablehlo/stablehlo/tests/vhlo/stablehlo_legalize_to_vhlo_mixed.mlir b/stablehlo/stablehlo/tests/vhlo/stablehlo_legalize_to_vhlo_mixed.mlir
--- stablehlo/stablehlo/tests/vhlo/stablehlo_legalize_to_vhlo_mixed.mlir
+++ stablehlo/stablehlo/tests/vhlo/stablehlo_legalize_to_vhlo_mixed.mlir
@@ -5,15 +5,9 @@
 // about what constitutes a good test! The CHECK should be
 // minimized and named to reflect the test intent.
 
-// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py
-
-// The script is designed to make adding checks to
-// a test case fast, it is *not* designed to be authoritative
-// minimized and named to reflect the test intent.
-
-// RUN: stablehlo-opt %s --stablehlo-legalize-to-vhlo=allow-other-dialects | FileCheck %s
+// RUN: stablehlo-opt %s --stablehlo-legalize-to-vhlo=allow-other-dialects --mlir-print-local-scope | FileCheck %s
 // RUN: stablehlo-opt %s > %t.0
-// RUN: stablehlo-opt %s --stablehlo-legalize-to-vhlo=allow-other-dialects | stablehlo-opt --vhlo-legalize-to-stablehlo > %t.1
+// RUN: stablehlo-translate %s --serialize --target=1.0.0 --allow-other-dialects | stablehlo-translate --deserialize | stablehlo-opt > %t.1
 // RUN: diff %t.0 %t.1
 
 // CHECK-LABEL:   vhlo.func_v1 @op_other(
@@ -26,6 +20,34 @@
 func.func @op_other(%arg0: tensor<f32>) -> tensor<f32> {
   %0 = arith.addf %arg0, %arg0 : tensor<f32>
   return %0 : tensor<f32>
+}
+
+// -----
+
+// CHECK-LABEL:   vhlo.func_v1 @func_attributes(
+// CHECK-SAME:                                  %[[VAL_0:[0-9]+|[a-zA-Z$._-][a-zA-Z0-9$._-]*]]: !vhlo.tensor_v1<!vhlo.f32_v1>) -> (!vhlo.tensor_v1<!vhlo.f32_v1>) {
+// CHECK:           "vhlo.return_v1"(%[[VAL_0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
+// CHECK:          } {arg_attrs = #vhlo.array_v1<[]>, builtin.map = affine_map<(d0) -> (d0)>, mhlo.sharding = #vhlo.string_v1<"{replicated}">, res_attrs = #vhlo.array_v1<[]>, sym_visibility = #vhlo.string_v1<"">}
+func.func @func_attributes(%arg0: tensor<f32>) -> tensor<f32> attributes {
+  mhlo.sharding = "{replicated}",
+  builtin.map = affine_map<(d0) -> (d0)>
+} {
+  return %arg0 : tensor<f32>
+}
+
+// -----
+
+// CHECK-LABEL:   vhlo.func_v1 @func_mixed_attributes(
+// CHECK-SAME:                                        %[[VAL_0:[0-9]+|[a-zA-Z$._-][a-zA-Z0-9$._-]*]]: !vhlo.tensor_v1<!vhlo.f32_v1>) -> (!vhlo.tensor_v1<!vhlo.f32_v1>) {
+// CHECK:           "vhlo.return_v1"(%[[VAL_0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
+// CHECK:         }
+// CHECK-SAME:    vhlo.mixed_array = #vhlo.array_v1<[affine_map<(d0) -> (d0)>, #vhlo.string_v1<"STR_ATTR">]>
+// CHECK-SAME:    vhlo.mixed_dict = #vhlo.dict_v1<{#vhlo.string_v1<"affine_map"> = affine_map<(d0) -> (d0)>, #vhlo.string_v1<"str_attr"> = #vhlo.string_v1<"STR_ATTR">}
+func.func @func_mixed_attributes(%arg0: tensor<f32>) -> tensor<f32> attributes {
+  vhlo.mixed_array = [affine_map<(d0) -> (d0)>, "STR_ATTR"],
+  vhlo.mixed_dict = {affine_map = affine_map<(d0) -> (d0)>, str_attr = "STR_ATTR"}
+} {
+  return %arg0 : tensor<f32>
 }
 
 // -----
diff --ruN a/stablehlo/stablehlo/tests/vhlo/vhlo_attributes_invalid.mlir b/stablehlo/stablehlo/tests/vhlo/vhlo_attributes_invalid.mlir
--- stablehlo/stablehlo/tests/vhlo/vhlo_attributes_invalid.mlir
+++ stablehlo/stablehlo/tests/vhlo/vhlo_attributes_invalid.mlir
@@ -1,17 +1,8 @@
 // RUN: stablehlo-opt --vhlo-to-version=target=1.9.0 -verify-diagnostics --split-input-file %s
 
-func.func @invalid_array_element() -> () attributes {
-  // expected-error @+1 {{expected array of VHLO attriutes}}
-  vhlo.attr = #vhlo.array_v1<[#stablehlo<precision DEFAULT>]>
-} {
-  return
-}
-
-// -----
-
 func.func @invalid_dict_element_value() -> () attributes {
-  // expected-error @+1 {{expected VHLO attribute}}
-  vhlo.attr = #vhlo.dict_v1<{#vhlo.string_v1<"attr1"> = 3 : i32}>
+  // expected-error @+1 {{expected VHLO key attribute}}
+  vhlo.attr = #vhlo.dict_v1<{"attr1" = #vhlo.array_v1<[]>}>
 } {
   return
 }
diff --ruN a/stablehlo/stablehlo/tools/StablehloTranslateMain.cpp b/stablehlo/stablehlo/tools/StablehloTranslateMain.cpp
--- stablehlo/stablehlo/tools/StablehloTranslateMain.cpp
+++ stablehlo/stablehlo/tools/StablehloTranslateMain.cpp
@@ -76,6 +76,11 @@
     "target", llvm::cl::desc("Target version for serialization"),
     llvm::cl::init(""));
 
+llvm::cl::opt<bool> allowOtherDialectsOption(
+    "allow-other-dialects",
+    llvm::cl::desc("Allow mixed dialect in serialization"),
+    llvm::cl::init(false));
+
 llvm::cl::opt<std::string> argsOption(
     "args", llvm::cl::desc("Arguments to pass to the interpreter"),
     llvm::cl::init(""));
@@ -317,7 +322,8 @@
           return module.emitError("failed to strip debuginfo");
       }
 
-      return stablehlo::serializePortableArtifact(module, targetVersion, os);
+      return stablehlo::serializePortableArtifact(
+          module, targetVersion, os, allowOtherDialectsOption.getValue());
     },
     [](DialectRegistry &registry) {
       mlir::registerAllDialects(registry);
diff --ruN a/stablehlo/stablehlo/transforms/Passes.h b/stablehlo/stablehlo/transforms/Passes.h
--- stablehlo/stablehlo/transforms/Passes.h
+++ stablehlo/stablehlo/transforms/Passes.h
@@ -35,6 +35,7 @@
 #include "mlir/Transforms/DialectConversion.h"
 #include "stablehlo/dialect/StablehloOps.h"
 #include "stablehlo/dialect/Version.h"
+#include "stablehlo/dialect/VhloTypes.h"
 
 namespace mlir {
 namespace stablehlo {
@@ -54,17 +55,17 @@
 // Populates StableHLO ops to VHLO ops rewriting patterns.
 void populateStablehloToVhloPatterns(MLIRContext *context,
                                      RewritePatternSet *patterns,
-                                     TypeConverter *converter);
+                                     vhlo::VhloTypeConverter *converter);
 
 // Populates VHLO ops to StableHLO ops rewriting patterns.
 void populateVhloToStablehloPatterns(MLIRContext *context,
                                      RewritePatternSet *patterns,
-                                     TypeConverter *converter);
+                                     vhlo::VhloTypeConverter *converter);
 
 // Populates VHLO downgrade rewriting patterns.
 void populateVhloToVersionPatterns(MLIRContext *context,
                                    RewritePatternSet *patterns,
-                                   TypeConverter *converter);
+                                   vhlo::VhloTypeConverter *converter);
 
 /// Collection of rewrite patterns for lowering of CHLO ops to StableHLO and
 /// Shape ops.
diff --ruN a/stablehlo/stablehlo/transforms/StablehloLegalizeToVhlo.cpp b/stablehlo/stablehlo/transforms/StablehloLegalizeToVhlo.cpp
--- stablehlo/stablehlo/transforms/StablehloLegalizeToVhlo.cpp
+++ stablehlo/stablehlo/transforms/StablehloLegalizeToVhlo.cpp
@@ -57,7 +57,7 @@
 class StablehloToVhloTypeConverter : public vhlo::VhloTypeConverter {
  public:
   StablehloToVhloTypeConverter(bool allowOtherDialects)
-      : vhlo::VhloTypeConverter() {
+      : vhlo::VhloTypeConverter(allowOtherDialects) {
     LLVM_DEBUG(
         llvm::dbgs()
         << "[StablehloToVhloTypeConverter] Creating with allowOtherDialects: "
@@ -82,7 +82,15 @@
       return vhlo::TokenV1Type::get(token.getContext());
     });
     addBuiltinToVhloConversions();
-    if (allowOtherDialects) addUnrealizedMaterializations();
+    if (allowOtherDialects) {
+      addUnrealizedMaterializations();
+
+      // Attribute conversion fallback uses the type converter.
+      addTypeAttributeConversion(
+          [](Type, Attribute attr) -> TypeConverter::AttributeConversionResult {
+            return attr;
+          });
+    }
   }
 
   Attribute convertEncoding(Attribute attr) const final {
@@ -114,7 +122,7 @@
   return vhlo::Name##Version##Attr::get(attr.getContext(), vhloValue.value())
 
 Attribute convertGeneric(Attribute stablehloAttr,
-                         const TypeConverter* typeConverter) {
+                         const vhlo::VhloTypeConverter* typeConverter) {
   LLVM_DEBUG(llvm::dbgs() << "Convert generic: " << stablehloAttr << '\n');
 
   // Handle StableHLO attributes.
@@ -241,6 +249,10 @@
     return vhlo::TypeV1Attr::get(attr.getContext(), vhloType);
   }
 
+  // Fall back to type converter for unknown attributes.
+  auto unknownAttr = typeConverter->convertUnknownAttribute(stablehloAttr);
+  if (unknownAttr) return unknownAttr;
+
   LLVM_DEBUG(llvm::dbgs() << "Failed to convert: " << stablehloAttr << '\n');
   return {};  // Failed to convert attribute.
 }
@@ -268,13 +280,15 @@
 Attribute convertBool(const ConversionPattern& pattern, int64_t stablehloDim) {
   auto stablehloType = IntegerType::get(pattern.getContext(), 1);
   auto stablehloAttr = IntegerAttr::get(stablehloType, stablehloDim);
-  return convertGeneric(stablehloAttr, pattern.getTypeConverter());
+  return convertGeneric(stablehloAttr,
+                        pattern.getTypeConverter<vhlo::VhloTypeConverter>());
 }
 
 Attribute convertInt(const ConversionPattern& pattern, int64_t stablehloDim) {
   auto stablehloType = IntegerType::get(pattern.getContext(), 64);
   auto stablehloAttr = IntegerAttr::get(stablehloType, stablehloDim);
-  return convertGeneric(stablehloAttr, pattern.getTypeConverter());
+  return convertGeneric(stablehloAttr,
+                        pattern.getTypeConverter<vhlo::VhloTypeConverter>());
 }
 
 Attribute convertInts(const ConversionPattern& pattern,
@@ -282,7 +296,8 @@
   auto stablehloType = RankedTensorType::get(
       stablehloDims.size(), IntegerType::get(pattern.getContext(), 64));
   auto stablehloAttr = DenseIntElementsAttr::get(stablehloType, stablehloDims);
-  return convertGeneric(stablehloAttr, pattern.getTypeConverter());
+  return convertGeneric(stablehloAttr,
+                        pattern.getTypeConverter<vhlo::VhloTypeConverter>());
 }
 
 Attribute convertSymbol(const ConversionPattern& pattern,
@@ -290,7 +305,7 @@
   auto stablehloSymbolAttr = dyn_cast<FlatSymbolRefAttr>(stablehloAttr);
   if (!stablehloSymbolAttr) return {};
   return convertGeneric(stablehloSymbolAttr.getAttr(),
-                        pattern.getTypeConverter());
+                        pattern.getTypeConverter<vhlo::VhloTypeConverter>());
 }
 
 SpecialResult convertChannelHandle(const ConversionPattern& pattern,
@@ -445,15 +460,15 @@
   vhloAttrs.emplace_back(
       StringAttr::get(pattern.getContext(), "lhs_precision_type"),
       convertGeneric(TypeAttr::get(attr.getLhsPrecisionType()),
-                     pattern.getTypeConverter()));
+                     pattern.getTypeConverter<vhlo::VhloTypeConverter>()));
   vhloAttrs.emplace_back(
       StringAttr::get(pattern.getContext(), "rhs_precision_type"),
       convertGeneric(TypeAttr::get(attr.getRhsPrecisionType()),
-                     pattern.getTypeConverter()));
+                     pattern.getTypeConverter<vhlo::VhloTypeConverter>()));
   vhloAttrs.emplace_back(
       StringAttr::get(pattern.getContext(), "accumulation_type"),
       convertGeneric(TypeAttr::get(attr.getAccumulationType()),
-                     pattern.getTypeConverter()));
+                     pattern.getTypeConverter<vhlo::VhloTypeConverter>()));
 
   // Components
   auto vhloLhsComponentCount = convertInt(pattern, attr.getLhsComponentCount());
@@ -712,7 +727,9 @@
   auto addDefaultAttr = [&](StringRef vhloName, Attribute stablehloAttr) {
     vhloAttrs.emplace_back(
         StringAttr::get(pattern.getContext(), vhloName),
-        convertGeneric(stablehloAttr, pattern.getTypeConverter()));
+        convertGeneric(
+            stablehloAttr,
+            pattern.template getTypeConverter<vhlo::VhloTypeConverter>()));
   };
   if constexpr (std::is_same<StablehloOpTy, func::FuncOp>::value) {
     if (!stablehloOp.getSymVisibilityAttr())
@@ -987,8 +1004,9 @@
         case SpecialResult::SPECIAL_FAILURE:
           return failure();
         case SpecialResult::NOT_SPECIAL:
-          auto vhloAttr = convertGeneric(stablehloAttr.getValue(),
-                                         this->getTypeConverter());
+          auto vhloAttr = convertGeneric(
+              stablehloAttr.getValue(),
+              this->template getTypeConverter<vhlo::VhloTypeConverter>());
           if (!vhloAttr) return failure();
           vhloAttrs.push_back({stablehloAttr.getName(), vhloAttr});
           break;
@@ -1075,14 +1093,14 @@
   }
 
  private:
-  std::shared_ptr<StablehloToVhloTypeConverter> converter;
+  std::shared_ptr<vhlo::VhloTypeConverter> converter;
   FrozenRewritePatternSet patterns;
   std::shared_ptr<ConversionTarget> target;
 };
 
 void populateStablehloToVhloPatterns(MLIRContext* context,
                                      RewritePatternSet* patterns,
-                                     TypeConverter* converter) {
+                                     vhlo::VhloTypeConverter* converter) {
   populateStablehloToVhloPatterns<
 #define GET_OP_LIST
 #include "stablehlo/dialect/StablehloOps.cpp.inc"
diff --ruN a/stablehlo/stablehlo/transforms/VhloLegalizeToStablehlo.cpp b/stablehlo/stablehlo/transforms/VhloLegalizeToStablehlo.cpp
--- stablehlo/stablehlo/transforms/VhloLegalizeToStablehlo.cpp
+++ stablehlo/stablehlo/transforms/VhloLegalizeToStablehlo.cpp
@@ -57,7 +57,10 @@
 
 class VhloToStablehloTypeConverter : public vhlo::VhloTypeConverter {
  public:
-  VhloToStablehloTypeConverter() : vhlo::VhloTypeConverter() {
+  // Safe to allow other dialects since the StableHLO->VHLO conversion guards
+  // the legality of types / attributes.
+  VhloToStablehloTypeConverter()
+      : vhlo::VhloTypeConverter(/*allowOtherDialects=*/true) {
     addConversion([](Type type) -> Type { return type; });
     addConversion([](vhlo::TokenV1Type token) -> Type {
       LLVM_DEBUG(llvm::dbgs() << "Converting TokenType\n");
@@ -90,7 +93,7 @@
   return stablehlo::Name##Attr::get(attr.getContext(), stablehloValue.value())
 
 Attribute convertGeneric(Attribute vhloAttr,
-                         const TypeConverter* typeConverter) {
+                         const vhlo::VhloTypeConverter* typeConverter) {
   LLVM_DEBUG(llvm::dbgs() << "Converting attr " << vhloAttr);
   if (auto vhloAttrs = dyn_cast<vhlo::ArrayV1Attr>(vhloAttr)) {
     SmallVector<Attribute> stablehloAttrs;
@@ -189,6 +192,10 @@
     // All VHLO attributes must have counterparts in StableHLO.
     return {};
   }
+
+  // Fall back to type converter for unknown attributes.
+  auto unknownAttr = typeConverter->convertUnknownAttribute(vhloAttr);
+  if (unknownAttr) return unknownAttr;
 
   // This should be unreachable unless program is a mix of VHLO and other
   // dialects, e.g. due to user edits to textual assembly format.
@@ -229,7 +236,7 @@
 }
 
 LogicalResult convertTypeAttr(Attribute vhloAttr, Type& result,
-                              const TypeConverter* typeConverter) {
+                              const vhlo::VhloTypeConverter* typeConverter) {
   auto stablehloAttr = convertGeneric(vhloAttr, typeConverter);
   if (!stablehloAttr || !isa<TypeAttr>(stablehloAttr)) return failure();
   result = cast<TypeAttr>(stablehloAttr).getValue();
@@ -244,7 +251,7 @@
 }
 
 LogicalResult convertInts(Attribute vhloAttr,
-                          const TypeConverter* typeConverter,
+                          const vhlo::VhloTypeConverter* typeConverter,
                           SmallVector<int64_t>& result) {
   auto vhloTensorAttr = dyn_cast<vhlo::TensorV1Attr>(vhloAttr);
   if (!vhloTensorAttr) return failure();
@@ -256,7 +263,7 @@
 }
 
 Attribute convertSymbol(Attribute vhloAttr,
-                        const TypeConverter* typeConverter) {
+                        const vhlo::VhloTypeConverter* typeConverter) {
   auto vhloStringAttr = dyn_cast<vhlo::StringV1Attr>(vhloAttr);
   if (!vhloStringAttr) return {};
   auto stablehloStringAttr = dyn_cast_or_null<StringAttr>(
@@ -267,7 +274,7 @@
 
 template <typename OpType>
 Attribute convertChannelHandle(OpType vhloOp,
-                               const TypeConverter* typeConverter) {
+                               const vhlo::VhloTypeConverter* typeConverter) {
   int64_t channelId, channelType;
   if (failed(convertInt(vhloOp.getChannelId(), channelId)) ||
       failed(convertInt(vhloOp.getChannelType(), channelType)))
@@ -277,7 +284,7 @@
 }
 
 Attribute convertChannelId(Attribute vhloAttr,
-                           const TypeConverter* typeConverter) {
+                           const vhlo::VhloTypeConverter* typeConverter) {
   int64_t channelId;
   if (failed(convertInt(vhloAttr, channelId))) return {};
   return stablehlo::ChannelHandleAttr::get(vhloAttr.getContext(), channelId,
@@ -285,8 +292,8 @@
 }
 
 template <typename OpType>
-Attribute convertConvDimensionNumbers(OpType vhloOp,
-                                      const TypeConverter* typeConverter) {
+Attribute convertConvDimensionNumbers(
+    OpType vhloOp, const vhlo::VhloTypeConverter* typeConverter) {
   int64_t stablehloInputBatchDimension, stablehloInputFeatureDimension;
   SmallVector<int64_t> stablehloInputSpatialDimensions;
   int64_t stablehloKernelInputFeatureDimension,
@@ -323,7 +330,7 @@
 }
 
 Attribute convertCustomCallCalledComputations(
-    Attribute vhloAttr, const TypeConverter* typeConverter) {
+    Attribute vhloAttr, const vhlo::VhloTypeConverter* typeConverter) {
   if (auto vhloArrayAttr = dyn_cast<vhlo::ArrayV1Attr>(vhloAttr)) {
     SmallVector<Attribute> stablehloAttrs;
     for (auto vhloAttr : vhloArrayAttr.getValue()) {
@@ -336,8 +343,8 @@
   return {};
 }
 
-FailureOr<Attribute> convertDotAlgorithm(vhlo::DotGeneralOpV2 vhloOp,
-                                         const TypeConverter* typeConverter) {
+FailureOr<Attribute> convertDotAlgorithm(
+    vhlo::DotGeneralOpV2 vhloOp, const vhlo::VhloTypeConverter* typeConverter) {
   Type lhsPrecisionType, rhsPrecisionType, accumulationType;
   if (isNoneType(vhloOp.getLhsComponentCount())) {
     // All must be nonetype
@@ -373,8 +380,8 @@
       numPrimitiveOperations, allowImpreciseAccumulation);
 }
 
-Attribute convertDotDimensionNumbers(vhlo::DotGeneralOpV2 vhloOp,
-                                     const TypeConverter* typeConverter) {
+Attribute convertDotDimensionNumbers(
+    vhlo::DotGeneralOpV2 vhloOp, const vhlo::VhloTypeConverter* typeConverter) {
   SmallVector<int64_t> stablehloLhsBatchingDimensions,
       stablehloRhsBatchingDimensions, stablehloLhsContractingDimensions,
       stablehloRhsContractingDimensions;
@@ -394,13 +401,13 @@
 }
 
 Attribute convertFuncCallee(Attribute vhloAttr,
-                            const TypeConverter* typeConverter) {
+                            const vhlo::VhloTypeConverter* typeConverter) {
   return convertSymbol(vhloAttr, typeConverter);
 }
 
 template <typename OpType>
-Attribute convertGatherDimensionNumbers(OpType vhloOp,
-                                        const TypeConverter* typeConverter) {
+Attribute convertGatherDimensionNumbers(
+    OpType vhloOp, const vhlo::VhloTypeConverter* typeConverter) {
   SmallVector<int64_t> stablehloOffsetDims, stablehloCollapsedSliceDims,
       stablehloOperandBatchingDims, stablehloStartIndicesBatchingDims,
       stablehloStartIndexMap;
@@ -423,8 +430,8 @@
       stablehloStartIndexMap, stablehloIndexVectorDim);
 }
 
-Attribute convertScatterDimensionNumbers(vhlo::ScatterOpV2 vhloOp,
-                                         const TypeConverter* typeConverter) {
+Attribute convertScatterDimensionNumbers(
+    vhlo::ScatterOpV2 vhloOp, const vhlo::VhloTypeConverter* typeConverter) {
   SmallVector<int64_t> stablehloUpdateWindowDims, stablehloInsertedWindowDims,
       stablehloInputBatchingDims, stablehloScatterIndicesBatchingDims,
       stablehloScatterDimsToOperandDims;
@@ -463,10 +470,11 @@
                              VhloOpTy vhloOp,
                              SmallVector<NamedAttribute>& vhloAttrs,
                              SmallVector<NamedAttribute>& stablehloAttrs) {
+  auto typeConverter =
+      pattern.template getTypeConverter<vhlo::VhloTypeConverter>();
   if constexpr (std::is_same<VhloOpTy, vhlo::ConvolutionOpV1>::value ||
                 std::is_same<VhloOpTy, vhlo::DynamicConvOpV2>::value) {
-    auto stablehloAttr =
-        convertConvDimensionNumbers(vhloOp, pattern.getTypeConverter());
+    auto stablehloAttr = convertConvDimensionNumbers(vhloOp, typeConverter);
     if (!stablehloAttr) return failure();
     stablehloAttrs.emplace_back(
         StringAttr::get(pattern.getContext(), "dimension_numbers"),
@@ -480,7 +488,7 @@
   if constexpr (std::is_same<VhloOpTy, vhlo::DotGeneralOpV2>::value) {
     // Dot Dimension Numbers
     auto stablehloDotDimAttr =
-        convertDotDimensionNumbers(vhloOp, pattern.getTypeConverter());
+        convertDotDimensionNumbers(vhloOp, typeConverter);
     if (!stablehloDotDimAttr) return failure();
     stablehloAttrs.emplace_back(
         StringAttr::get(pattern.getContext(), "dot_dimension_numbers"),
@@ -489,8 +497,7 @@
                "lhs_contracting_dimensions", "rhs_contracting_dimensions");
 
     // Dot Algorithm
-    auto stablehloDotAlgorithmAttr =
-        convertDotAlgorithm(vhloOp, pattern.getTypeConverter());
+    auto stablehloDotAlgorithmAttr = convertDotAlgorithm(vhloOp, typeConverter);
     if (failed(stablehloDotAlgorithmAttr)) return failure();
     if (stablehloDotAlgorithmAttr.value())
       stablehloAttrs.emplace_back(
@@ -503,8 +510,7 @@
   }
   if constexpr (std::is_same<VhloOpTy, vhlo::DynamicGatherOpV2>::value ||
                 std::is_same<VhloOpTy, vhlo::GatherOpV2>::value) {
-    auto stablehloAttr =
-        convertGatherDimensionNumbers(vhloOp, pattern.getTypeConverter());
+    auto stablehloAttr = convertGatherDimensionNumbers(vhloOp, typeConverter);
     if (!stablehloAttr) return failure();
     stablehloAttrs.emplace_back(
         StringAttr::get(pattern.getContext(), "dimension_numbers"),
@@ -514,8 +520,7 @@
                "start_index_map", "index_vector_dim");
   }
   if constexpr (std::is_same<VhloOpTy, vhlo::ScatterOpV2>::value) {
-    auto stablehloAttr =
-        convertScatterDimensionNumbers(vhloOp, pattern.getTypeConverter());
+    auto stablehloAttr = convertScatterDimensionNumbers(vhloOp, typeConverter);
     if (!stablehloAttr) return failure();
     stablehloAttrs.emplace_back(
         StringAttr::get(pattern.getContext(), "scatter_dimension_numbers"),
@@ -526,8 +531,7 @@
   }
   if constexpr (std::is_same<VhloOpTy, vhlo::RecvOpV1>::value ||
                 std::is_same<VhloOpTy, vhlo::SendOpV1>::value) {
-    auto stablehloAttr =
-        convertChannelHandle(vhloOp, pattern.getTypeConverter());
+    auto stablehloAttr = convertChannelHandle(vhloOp, typeConverter);
     if (!stablehloAttr) return failure();
     stablehloAttrs.emplace_back(
         StringAttr::get(pattern.getContext(), "channel_handle"), stablehloAttr);
@@ -537,7 +541,7 @@
 }
 
 template <typename T, typename DenseArrayAttr>
-SpecialResult convertDenseArray(const TypeConverter* typeConverter,
+SpecialResult convertDenseArray(const vhlo::VhloTypeConverter* typeConverter,
                                 StringAttr vhloName, Attribute vhloAttr,
                                 SmallVector<NamedAttribute>& stablehloAttrs) {
   auto tensorAttr = dyn_cast<vhlo::TensorV1Attr>(vhloAttr);
@@ -556,15 +560,15 @@
 }
 
 SpecialResult convertDenseBoolArray(
-    const TypeConverter* typeConverter, StringAttr vhloName, Attribute vhloAttr,
-    SmallVector<NamedAttribute>& stablehloAttrs) {
+    const vhlo::VhloTypeConverter* typeConverter, StringAttr vhloName,
+    Attribute vhloAttr, SmallVector<NamedAttribute>& stablehloAttrs) {
   return convertDenseArray<bool, DenseBoolArrayAttr>(typeConverter, vhloName,
                                                      vhloAttr, stablehloAttrs);
 }
 
 SpecialResult convertDenseI64Array(
-    const TypeConverter* typeConverter, StringAttr vhloName, Attribute vhloAttr,
-    SmallVector<NamedAttribute>& stablehloAttrs) {
+    const vhlo::VhloTypeConverter* typeConverter, StringAttr vhloName,
+    Attribute vhloAttr, SmallVector<NamedAttribute>& stablehloAttrs) {
   return convertDenseArray<int64_t, DenseI64ArrayAttr>(
       typeConverter, vhloName, vhloAttr, stablehloAttrs);
 }
@@ -575,7 +579,8 @@
                              SmallVector<NamedAttribute>& stablehloAttrs) {
   StringAttr stablehloName = vhloName;
   Attribute stablehloAttr;
-  auto typeConverter = pattern.getTypeConverter();
+  auto typeConverter =
+      pattern.template getTypeConverter<vhlo::VhloTypeConverter>();
 
   if constexpr (std::is_same<VhloOpTy, vhlo::AllGatherOpV2>::value ||
                 std::is_same<VhloOpTy, vhlo::AllReduceOpV2>::value ||
@@ -585,7 +590,7 @@
                 std::is_same<VhloOpTy, vhlo::CollectiveBroadcastOpV1>::value) {
     if (vhloName == "channel_id") {
       stablehloName = StringAttr::get(pattern.getContext(), "channel_handle");
-      stablehloAttr = convertChannelId(vhloAttr, pattern.getTypeConverter());
+      stablehloAttr = convertChannelId(vhloAttr, typeConverter);
       if (!stablehloAttr) return specialFailure();
     }
     if (vhloName == "use_global_device_ids") {
@@ -597,20 +602,20 @@
   }
   if constexpr (std::is_same<VhloOpTy, vhlo::CustomCallOpV1>::value) {
     if (vhloName == "called_computations") {
-      stablehloAttr = convertCustomCallCalledComputations(
-          vhloAttr, pattern.getTypeConverter());
+      stablehloAttr =
+          convertCustomCallCalledComputations(vhloAttr, typeConverter);
       if (!stablehloAttr) return specialFailure();
     }
   }
   if constexpr (std::is_same<VhloOpTy, vhlo::CompositeOpV1>::value) {
     if (vhloName == "decomposition") {
-      stablehloAttr = convertSymbol(vhloAttr, pattern.getTypeConverter());
+      stablehloAttr = convertSymbol(vhloAttr, typeConverter);
       if (!stablehloAttr) return specialFailure();
     }
   }
   if constexpr (std::is_same<VhloOpTy, vhlo::CallOpV1>::value) {
     if (vhloName == "callee") {
-      stablehloAttr = convertFuncCallee(vhloAttr, pattern.getTypeConverter());
+      stablehloAttr = convertFuncCallee(vhloAttr, typeConverter);
       if (!stablehloAttr) return specialFailure();
     }
   }
@@ -760,8 +765,8 @@
 template <typename T>
 bool isSplatTensor(const ConversionPattern& pattern, Attribute vhloAttr,
                    T splatValue) {
-  auto attr = dyn_cast_or_null<DenseElementsAttr>(
-      convertGeneric(vhloAttr, pattern.getTypeConverter()));
+  auto attr = dyn_cast_or_null<DenseElementsAttr>(convertGeneric(
+      vhloAttr, pattern.getTypeConverter<vhlo::VhloTypeConverter>()));
   return attr && attr.isSplat() &&
          attr.template getSplatValue<T>() == splatValue;
 }
@@ -977,8 +982,9 @@
         case SpecialResult::SPECIAL_FAILURE:
           return failure();
         case SpecialResult::NOT_SPECIAL:
-          auto stablehloAttr =
-              convertGeneric(vhloAttr.getValue(), this->getTypeConverter());
+          auto stablehloAttr = convertGeneric(
+              vhloAttr.getValue(),
+              this->template getTypeConverter<vhlo::VhloTypeConverter>());
           if (!stablehloAttr) return failure();
           stablehloAttrs.push_back({vhloAttr.getName(), stablehloAttr});
           break;
@@ -1056,7 +1062,7 @@
 template <typename... StablehloOpTypes>
 void populateVhloToStablehloPatterns(MLIRContext* context,
                                      RewritePatternSet* patterns,
-                                     TypeConverter* converter) {
+                                     vhlo::VhloTypeConverter* converter) {
   patterns
       ->add<VhloToStablehloOpConverter<StablehloToVhloOp<StablehloOpTypes>>...>(
           *converter, context);
@@ -1104,7 +1110,7 @@
 
 void populateVhloToStablehloPatterns(MLIRContext* context,
                                      RewritePatternSet* patterns,
-                                     TypeConverter* converter) {
+                                     vhlo::VhloTypeConverter* converter) {
   populateVhloToStablehloPatterns<
 #define GET_OP_LIST
 #include "stablehlo/dialect/StablehloOps.cpp.inc"
diff --ruN a/stablehlo/stablehlo/transforms/VhloToVersion.cpp b/stablehlo/stablehlo/transforms/VhloToVersion.cpp
--- stablehlo/stablehlo/transforms/VhloToVersion.cpp
+++ stablehlo/stablehlo/transforms/VhloToVersion.cpp
@@ -56,15 +56,23 @@
 
 // Currently there are no type-to-version conversions so this class
 // simply validates that all types are from the VHLO dialect.
-class VhloToVersionConverter : public TypeConverter {
+class VhloToVersionConverter : public VhloTypeConverter {
  public:
-  VhloToVersionConverter() : TypeConverter() {
-    addConversion([](Type type) -> Type {
-      if (llvm::isa<vhlo::VhloDialect>(type.getDialect())) return type;
-      LLVM_DEBUG(llvm::dbgs() << "Invalid type: " << type << '\n');
-      return {};
+  // Safe to allow other dialects since the StableHLO->VHLO conversion guards
+  // the legality of types / attributes.
+  VhloToVersionConverter() : VhloTypeConverter(/*allowOtherDialects=*/true) {
+    addConversion([&](Type type) -> Type {
+      if (llvm::isa<vhlo::VhloDialect>(type.getDialect())) {
+        // Once a type becomes versioned we will check the version here.
+        return type;
+      }
+
+      LLVM_DEBUG(llvm::dbgs() << "Not VHLO type, allowed: " << type << '\n');
+      return type;
     });
   }
+
+  Attribute convertEncoding(Attribute attr) const override { return attr; };
 };
 
 // Check user-specified target version. Emit error if invalid.
@@ -111,6 +119,10 @@
 LogicalResult isLegalType(Type type, const Version& targetVersion);
 
 LogicalResult isLegalAttribute(const Attribute& attr, Version targetVersion) {
+  // StableHLO->VHLO conversion guards the legality of types / attributes.
+  // Other dialect types that make it past that step are valid here.
+  if (!mlir::isa<vhlo::VhloDialect>(attr.getDialect())) return success();
+
   auto attrInterface = dyn_cast<VersionedAttrInterface>(attr);
   if (!attrInterface || !isLegalVersion(attrInterface, targetVersion)) {
     LLVM_DEBUG(llvm::dbgs() << "failed to legalize attribute " << attr
@@ -119,10 +131,11 @@
   }
 
   // Recursively check attrs if VHLO attr is a container
-  if (auto arrAttr = dyn_cast<ArrayV1Attr>(attr))
+  if (auto arrAttr = dyn_cast<ArrayV1Attr>(attr)) {
     return success(llvm::all_of(arrAttr.getValue(), [&](Attribute ele) {
       return succeeded(isLegalAttribute(ele, targetVersion));
     }));
+  }
   if (auto arrAttr = dyn_cast<DictionaryV1Attr>(attr)) {
     return success(llvm::all_of(
         arrAttr.getValue(), [&](std::pair<Attribute, Attribute> entry) {
@@ -146,6 +159,10 @@
 }
 
 LogicalResult isLegalType(Type type, const Version& targetVersion) {
+  // StableHLO->VHLO conversion guards the legality of types / attributes.
+  // Other dialect types that make it past that step are valid here.
+  if (!mlir::isa<vhlo::VhloDialect>(type.getDialect())) return success();
+
   // All valid VHLO types must have versioned type interface.
   auto typeInterface = dyn_cast<VersionedTypeInterface>(type);
   if (!typeInterface || !isLegalVersion(typeInterface, targetVersion)) {
@@ -170,10 +187,11 @@
       return failure();
     return isLegalType(ranked.getElementType(), targetVersion);
   }
-  if (auto tuple = dyn_cast<TupleV1Type>(type))
+  if (auto tuple = dyn_cast<TupleV1Type>(type)) {
     return success(llvm::all_of(tuple.getTypes(), [&](Type ele) {
       return succeeded(isLegalType(ele, targetVersion));
     }));
+  }
   if (auto quant = dyn_cast<UniformQuantizedV1Type>(type))
     return success(
         succeeded(isLegalType(quant.getStorageType(), targetVersion)) &&
@@ -213,7 +231,7 @@
 bool isLegalOperation(Operation* op, const Version& targetVersion) {
   // Validate op
   auto opInterface = dyn_cast<VersionedOpInterface>(op);
-  if (!opInterface) return false;
+  if (!opInterface) return true;
   if (!isLegalVersion(opInterface, targetVersion)) return false;
   LLVM_DEBUG(llvm::dbgs() << "Legal op version for target. " << op << '\n');
 
@@ -454,7 +472,7 @@
 namespace stablehlo {
 void populateVhloToVersionPatterns(MLIRContext* context,
                                    RewritePatternSet* patterns,
-                                   TypeConverter* converter) {
+                                   vhlo::VhloTypeConverter* converter) {
   vhlo::populateWithGenerated(*patterns);
   patterns->add<vhlo::ScatterOpV1ToV2, vhlo::ScatterOpV2ToV1>(context);
   patterns->add<vhlo::AllReduceOpV1ToV2, vhlo::AllReduceOpV2ToV1>(context);

