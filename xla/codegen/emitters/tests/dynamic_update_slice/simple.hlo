// RUN: gpu_fusion_to_mlir %s | emitters_opt -xla-test-optimize |\
// RUN:   FileCheck %s --check-prefixes=CHECK,CHECK-GPU
// RUN: cpu_fusion_to_mlir %s | emitters_opt -xla-test-optimize |\
// RUN:   FileCheck %s
// RUN: gpu_test_correctness %s --bijection_inputs=updated:1
// RUN: cpu_test_correctness %s

fusion {
  in = f32[20,30] parameter(0)
  updates = f32[5,6] parameter(1)
  i0 = s32[] parameter(2)
  i1 = s32[] parameter(3)
  ROOT updated = f32[20,30] dynamic-update-slice(in, updates, i0, i1)
}

ENTRY main {
  %param_0 = f32[20,30] parameter(0)
  %param_1 = f32[5,6] parameter(1)
  %param_2 = s32[] parameter(2)
  %param_3 = s32[] parameter(3)
  // On CPU the input/output alias, this is resulting in a double free so we
  // need to copy the input.
  %param_0_copy = f32[20,30] copy(%param_0)
  ROOT %fusion = f32[20,30] fusion(%param_0_copy, %param_1, %param_2, %param_3), kind=kLoop, calls=fusion
}

// CHECK:     func.func @main
// CHECK-SAME:  %arg0: tensor<20x30xf32>
// CHECK-SAME:  %arg1: tensor<5x6xf32>
// CHECK-SAME:  %arg2: tensor<i32>
// CHECK-SAME:  %arg3: tensor<i32>
// CHECK-SAME:  %arg4: tensor<20x30xf32>
// CHECK-DAG:   %[[C_24:.*]] = arith.constant 24
// CHECK-DAG:   %[[C_15:.*]] = arith.constant 15
// CHECK-DAG:   %[[C_0:.*]] = arith.constant 0
// CHECK-GPU:   scf.forall (%[[WORKITEM_ID:.*]]) in (30)

// CHECK:     xla.loop
// CHECK-SAME:  -> (%[[RA:.*]], %[[RB:.*]]) in
// CHECK:       %[[I0:.*]] = xla.pure_call @fusion_i0
// CHECK:       %[[I1:.*]] = xla.pure_call @fusion_i1
// CHECK:       %[[IDX0:.*]] = arith.index_cast %[[I0]]
// CHECK:       %[[MIN0:.*]] = arith.minsi %[[IDX0]], %[[C_15]]
// CHECK:       %[[MAX0:.*]] = arith.maxsi %[[MIN0]], %[[C_0]]
// CHECK:       %[[ADD0:.*]] = arith.addi %[[RA]], %[[MAX0]]
// CHECK:       %[[IDX1:.*]] = arith.index_cast %[[I1]]
// CHECK:       %[[MIN1:.*]] = arith.minsi %[[IDX1]], %[[C_24]]
// CHECK:       %[[MAX1:.*]] = arith.maxsi %[[MIN1]], %[[C_0]]
// CHECK:       %[[ADD1:.*]] = arith.addi %[[RB]], %[[MAX1]]
// CHECK:       %[[UPDATE:.*]] = xla.pure_call @fusion_updates
// CHECK:       %[[INSERT:.*]] = tensor.insert %[[UPDATE:.*]] into %{{[a-z0-9]+}}[%[[ADD0]], %[[ADD1]]]
// CHECK:       xla.yield %[[INSERT]]
