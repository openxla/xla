/* Copyright 2025 The OpenXLA Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

#include <cstdint>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <memory>
#include <optional>
#include <sstream>
#include <string>
#include <utility>
#include <vector>

#include "absl/status/statusor.h"
#include "absl/types/span.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/IR/Module.h"
#include "llvm/IRReader/IRReader.h"
#include "llvm/Object/ObjectFile.h"
#include "llvm/Support/Error.h"
#include "llvm/Support/MemoryBuffer.h"
#include "llvm/Support/SourceMgr.h"
#include "llvm/Support/TargetSelect.h"
#include "llvm/TargetParser/Host.h"
#include "xla/util/embedded_constant_buffers.h"

namespace {

struct Args {
  std::string input_path;
  std::string output_object_path;
  std::string output_header_path;
  std::string variable_name;
  std::string namespace_name;
  bool fail_if_no_bitcode;
};

std::optional<Args> ParseArgs(int argc, char* argv[]) {
  if (argc < 6 || argc > 7) {
    return std::nullopt;
  }
  bool fail_if_no_bitcode = false;
  if (argc == 7) {
    if (std::string(argv[6]) == "--fail_if_no_bitcode") {
      fail_if_no_bitcode = true;
    } else {
      return std::nullopt;
    }
  }
  return Args{argv[1], argv[2], argv[3], argv[4], argv[5], fail_if_no_bitcode};
}

llvm::StringRef ExtractBitcodeContent(const llvm::MemoryBuffer& buffer) {
  llvm::StringRef content = buffer.getBuffer();

  // Try to parse as object file to find embedded bitcode
  llvm::Expected<std::unique_ptr<llvm::object::ObjectFile>> obj_or_err =
      llvm::object::ObjectFile::createObjectFile(buffer.getMemBufferRef());

  if (obj_or_err) {
    // Reset to empty to avoid returning a binary blob if we fail to parse.
    content = llvm::StringRef();

    std::unique_ptr<llvm::object::ObjectFile> obj = std::move(obj_or_err.get());
    for (const auto& section : obj->sections()) {
      llvm::Expected<llvm::StringRef> name_or_err = section.getName();
      if (!name_or_err) {
        llvm::consumeError(name_or_err.takeError());
        continue;
      }
      if (*name_or_err == ".llvmbc" || *name_or_err == "__LLVM,__bitcode") {
        llvm::Expected<llvm::StringRef> data_or_err = section.getContents();
        if (!data_or_err) {
          llvm::consumeError(data_or_err.takeError());
          continue;
        }
        content = *data_or_err;
        break;
      }
    }
  } else {
    // Not an object file, check if it's potentially an empty file produced by
    // conditional compilation (e.g. valid empty object).
    // If the input is indeed empty or not an object file, we treat it as
    // empty bitcode.
    llvm::consumeError(obj_or_err.takeError());
    if (content.size() > 0 && content.size() < 4) {
      // Too small to be valid bitcode or object file, ignore.
      content = llvm::StringRef();
    }
  }
  return content;
}

std::string GenerateHeaderContent(const xla::EmbeddedConstantBuffers& buffers,
                                  const Args& args) {
  std::ostringstream os;
  os << "#pragma once\n\n";
  os << "// This file is generated by the cc_to_llvm_ir rule. "
        "Do not edit.\n\n";
  os << "#include <cstdint>\n";
  os << "#include <string>\n";
  os << "#include <utility>\n\n";

  if (!args.namespace_name.empty()) {
    os << "namespace " << args.namespace_name << " {\n\n";
  }

  os << "// LLVM Bitcode compiled for the current architecture\n";

  if (buffers.variable_decls.empty()) {
    std::cerr << "Error: no variable declaration in EmbeddedConstantBuffers.\n";
    std::abort();
  }

  // Use the first var decl (there's only one constant to embed anyway)
  const auto& var_decl = buffers.variable_decls[0];

  os << var_decl.variable_decl << "\n\n";

  os << "inline const std::string " << args.variable_name
     << " = []() -> std::string {\n";
  os << "  std::pair<uint64_t, char*> result = " << var_decl.cpp_access_shim
     << ";\n";
  os << "  return std::string(result.second, result.first);\n";
  os << "}();\n\n";

  if (!args.namespace_name.empty()) {
    os << "}  // namespace " << args.namespace_name << "\n";
  }

  return os.str();
}

}  // namespace

int main(int argc, char* argv[]) {
  llvm::InitializeAllTargetInfos();
  llvm::InitializeAllTargets();
  llvm::InitializeAllTargetMCs();
  llvm::InitializeAllAsmParsers();
  llvm::InitializeAllAsmPrinters();

  std::optional<Args> args = ParseArgs(argc, argv);
  if (!args) {
    std::cerr << "Usage: " << argv[0]
              << " <input_file> <output_object_file> <output_header_file> "
                 "<variable_name> <namespace> [--fail_if_no_bitcode]\n";
    return 1;
  }

  auto buffer_or_err = llvm::MemoryBuffer::getFile(args->input_path);
  if (!buffer_or_err) {
    std::cerr << "Error: Could not open input file " << args->input_path << ": "
              << buffer_or_err.getError().message() << "\n";
    return 1;
  }
  std::unique_ptr<llvm::MemoryBuffer> buffer = std::move(buffer_or_err.get());

  if (buffer->getBuffer().empty()) {
    std::cerr << "Info: Input file " << args->input_path << " is empty.\n";
  }

  llvm::StringRef content = ExtractBitcodeContent(*buffer);

  // Handle empty bitcode correctly (e.g. for MacOS/Windows bypass)
  if (content.empty()) {
    if (!buffer->getBuffer().empty()) {
      std::cerr << "Info: Input file " << args->input_path
                << " contains no bitcode.\n";
    }
    if (args->fail_if_no_bitcode) {
      std::cerr << "Error: No bitcode found in " << args->input_path
                << " and --fail_if_no_bitcode was specified.\n";
      return 1;
    }

    std::ofstream header_file(args->output_header_path);
    if (!header_file) {
      std::cerr << "Error: Could not open output header file "
                << args->output_header_path << "\n";
      return 1;
    }
    header_file << "#pragma once\n\n#include <cstdint>\n#include <string>\n\n";
    if (!args->namespace_name.empty()) {
      header_file << "namespace " << args->namespace_name << " {\n";
    }
    header_file << "inline const std::string " << args->variable_name << ";\n";
    if (!args->namespace_name.empty()) {
      header_file << "}  // namespace " << args->namespace_name << "\n";
    }
    header_file.close();

    std::ofstream object_file(args->output_object_path);
    object_file.close();
    return 0;
  }

  // We need to determine the target triple.
  llvm::SMDiagnostic err;
  llvm::LLVMContext context;
  std::unique_ptr<llvm::Module> module;

  std::string target_triple = llvm::sys::getDefaultTargetTriple();

  if (!content.empty()) {
    // Attempt to parse the bitcode to extract its target triple.
    std::unique_ptr<llvm::MemoryBuffer> bitcode_buffer =
        llvm::MemoryBuffer::getMemBuffer(content, "<embedded_bitcode>",
                                         /*RequiresNullTerminator=*/false);
    module = llvm::parseIR(bitcode_buffer->getMemBufferRef(), err, context);
    if (module && !module->getTargetTriple().str().empty()) {
      target_triple = module->getTargetTriple().str();
    }
  }

  // Wrap the content into a ConstantToEmbed.
  xla::ConstantToEmbed constant_to_embed;
  constant_to_embed.symbol_prefix = args->variable_name;
  std::vector<uint8_t> content_vec(content.begin(), content.end());
  constant_to_embed.SerializeIntoBuffer(content_vec);

  std::vector<xla::ConstantToEmbed> constants;
  constants.push_back(std::move(constant_to_embed));
  auto embedded_buffers = xla::CreateEmbeddedConstantBuffers(
      target_triple, absl::MakeSpan(constants));

  if (!embedded_buffers.ok()) {
    std::cerr << "Error: Failed to create embedded constant buffer: "
              << embedded_buffers.status().ToString() << "\n";
    return 1;
  }

  // Write object file
  std::ofstream object_file(args->output_object_path, std::ios::binary);
  if (!object_file) {
    std::cerr << "Error: Could not open output object file "
              << args->output_object_path << "\n";
    return 1;
  }
  object_file.write(embedded_buffers->object_file_data.data(),
                    embedded_buffers->object_file_data.size());
  object_file.close();

  // Write header file
  std::string header_content = GenerateHeaderContent(*embedded_buffers, *args);
  std::ofstream header_file(args->output_header_path);
  if (!header_file) {
    std::cerr << "Error: Could not open output header file "
              << args->output_header_path << "\n";
    return 1;
  }
  header_file << header_content;
  header_file.close();

  return 0;
}
