# Copyright 2025 The OpenXLA Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================
"""Generates golden_baselines.h using mpmath."""

from collections.abc import Sequence
import dataclasses
import math
import os
import struct
import sys
from typing import Any, Callable

import mpmath

# Configure mpmath for high precision
mpmath.mp.dps = 50

_LICENSE_HEADER = """/* Copyright 2025 The OpenXLA Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/"""

_SCRIPT_TARGET = "//tensorflow/compiler/xla/codegen/intrinsic/accuracy:generate_golden_baselines"

_HEADER_TEMPLATE = """{license}

// DO NOT EDIT THIS FILE DIRECTLY.
// This file is generated by generate_golden_baselines.py.
// To regenerate:
//     bazel run {script_target}

#ifndef TENSORFLOW_COMPILER_XLA_CODEGEN_INTRINSIC_ACCURACY_GOLDEN_BASELINES_H_
#define TENSORFLOW_COMPILER_XLA_CODEGEN_INTRINSIC_ACCURACY_GOLDEN_BASELINES_H_

#include <array>
#include <limits>

namespace xla::codegen::intrinsic::accuracy {{

struct RefPoint {{
  double input;
  float expected_f32;
  double expected_f64;
}};

{array_decls}

}}  // namespace xla::codegen::intrinsic::accuracy

#endif  // TENSORFLOW_COMPILER_XLA_CODEGEN_INTRINSIC_ACCURACY_GOLDEN_BASELINES_H_
"""

_SOURCE_TEMPLATE = """{license}

// DO NOT EDIT THIS FILE DIRECTLY.
// This file is generated by generate_golden_baselines.py.
// To regenerate:
//     bazel run {script_target}

#include "third_party/tensorflow/compiler/xla/codegen/intrinsic/accuracy/golden_baselines.h"
#include <array>
#include <limits>

namespace xla::codegen::intrinsic::accuracy {{

{array_defs}

}}  // namespace xla::codegen::intrinsic::accuracy
"""

_ARRAY_DECL_TEMPLATE = """// {func_name}: {count} reference points
extern const std::array<RefPoint, {count}> kGolden{func_title};"""

_ARRAY_DEF_TEMPLATE = """// {func_name}: {count} reference points
extern const std::array<RefPoint, {count}> kGolden{func_title} = {{{{
{elements}
}}}};"""


@dataclasses.dataclass
class FunctionSpec:
  """Specifies a function to generate golden baselines for.

  Attributes:
    name: The name of the function (e.g., "tanh", "exp").
    impl: The high-precision implementation of the function, typically from
      `mpmath`.
    points: A list of float input values to test.
    domain_predicate: An optional callable that takes a float and returns True
      if the point is within the function's domain, False otherwise. Points for
      which this returns False will be skipped.
  """

  name: str
  impl: Callable[[Any], Any]
  points: Sequence[float]
  domain_predicate: Callable[[float], bool] | None = None


def _fmt_float(val: float, is_f32: bool = False) -> str:
  """Formats a float as a human-readable string or exact hex float."""
  type_str = "float" if is_f32 else "double"
  suffix = "f" if is_f32 else ""
  if math.isnan(val):
    return f"std::numeric_limits<{type_str}>::quiet_NaN()"
  if math.isinf(val):
    sign = "-" if val < 0 else ""
    return f"{sign}std::numeric_limits<{type_str}>::infinity()"

  # Handle signed zero
  if val == 0.0:
    s = "-0.0" if math.copysign(1.0, val) < 0 else "0.0"
    return s + suffix

  # Variable precision for human readability
  s = f"{val:.17g}" if not is_f32 else f"{val:.9g}"
  # If it round-trips exactly and is short, use it.
  try:
    if float(s) == val and len(s) < 18:
      if "." not in s and "e" not in s:
        s += ".0"
      return s + suffix
  except ValueError:
    pass

  return val.hex() + suffix


def _compute_reference(spec: FunctionSpec, x: float) -> float:
  """Computes the reference value for x using the spec."""

  try:
    result = spec.impl(mpmath.mpf(x))
    if isinstance(result, mpmath.mpc):
      return float("nan")
    return float(result)
  except (ArithmeticError, ValueError):
    return float("nan")


def _arange(start: float, stop: float, step: float) -> list[float]:
  """Generates a list of floats from start to stop (exclusive) with step."""
  num_steps = int((stop - start) / step)
  return [start + i * step for i in range(num_steps)]


def _get_samples(spec: FunctionSpec) -> list[float]:
  """Returns a list of sample points for the given function."""
  unique_points = {}
  for x in spec.points:
    # Filter based on domain
    if spec.domain_predicate and not spec.domain_predicate(x):
      continue

    # Deduplicate using hex key
    key = x.hex() if not math.isnan(x) else "NAN"
    unique_points.setdefault(key, x)

  # Sort for determinism
  return sorted(
      unique_points.values(),
      key=lambda v: (math.isnan(v), v, math.copysign(1.0, v)),
  )


def _generate_cpp_code(spec: FunctionSpec) -> tuple[str, str]:
  """Generates declaration and definition strings for C++.

  Args:
    spec: A FunctionSpec object containing the function details.

  Returns:
    A tuple containing two strings: the C++ array declaration and the C++ array
    definition.
  """
  samples = _get_samples(spec)
  elements = []

  for x in samples:
    try:
      x_f32 = struct.unpack("!f", struct.pack("!f", x))[0]
    except OverflowError:
      x_f32 = float("nan")

    y_f32 = (
        _compute_reference(spec, x_f32)
        if not math.isnan(x_f32)
        else float("nan")
    )
    if not math.isnan(y_f32) and not math.isinf(y_f32):
      try:
        y_f32 = struct.unpack("!f", struct.pack("!f", y_f32))[0]
      except OverflowError:
        y_f32 = math.copysign(float("inf"), y_f32)

    y_f64 = _compute_reference(spec, x)
    elements.append(
        f"    RefPoint{{{_fmt_float(x)}, {_fmt_float(y_f32, is_f32=True)},"
        f" {_fmt_float(y_f64)}}}"
    )

  func_title = spec.name.title().replace("1P", "1p")
  count = len(elements)

  decl = _ARRAY_DECL_TEMPLATE.format(
      func_name=spec.name, func_title=func_title, count=count
  )

  defs = _ARRAY_DEF_TEMPLATE.format(
      func_name=spec.name,
      func_title=func_title,
      count=count,
      elements=",\n".join(elements),
  )
  return decl, defs


# --- Reusable Sampling Constants ---

# Common special values
_SPECIAL_VALUES = [
    0.0,
    -0.0,
    float("inf"),
    float("-inf"),
    float("nan"),
    5e-324,
    -5e-324,
    1e-300,
    -1e-300,  # Subnormals
    1.0,
    -1.0,
    0.5,
    -0.5,
    2.0,
    -2.0,
    0.25,
    0.125,  # Powers of 2
    10.0,
    -10.0,
    100.0,
    -100.0,
    0.001,
    -0.001,  # Powers of 10
]

# Logspace points
_LOG_SPACE_NEAR_ZERO = [2.0**-i for i in range(1, 40, 2)] + [
    -(2.0**-i) for i in range(1, 40, 2)
]
_LOG_SPACE_NEAR_BOUNDS = []
for i in range(1, 10, 2):
  _LOG_SPACE_NEAR_BOUNDS.extend([
      2.0 ** (127 - i),
      -(2.0 ** (127 - i)),
      2.0 ** (1023 - i),
      -(2.0 ** (1023 - i)),
  ])

_COMMON_POINTS = _SPECIAL_VALUES + _LOG_SPACE_NEAR_ZERO + _LOG_SPACE_NEAR_BOUNDS

# Range Definitions
_EXP_POINTS = _arange(-800.0, 800.0, 20.0) + _arange(-10.0, 10.0, 0.2)

_LOG_POINTS = (
    _arange(0.1, 100.0, 1.0)
    + _arange(0.0001, 100.0, 1.0)
    + _arange(1.0, 1000.0, 20.0)
)

_TRIG_POINTS = (
    _arange(-15.0, 15.0, 0.4)
    + _arange(-1.0, 1.0, 0.04)
    + _arange(-5000.0, 5000.0, 400.0)
)


def main(argv: Sequence[str]):
  if len(argv) > 1:
    sys.exit(f"Unexpected command line arguments: {argv[1:]}")

  functions = [
      FunctionSpec("tanh", mpmath.tanh, _COMMON_POINTS + _TRIG_POINTS),
      FunctionSpec("exp", mpmath.exp, _COMMON_POINTS + _EXP_POINTS),
      FunctionSpec("log", mpmath.log, _COMMON_POINTS + _LOG_POINTS),
      FunctionSpec("log1p", mpmath.log1p, _COMMON_POINTS + _LOG_POINTS),
      FunctionSpec(
          "rsqrt",
          lambda x: 1.0 / mpmath.sqrt(x),
          _COMMON_POINTS + _LOG_POINTS,
      ),
      FunctionSpec("sqrt", mpmath.sqrt, _COMMON_POINTS + _LOG_POINTS),
      FunctionSpec("erf", mpmath.erf, _COMMON_POINTS + _TRIG_POINTS),
      FunctionSpec("sin", mpmath.sin, _COMMON_POINTS + _TRIG_POINTS),
      FunctionSpec("cos", mpmath.cos, _COMMON_POINTS + _TRIG_POINTS),
      FunctionSpec("tan", mpmath.tan, _COMMON_POINTS + _TRIG_POINTS),
      FunctionSpec("asin", mpmath.asin, _COMMON_POINTS + _TRIG_POINTS),
      FunctionSpec("acos", mpmath.acos, _COMMON_POINTS + _TRIG_POINTS),
      FunctionSpec("atan", mpmath.atan, _COMMON_POINTS + _TRIG_POINTS),
      FunctionSpec("sinh", mpmath.sinh, _COMMON_POINTS + _EXP_POINTS),
      FunctionSpec("cosh", mpmath.cosh, _COMMON_POINTS + _EXP_POINTS),
      FunctionSpec("asinh", mpmath.asinh, _COMMON_POINTS + _EXP_POINTS),
      FunctionSpec("acosh", mpmath.acosh, _COMMON_POINTS + _EXP_POINTS),
      FunctionSpec("atanh", mpmath.atanh, _COMMON_POINTS + _EXP_POINTS),
      FunctionSpec("expm1", mpmath.expm1, _COMMON_POINTS + _EXP_POINTS),
  ]

  decls = []
  defs = []

  for spec in functions:
    d, f = _generate_cpp_code(spec)
    decls.append(d)
    defs.append(f)

  # Determine output directory
  workspace_dir = os.environ.get("BUILD_WORKSPACE_DIRECTORY")
  if workspace_dir:
    output_dir = os.path.join(
        workspace_dir,
        "third_party/tensorflow/compiler/xla/codegen/intrinsic/accuracy",
    )
  else:
    output_dir = "."

  with open(os.path.join(output_dir, "golden_baselines.h"), "w") as f:
    f.write(
        _HEADER_TEMPLATE.format(
            license=_LICENSE_HEADER,
            array_decls="\n".join(decls),
            script_target=_SCRIPT_TARGET,
        )
    )

  with open(os.path.join(output_dir, "golden_baselines.cc"), "w") as f:
    f.write(
        _SOURCE_TEMPLATE.format(
            license=_LICENSE_HEADER,
            array_defs="\n\n".join(defs),
            script_target=_SCRIPT_TARGET,
        )
    )


if __name__ == "__main__":
  main(sys.argv)
