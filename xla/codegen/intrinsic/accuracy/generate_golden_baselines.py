# Copyright 2025 The OpenXLA Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================
"""Generates golden_baselines.h using mpmath."""

import math
from typing import List

import mpmath

# Configure mpmath for high precision
mpmath.mp.dps = 50

HEADER_TEMPLATE = """/* Copyright 2025 The OpenXLA Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

// DO NOT EDIT THIS FILE DIRECTLY.
// This file is generated by generate_golden_baselines.py.
// To regenerate:
//     python3 generate_golden_baselines.py > golden_baselines.h

#ifndef TENSORFLOW_COMPILER_XLA_CODEGEN_INTRINSIC_ACCURACY_GOLDEN_BASELINES_H_
#define TENSORFLOW_COMPILER_XLA_CODEGEN_INTRINSIC_ACCURACY_GOLDEN_BASELINES_H_

#include <array>
#include <limits>

namespace xla::codegen::intrinsic::accuracy {{

struct RefPoint {{
  double input;
  double expected;
}};

{arrays}

}}  // namespace xla::codegen::intrinsic::accuracy

#endif  // TENSORFLOW_COMPILER_XLA_CODEGEN_INTRINSIC_ACCURACY_GOLDEN_BASELINES_H_
"""

ARRAY_TEMPLATE = """// {func_name}: {count} reference points
inline constexpr std::array<RefPoint, {count}> kGolden{func_name_title} = {{{{
{elements}
}}}};"""

# Functions that preserve signed zero: f(-0.0) = -0.0
_SIGN_PRESERVING_AT_ZERO = frozenset({
    "tanh",
    "sin",
    "asin",
    "atan",
    "sinh",
    "asinh",
    "atanh",
    "expm1",
    "log1p",
    "tan",
    "sqrt",
})


def fmt_float(val: float) -> str:
  """Formats a float as a human-readable string or exact hex float."""
  if math.isnan(val):
    return "std::numeric_limits<double>::quiet_NaN()"
  if math.isinf(val):
    if val > 0:
      return "std::numeric_limits<double>::infinity()"
    else:
      return "-std::numeric_limits<double>::infinity()"

  # If it's zero, handle signed zero carefully
  if val == 0.0:
    if math.copysign(1.0, val) < 0:
      return "-0.0"
    return "0.0"

  # Try simple decimal notation
  s = str(val)
  # Heuristic: if decimal is short and mostly standard, use it.
  # Otherwise use hex for precision.
  if len(s) < 12 and "e" not in s:
    # Verify round-trip equality just to be safe
    try:
      if float(s) == val:
        return s
    except ValueError:
      pass

  return val.hex()


def compute_reference(func_name: str, mp_func, x: float) -> float:
  """Computes the reference value for x using mp_func."""
  # Handle signed zero for specific functions
  if x == 0.0:
    if math.copysign(1.0, x) < 0:
      if func_name == "rsqrt":
        return float("-inf")
      if func_name in _SIGN_PRESERVING_AT_ZERO:
        return -0.0
    else:
      if func_name == "rsqrt":
        return float("inf")

  try:
    # Convert input to mpf
    mp_x = mpmath.mpf(x)
    result = mp_func(mp_x)

    # Check for complex result
    if isinstance(result, mpmath.mpc):
      return float("nan")

    return float(result)
  except (ArithmeticError, ValueError):
    # Capture only math domain errors or value errors
    return float("nan")
  # Let other exceptions propagate (e.g., KeyboardInterrupt, or logic bugs)


def generate_points(func_name: str, mp_func, samples: List[float]) -> str:
  """Generates the C++ array content for a single function."""

  # Deduplicate points
  # Key is hex representation to distinguish -0.0 from 0.0, except NaN
  unique_points = {}

  for x in samples:
    # Use hex as key for uniqueness to handle -0.0 vs 0.0
    hex_key = x.hex() if not math.isnan(x) else "NAN"
    if hex_key not in unique_points:
      unique_points[hex_key] = x

  # Sort by key for determinism
  sorted_inputs = sorted(
      unique_points.values(),
      key=lambda v: (math.isnan(v), v, math.copysign(1.0, v)),
  )

  elements = []
  for i, x in enumerate(sorted_inputs):
    y = compute_reference(func_name, mp_func, x)

    # Use nicely formatted floats
    input_str = fmt_float(x)
    output_str = fmt_float(y)

    comma = "," if i < len(sorted_inputs) - 1 else ""
    line = f"    RefPoint{{{input_str}, {output_str}}}{comma}"
    elements.append(line)

  func_name_title = func_name.title().replace("1P", "1p")

  return ARRAY_TEMPLATE.format(
      func_name=func_name,
      func_name_title=func_name_title,
      count=len(elements),
      elements="\n".join(elements),
  )


def get_samples(func_name: str) -> List[float]:
  """Returns a list of sample points for the given function."""
  common_special = [0.0, -0.0, float("inf"), float("-inf"), float("nan")]

  # Subnormals (smallest positive, etc)
  subnormals = [
      5e-324,  # Min subnormal
      -5e-324,
      1e-300,
      -1e-300,
  ]

  f16_special = [
      1.0,
      -1.0,
      0.5,
      -0.5,
      2.0,
      -2.0,
      0.25,
      0.125,
      10.0,
      -10.0,
      100.0,
      -100.0,
      0.001,
      -0.001,
  ]

  samples = common_special + subnormals + f16_special

  # Reduced sampling rate (approx 50% fewer points)

  # Linear space
  if func_name in ["exp", "expm1", "sinh", "cosh"]:
    # -800 to 800, step 200 (was 100)
    samples.extend([x * 0.1 for x in range(-8000, 8000, 200)])
    # -10 to 10, step 20 (was 10)
    samples.extend([x * 0.01 for x in range(-1000, 1000, 20)])
  elif func_name in ["log", "log1p", "sqrt", "rsqrt"]:
    samples.extend([x * 0.1 for x in range(1, 1000, 10)])
    samples.extend([x * 0.0001 for x in range(1, 1000, 10)])
    samples.extend([x * 1.0 for x in range(1, 1000, 20)])
  else:
    # Tanh, Erf, etc
    samples.extend([x * 0.1 for x in range(-150, 150, 4)])
    samples.extend([x * 0.01 for x in range(-100, 100, 4)])
    samples.extend([x * 100.0 for x in range(-50, 50, 4)])

  # Logspace near zero
  # Reduced density: step 2
  for i in range(1, 40, 2):
    samples.append(2.0**-i)
    samples.append(-(2.0**-i))

  # Logspace near bounds
  for i in range(1, 10, 2):
    samples.append(2.0 ** (127 - i))
    samples.append(-(2.0 ** (127 - i)))
    samples.append(2.0 ** (1023 - i))
    samples.append(-(2.0 ** (1023 - i)))

  # Filter samples for rsqrt
  if func_name == "rsqrt":
    # Rsqrt is only defined for x >= -0.0.
    # Exclude all other negatives (finite) to avoid ambiguous behavior.
    # Keep -0.0, -inf, nan.
    # In python:
    #   (-1.0 < 0) is True
    #   (-0.0 < 0) is False
    #   (-inf < 0) is True
    #   (nan < 0) is False
    # math.isnan check is safer.

    # Check nan behavior: `nan < 0` is False. `nan >= 0` is False.
    # So `x >= 0` removes nan.
    # Should Include nan explicitly.
    samples = [x for x in samples if x >= 0 or math.isinf(x) or math.isnan(x)]

  return samples


def main():
  functions = [
      ("tanh", mpmath.tanh),
      ("exp", mpmath.exp),
      ("log", mpmath.log),
      ("log1p", mpmath.log1p),
      ("rsqrt", lambda x: 1.0 / mpmath.sqrt(x)),
      ("sqrt", mpmath.sqrt),
      ("erf", mpmath.erf),
      # Add others as needed, these are the ops in HLO.
      ("sin", mpmath.sin),
      ("cos", mpmath.cos),
      ("tan", mpmath.tan),
      ("asin", mpmath.asin),
      ("acos", mpmath.acos),
      ("atan", mpmath.atan),
      ("sinh", mpmath.sinh),
      ("cosh", mpmath.cosh),
      ("asinh", mpmath.asinh),
      ("acosh", mpmath.acosh),
      ("atanh", mpmath.atanh),
      ("expm1", mpmath.expm1),
  ]

  arrays = []
  for name, mp_func in functions:
    samples = get_samples(name)
    arrays.append(generate_points(name, mp_func, samples))

  print(HEADER_TEMPLATE.format(arrays="\n\n".join(arrays)))


if __name__ == "__main__":
  main()
