/* Copyright 2025 The OpenXLA Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

#ifndef XLA_SERVICE_SOURCE_TARGET_PAIRS_H_
#define XLA_SERVICE_SOURCE_TARGET_PAIRS_H_

#include <cstdint>
#include <string>
#include <utility>
#include <vector>

#include "absl/container/inlined_vector.h"
#include "absl/log/check.h"

namespace xla {

class SourceTargetPairs {
  struct SourceTargetPair {
    int64_t source;
    int64_t target;
  };

 public:
  SourceTargetPairs() = default;

  explicit SourceTargetPairs(
      const std::vector<std::pair<int64_t, int64_t>>& pairs) {
    for (const auto& pair : pairs) {
      pairs_.push_back({.source = pair.first, .target = pair.second});
    }
  }

  // Returns a cannoical string such as {{0,1},{1,2},{2,3},{3,0}}.
  std::string ToString() const;

  SourceTargetPair& operator[](int64_t i) {
    CHECK_LT(i, pairs_.size())
        << "Index out of bounds. Size: " << pairs_.size() << " Index: " << i;
    return pairs_[i];
  }
  const SourceTargetPair& operator[](int64_t i) const {
    CHECK_LT(i, pairs_.size())
        << "Index out of bounds. Size: " << pairs_.size() << " Index: " << i;
    return pairs_[i];
  }

  int64_t size() const { return pairs_.size(); }

  std::vector<std::pair<int64_t, int64_t>> data() const {
    std::vector<std::pair<int64_t, int64_t>> data;
    for (const auto& pair : pairs_) {
      data.push_back({pair.source, pair.target});
    }
    return data;
  }

  // Returns true if the (source, target) relationship has a cycle.
  bool HasCycles();

  // Returns true if the (source, target) pairs form a forward cycle with all
  // participants in the cycle, such as {{0,1},{1,2},{2,3},{3,0}}. We assume
  // that the (source, target) pairs are ordered via increasing source IDs, as
  // they are currently generated by SPMD partitioning.
  static bool IsForwardCycle(const SourceTargetPairs& backedge,
                             const SourceTargetPairs& others);

  // Returns true if the (source, target) pairs form a backward cycle with all
  // participants in the cycle, such as {{0,3},{1,0},{2,1},{3,2}}. We assume
  // that the (source, target) pairs are ordered via increasing source IDs, as
  // they are currently generated by SPMD partitioning.
  static bool IsBackwardCycle(const SourceTargetPairs& backedge,
                              const SourceTargetPairs& others);

 private:
  static constexpr int64_t kInlineFactor = 8;
  absl::InlinedVector<SourceTargetPair, kInlineFactor> pairs_;
};

}  // namespace xla
#endif  // XLA_SERVICE_SOURCE_TARGET_PAIRS_H_
